{
  "language": "Solidity",
  "sources": {
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./RewardsDistributorDelegate.sol\";\nimport \"./IFuseFeeDistributor.sol\";\n\nimport \"../oracles/default/IKeydonixUniswapTwapPriceOracle.sol\";\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(CToken cToken);\n\n  /// @notice Emitted when an admin unsupports a market\n  event MarketUnlisted(CToken cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(CToken cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(CToken cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  /// @notice Emitted when an action is paused globally\n  event ActionPaused(string action, bool pauseState);\n\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(CToken cToken, string action, bool pauseState);\n\n  /// @notice Emitted when the whitelist enforcement is changed\n  event WhitelistEnforcementChanged(bool enforce);\n\n  /// @notice Emitted when auto implementations are toggled\n  event AutoImplementationsToggled(bool enabled);\n\n  /// @notice Emitted when supply cap for a cToken is changed\n  event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n  event AddedRewardsDistributor(address rewardsDistributor);\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  // liquidationIncentiveMantissa must be no less than this value\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n  // liquidationIncentiveMantissa must be no greater than this value\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n  constructor(address payable _fuseAdmin) {\n    fuseAdmin = _fuseAdmin;\n  }\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n   * @param account The address of the account to pull assets for\n   * @return A dynamic list with the assets the account has entered\n   */\n  function getAssetsIn(address account) external view returns (CToken[] memory) {\n    CToken[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n   * @param account The address of the account to check\n   * @param cToken The cToken to check\n   * @return True if the account is in the asset, otherwise false.\n   */\n  function checkMembership(address account, CToken cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n   * @param cTokens The list of addresses of the cToken markets to be enabled\n   * @return Success indicator for whether each corresponding market was entered\n   */\n  function enterMarkets(address[] memory cTokens) public override returns (uint256[] memory) {\n    uint256 len = cTokens.length;\n\n    uint256[] memory results = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      CToken cToken = CToken(cTokens[i]);\n\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n   * @param cToken The market to enter\n   * @param borrower The address of the account to modify\n   * @return Success indicator for whether the market was entered\n   */\n  function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    // Add to allBorrowers\n    if (!borrowers[borrower]) {\n      allBorrowers.push(borrower);\n      borrowers[borrower] = true;\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\n    }\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n   * @dev Sender must not have an outstanding borrow balance in the asset,\n   *  or be providing neccessary collateral for an outstanding borrow.\n   * @param cTokenAddress The address of the asset to be removed\n   * @return Whether or not the account successfully exited the market\n   */\n  function exitMarket(address cTokenAddress) external override returns (uint256) {\n    CToken cToken = CToken(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[address(cToken)];\n\n    /* Return true if the sender is not already ‘in’ the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the account’s list of assets */\n    // load into memory for faster iteration\n    CToken[] memory userAssetList = accountAssets[msg.sender];\n    uint256 len = userAssetList.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (userAssetList[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    CToken[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    // If the user has exited all markets, remove them from the `allBorrowers` array\n    if (storedList.length == 0) {\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n      allBorrowers.pop(); // Reduce length by 1\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n    }\n\n    emit MarketExited(cToken, msg.sender);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n   * @param cToken The market to verify the mint against\n   * @param minter The account which would get the minted tokens\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n    // Shh - currently unused\n    minter;\n    mintAmount;\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure minter is whitelisted\n    if (enforceWhitelist && !whitelist[minter]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    // Check supply cap\n    uint256 supplyCap = supplyCaps[cToken];\n    // Supply cap of 0 corresponds to unlimited supplying\n    if (supplyCap != 0) {\n      uint256 totalCash = CToken(cToken).getCash();\n      uint256 totalBorrows = CToken(cToken).totalBorrows();\n      uint256 totalReserves = CToken(cToken).totalReserves();\n      uint256 totalFuseFees = CToken(cToken).totalFuseFees();\n      uint256 totalAdminFees = CToken(cToken).totalAdminFees();\n\n      // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)\n      (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(\n        totalCash,\n        totalBorrows,\n        add_(add_(totalReserves, totalFuseFees), totalAdminFees)\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      uint256 nextTotalUnderlyingSupply;\n      (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, minter);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n   * @param cToken Asset being minted\n   * @param minter The address minting the tokens\n   * @param actualMintAmount The amount of the underlying asset being minted\n   * @param mintTokens The number of tokens being minted\n   */\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 actualMintAmount,\n    uint256 mintTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    minter;\n    actualMintAmount;\n    mintTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n\n    // Add minter to suppliers mapping\n    suppliers[minter] = true;\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n   * @param cToken The market to verify the redeem against\n   * @param redeemer The account which would redeem the tokens\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external override returns (uint256) {\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, redeemer);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) internal view returns (uint256) {\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      redeemer,\n      CToken(cToken),\n      redeemTokens,\n      0\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n   * @param cToken Asset being redeemed\n   * @param redeemer The address redeeming the tokens\n   * @param redeemAmount The amount of the underlying asset being redeemed\n   * @param redeemTokens The number of tokens being redeemed\n   */\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    redeemer;\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"redeemTokens zero\");\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken The market to verify the borrow against\n   * @param borrower The account which would borrow the asset\n   * @param borrowAmount The amount of underlying the account would borrow\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"sender must be cToken\");\n\n      // attempt to add borrower to the market\n      Error err = addToMarketInternal(CToken(msg.sender), borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    // Make sure oracle price is available\n    if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n      return uint256(Error.PRICE_ERROR);\n    }\n\n    // Make sure borrower is whitelisted\n    if (enforceWhitelist && !whitelist[borrower]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    // Check borrow cap\n    uint256 borrowCap = borrowCaps[cToken];\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0) {\n      uint256 totalBorrows = CToken(cToken).totalBorrows();\n      (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n      require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    // Perform a hypothetical liquidity check to guard against shortfall\n    (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      borrower,\n      CToken(cToken),\n      0,\n      borrowAmount\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n   */\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external override returns (uint256) {\n    // Check if min borrow exists\n    uint256 minBorrowEth = IFuseFeeDistributor(fuseAdmin).minBorrowEth();\n\n    if (minBorrowEth > 0) {\n      // Get new underlying borrow balance of account for this cToken\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(CToken(cToken));\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\n        Exp({ mantissa: oraclePriceMantissa }),\n        accountBorrowsNew\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      // Check against min borrow\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\n    }\n\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param exchangeRateMantissa Underlying/cToken exchange rate\n   * @param accountTokens Initial account cToken balance\n   * @param accountTokens Underlying amount to mint\n   */\n  function mintWithinLimits(\n    address cToken,\n    uint256 exchangeRateMantissa,\n    uint256 accountTokens,\n    uint256 mintAmount\n  ) external override returns (uint256) {\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates borrow and reverts on rejection. May emit logs.\n   * @param cToken Asset whose underlying is being borrowed\n   * @param borrower The address borrowing the underlying\n   * @param borrowAmount The amount of the underlying asset requested to borrow\n   */\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    borrower;\n    borrowAmount;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n   * @param cToken The market to verify the repay against\n   * @param payer The account which would repay the asset\n   * @param borrower The account which would borrowed the asset\n   * @param repayAmount The amount of the underlying asset the account would repay\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Shh - currently unused\n    payer;\n    borrower;\n    repayAmount;\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n   * @param cToken Asset being repaid\n   * @param payer The address repaying the borrow\n   * @param borrower The address of the borrower\n   * @param actualRepayAmount The amount of underlying being repaid\n   */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 borrowerIndex\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    payer;\n    borrower;\n    actualRepayAmount;\n    borrowerIndex;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Shh - currently unused\n    liquidator;\n\n    // Make sure markets are listed\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Get borrowers's underlying borrow balance\n    uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(CToken(cTokenBorrowed))) {\n      require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n    } else {\n      /* The borrower must have shortfall in order to be liquidatable */\n      (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      if (shortfall == 0) {\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n      if (repayAmount > maxClose) {\n        return uint256(Error.TOO_MUCH_REPAY);\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param actualRepayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 seizeTokens\n  ) external override {\n    // Shh - currently unused\n    cTokenBorrowed;\n    cTokenCollateral;\n    liquidator;\n    borrower;\n    actualRepayAmount;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"seize is paused\");\n\n    // Shh - currently unused\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Make sure markets are listed\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure cToken Comptrollers are identical\n    if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n      return uint256(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates seize and reverts on rejection. May emit logs.\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override {\n    // Shh - currently unused\n    cTokenCollateral;\n    cTokenBorrowed;\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n   * @param cToken The market to verify the transfer against\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"transfer is paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cToken, src, dst);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates transfer and reverts on rejection. May emit logs.\n   * @param cToken Asset being transferred\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   */\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    src;\n    dst;\n    transferTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /*** Flywheel Hooks ***/\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(\n    address cToken,\n    address src,\n    address dst\n  ) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n   */\n  struct AccountLiquidityLocalVars {\n    uint256 sumCollateral;\n    uint256 sumBorrowPlusEffects;\n    uint256 cTokenBalance;\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n    uint256 oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n  }\n\n  /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidity(address account)\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      CToken(address(0)),\n      0,\n      0\n    );\n\n    return (uint256(err), liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidityInternal(address account)\n    internal\n    view\n    returns (\n      Error,\n      uint256,\n      uint256\n    )\n  {\n    return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      CToken(cTokenModify),\n      redeemTokens,\n      borrowAmount\n    );\n    return (uint256(err), liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    CToken cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n    internal\n    view\n    returns (\n      Error,\n      uint256,\n      uint256\n    )\n  {\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n    uint256 oErr;\n\n    // For each asset the account is in\n    CToken[] memory assets = accountAssets[account];\n    for (uint256 i = 0; i < assets.length; i++) {\n      CToken asset = assets[i];\n\n      // Read the balances and exchange rate from the cToken\n      (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n      if (oErr != 0) {\n        // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n        return (Error.SNAPSHOT_ERROR, 0, 0);\n      }\n      vars.collateralFactor = Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\n      vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n      // Get the normalized price of the asset\n      vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n      if (vars.oraclePriceMantissa == 0) {\n        return (Error.PRICE_ERROR, 0, 0);\n      }\n      vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n      // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n      vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n      // sumCollateral += tokensToDenom * cTokenBalance\n      vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n        vars.oraclePrice,\n        vars.borrowBalance,\n        vars.sumBorrowPlusEffects\n      );\n\n      // Calculate effects of interacting with cTokenModify\n      if (asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.tokensToDenom,\n          redeemTokens,\n          vars.sumBorrowPlusEffects\n        );\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.oraclePrice,\n          borrowAmount,\n          vars.sumBorrowPlusEffects\n        );\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n   * @param cTokenBorrowed The address of the borrowed cToken\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view override returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint256(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint256 exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n    return (uint256(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Add a RewardsDistributor contracts.\n   * @dev Admin function to add a RewardsDistributor contract\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK);\n    }\n\n    // Check marker method\n    require(RewardsDistributorDelegate(distributor).isRewardsDistributor(), \"marker method returned false\");\n\n    // Check for existing RewardsDistributor\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      require(distributor != rewardsDistributors[i], \"RewardsDistributor contract already added\");\n\n    // Add RewardsDistributor to array\n    rewardsDistributors.push(distributor);\n    emit AddedRewardsDistributor(distributor);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist enforcement for the comptroller\n   * @dev Admin function to set a new whitelist enforcement boolean\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\n    }\n\n    // Check if `enforceWhitelist` already equals `enforce`\n    if (enforceWhitelist == enforce) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    // Set comptroller's `enforceWhitelist` to `enforce`\n    enforceWhitelist = enforce;\n\n    // Emit WhitelistEnforcementChanged(bool enforce);\n    emit WhitelistEnforcementChanged(enforce);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist `statuses` for `suppliers`\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\n    }\n\n    // Set whitelist statuses for suppliers\n    for (uint256 i = 0; i < suppliers.length; i++) {\n      address supplier = suppliers[i];\n\n      if (statuses[i]) {\n        // If not already whitelisted, add to whitelist\n        if (!whitelist[supplier]) {\n          whitelist[supplier] = true;\n          whitelistArray.push(supplier);\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\n        }\n      } else {\n        // If whitelisted, remove from whitelist\n        if (whitelist[supplier]) {\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\n          whitelistArray.pop(); // Reduce length by 1\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n        }\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets a new price oracle for the comptroller\n   * @dev Admin function to set a new price oracle\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    PriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the closeFactor used when liquidating borrows\n   * @dev Admin function to set closeFactor\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n    }\n\n    // Check limits\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    // Set pool close factor to new close factor, remember old value\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n\n    // Emit event\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the collateralFactor for a market\n   * @dev Admin function to set per-market collateralFactor\n   * @param cToken The market to set the factor on\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCollateralFactor(CToken cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets liquidationIncentive\n   * @dev Admin function to set liquidationIncentive\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Check de-scaled min <= newLiquidationIncentive <= max\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    // Save current value for use in log\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Add the market to the markets mapping and set it as listed\n   * @dev Admin function to set isListed and add support for the market\n   * @param cToken The address of the market (token) to list\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _supportMarket(CToken cToken) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Is market already listed?\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n    // Sanity check to make sure its really a CToken\n    require(cToken.isCToken(), \"marker method returned false\");\n\n    // Check cToken.comptroller == this\n    require(address(cToken.comptroller()) == address(this), \"Cannot support a market with a different Comptroller.\");\n\n    // Make sure market is not already listed\n    address underlying = cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying();\n\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // List market and emit event\n    Market storage market = markets[address(cToken)];\n    market.isListed = true;\n    market.collateralFactorMantissa = 0;\n    allMarkets.push(cToken);\n    cTokensByUnderlying[underlying] = cToken;\n    emit MarketListed(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _deployMarket(\n    bool isCEther,\n    bytes calldata constructorData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Temporarily enable Fuse admin rights for asset deployment (storing the original value)\n    bool oldFuseAdminHasRights = fuseAdminHasRights;\n    fuseAdminHasRights = true;\n\n    // Deploy via Fuse admin\n    CToken cToken = CToken(\n      isCEther\n        ? IFuseFeeDistributor(fuseAdmin).deployCEther(constructorData)\n        : IFuseFeeDistributor(fuseAdmin).deployCErc20(constructorData)\n    );\n    // Reset Fuse admin rights to the original value\n    fuseAdminHasRights = oldFuseAdminHasRights;\n    // Support market here in the Comptroller\n    uint256 err = _supportMarket(cToken);\n\n    // Set collateral factor\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\n  }\n\n  /**\n   * @notice Removed a market from the markets mapping and sets it as unlisted\n   * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n   * @param cToken The address of the market (token) to unlist\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _unsupportMarket(CToken cToken) external returns (uint256) {\n    // Check admin rights\n    if (!hasAdminRights()) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n    // Check if market is already unlisted\n    if (!markets[address(cToken)].isListed)\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n    // Check if market is in use\n    if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n    // Unlist market\n    delete markets[address(cToken)];\n\n    /* Delete cToken from allMarkets */\n    // load into memory for faster iteration\n    CToken[] memory _allMarkets = allMarkets;\n    uint256 len = _allMarkets.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (_allMarkets[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n    allMarkets.pop();\n\n    cTokensByUnderlying[cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying()] = CToken(address(0));\n    emit MarketUnlisted(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles the auto-implementation feature\n   * @param enabled If the feature is to be enabled\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _toggleAutoImplementations(bool enabled) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK);\n    }\n\n    // Return no error if already set to the desired value\n    if (autoImplementation == enabled) return uint256(Error.NO_ERROR);\n\n    // Store autoImplementation with value enabled\n    autoImplementation = enabled;\n\n    // Emit AutoImplementationsToggled(enabled)\n    emit AutoImplementationsToggled(enabled);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n   * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n   * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n   */\n  function _setMarketSupplyCaps(CToken[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n    require(\n      msg.sender == admin || msg.sender == borrowCapGuardian,\n      \"only admin or borrow cap guardian can set supply caps\"\n    );\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numSupplyCaps = newSupplyCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n      emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n   * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n   * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n   */\n  function _setMarketBorrowCaps(CToken[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n    require(\n      msg.sender == admin || msg.sender == borrowCapGuardian,\n      \"only admin or borrow cap guardian can set borrow caps\"\n    );\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numBorrowCaps = newBorrowCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to change the Borrow Cap Guardian\n   * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n   */\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n    require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n    // Save current value for inclusion in log\n    address oldBorrowCapGuardian = borrowCapGuardian;\n\n    // Store borrowCapGuardian with value newBorrowCapGuardian\n    borrowCapGuardian = newBorrowCapGuardian;\n\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n  }\n\n  /**\n   * @notice Admin function to change the Pause Guardian\n   * @param newPauseGuardian The address of the new Pause Guardian\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n    }\n\n    // Save current value for inclusion in log\n    address oldPauseGuardian = pauseGuardian;\n\n    // Store pauseGuardian with value newPauseGuardian\n    pauseGuardian = newPauseGuardian;\n\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    mintGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Mint\", state);\n    return state;\n  }\n\n  function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    borrowGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Borrow\", state);\n    return state;\n  }\n\n  function _setTransferPaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    transferGuardianPaused = state;\n    emit ActionPaused(\"Transfer\", state);\n    return state;\n  }\n\n  function _setSeizePaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    seizeGuardianPaused = state;\n    emit ActionPaused(\"Seize\", state);\n    return state;\n  }\n\n  function _become(Unitroller unitroller) public {\n    require(\n      (msg.sender == address(fuseAdmin) && unitroller.fuseAdminHasRights()) ||\n        (msg.sender == unitroller.admin() && unitroller.adminHasRights()),\n      \"only unitroller admin can change brains\"\n    );\n\n    uint256 changeStatus = unitroller._acceptImplementation();\n    require(changeStatus == 0, \"change not authorized\");\n\n    Comptroller(address(unitroller))._becomeImplementation();\n  }\n\n  function _becomeImplementation() external {\n    require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n    if (!_notEnteredInitialized) {\n      _notEntered = true;\n      _notEnteredInitialized = true;\n    }\n  }\n\n  /*** Helper Functions ***/\n\n  /**\n   * @notice Return all of the markets\n   * @dev The automatic getter may be used to access an individual market.\n   * @return The list of market addresses\n   */\n  function getAllMarkets() public view returns (CToken[] memory) {\n    return allMarkets;\n  }\n\n  /**\n   * @notice Return all of the borrowers\n   * @dev The automatic getter may be used to access an individual borrower.\n   * @return The list of borrower account addresses\n   */\n  function getAllBorrowers() public view returns (address[] memory) {\n    return allBorrowers;\n  }\n\n  /**\n   * @notice Return all of the whitelist\n   * @dev The automatic getter may be used to access an individual whitelist status.\n   * @return The list of borrower account addresses\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    return whitelistArray;\n  }\n\n  /**\n   * @notice Returns an array of all RewardsDistributors\n   */\n  function getRewardsDistributors() external view returns (address[] memory) {\n    return rewardsDistributors;\n  }\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   * @param cToken The market to check if deprecated\n   */\n  function isDeprecated(CToken cToken) public view returns (bool) {\n    return\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\n      borrowGuardianPaused[address(cToken)] == true &&\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.fuseFeeMantissa()) == 1e18;\n  }\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  /**\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _beforeNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"Comptroller:_beforeNonReentrant: caller not listed as market\");\n    require(_notEntered, \"re-entered across assets\");\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _afterNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"Comptroller:_afterNonReentrant: caller not listed as market\");\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n\n  function verifyPrice(address cToken, UniswapOracle.ProofData calldata proofData)\n    public\n    override\n    returns (uint256, uint256)\n  {\n    return IKeydonixUniswapTwapPriceOracle(address(oracle)).verifyPrice(ICToken(cToken), proofData);\n  }\n}\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\n    return\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\n      (msg.sender == address(fuseAdmin) && comptrollerStorage.fuseAdminHasRights());\n  }\n\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param fuseAdmin_ The FuseFeeDistributor contract address.\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    address payable fuseAdmin_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    require(msg.sender == fuseAdmin_, \"only Fuse admin may initialize the market\");\n    require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n    fuseAdmin = fuseAdmin_;\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n    // Set the comptroller\n    uint256 err = _setComptroller(comptroller_);\n    require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == uint256(Error.NO_ERROR), \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // Set reserve factor\n    err = _setReserveFactorFresh(reserveFactorMantissa_);\n    require(err == uint256(Error.NO_ERROR), \"setting reserve factor failed\");\n\n    // Set admin fee\n    err = _setAdminFeeFresh(adminFeeMantissa_);\n    require(err == uint256(Error.NO_ERROR), \"setting admin fee failed\");\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)\n   */\n  function getPendingFuseFeeFromAdmin() internal view returns (uint256) {\n    return IFuseFeeDistributor(fuseAdmin).interestFeeRate();\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint256 tokens\n  ) internal returns (uint256) {\n    /* Fail if transfer not allowed */\n    uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint256 startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint256).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    MathError mathErr;\n    uint256 allowanceNew;\n    uint256 srcTokensNew;\n    uint256 dstTokensNew;\n\n    (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n    }\n\n    (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint256).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override nonReentrant(false) returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant(false) returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n    (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n    require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n    return balance;\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account)\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 cTokenBalance = accountTokens[account];\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n\n    MathError mErr;\n\n    (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint256) {\n    return\n      interestRateModel.getBorrowRate(\n        getCashPrior(),\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint256) {\n    return\n      interestRateModel.getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees)),\n        reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint256) {\n    (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n    require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n    return result;\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n    /* Note: we do not assert that the market is up to date */\n    MathError mathErr;\n    uint256 principalTimesIndex;\n    uint256 result;\n\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    return (MathError.NO_ERROR, result);\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint256) {\n    (MathError err, uint256 result) = exchangeRateStoredInternal();\n    require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n    return result;\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return (error code, calculated exchange rate scaled by 1e18)\n   */\n  function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n    uint256 _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return (MathError.NO_ERROR, initialExchangeRateMantissa);\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply\n       */\n      uint256 totalCash = getCashPrior();\n      uint256 cashPlusBorrowsMinusReserves;\n      Exp memory exchangeRate;\n      MathError mathErr;\n\n      (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n        totalCash,\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n      );\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      return (MathError.NO_ERROR, exchangeRate.mantissa);\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = getBlockNumber();\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumber == currentBlockNumber) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Read the previous values out of storage */\n    uint256 cashPrior = getCashPrior();\n\n    /* Calculate the current borrow interest rate */\n    uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\n      cashPrior,\n      totalBorrows,\n      add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n    );\n    require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    (MathError mathErr, uint256 blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n    require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n    return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n  }\n\n  /**\n   * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n   */\n  function finishInterestAccrual(\n    uint256 currentBlockNumber,\n    uint256 cashPrior,\n    uint256 borrowRateMantissa,\n    uint256 blockDelta\n  ) private returns (uint256) {\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n     *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n    uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n    uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n    uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: reserveFactorMantissa }),\n      interestAccumulated,\n      totalReserves\n    );\n    uint256 totalFuseFeesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: fuseFeeMantissa }),\n      interestAccumulated,\n      totalFuseFees\n    );\n    uint256 totalAdminFeesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: adminFeeMantissa }),\n      interestAccumulated,\n      totalAdminFees\n    );\n    uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n    totalFuseFees = totalFuseFeesNew;\n    totalAdminFees = totalAdminFeesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    return mintFresh(msg.sender, mintAmount);\n  }\n\n  struct MintLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 mintTokens;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n    uint256 actualMintAmount;\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintFresh(address minter, uint256 mintAmount) internal returns (uint256, uint256) {\n    /* Fail if mint not allowed */\n    uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n    }\n\n    MintLocalVars memory vars;\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr)), 0);\n    }\n\n    // Check max supply\n    // unused function\n    /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n      vars.actualMintAmount,\n      Exp({ mantissa: vars.exchangeRateMantissa })\n    );\n    require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     */\n    vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n    vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[minter] = vars.accountTokensNew;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n    emit Transfer(address(this), minter, vars.mintTokens);\n\n    /* We call the defense hook */\n    comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n    return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n    }\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n    }\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, 0, redeemAmount);\n  }\n\n  struct RedeemLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 redeemTokens;\n    uint256 redeemAmount;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemFresh(\n    address redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal returns (uint256) {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n    RedeemLocalVars memory vars;\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n        Exp({ mantissa: vars.exchangeRateMantissa }),\n        redeemTokensIn\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n\n      (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n        redeemAmountIn,\n        Exp({ mantissa: vars.exchangeRateMantissa })\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n\n      vars.redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < vars.redeemAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n    }\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    return borrowFresh(msg.sender, borrowAmount);\n  }\n\n  struct BorrowLocalVars {\n    MathError mathErr;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowFresh(address borrower, uint256 borrowAmount) internal returns (uint256) {\n    /* Fail if borrow not allowed */\n    uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    uint256 cashPrior = getCashPrior();\n\n    if (cashPrior < borrowAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n    }\n\n    BorrowLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowsNew = accountBorrows + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(\n          Error.MATH_ERROR,\n          FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n          uint256(vars.mathErr)\n        );\n    }\n\n    // Check min borrow for this user for this asset\n    allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n    internal\n    nonReentrant(false)\n    returns (uint256, uint256)\n  {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  struct RepayBorrowLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 repayAmount;\n    uint256 borrowerIndex;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n    uint256 actualRepayAmount;\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of undelrying tokens being returned\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) internal returns (uint256, uint256) {\n    /* Fail if repayBorrow not allowed */\n    uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n    }\n\n    RepayBorrowLocalVars memory vars;\n\n    /* We remember the original borrowerIndex for verification purposes */\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return (\n        failOpaque(\n          Error.MATH_ERROR,\n          FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n          uint256(vars.mathErr)\n        ),\n        0\n      );\n    }\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    if (repayAmount == type(uint256).max) {\n      vars.repayAmount = vars.accountBorrows;\n    } else {\n      vars.repayAmount = repayAmount;\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n    return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n    }\n\n    error = cTokenCollateral.accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal returns (uint256, uint256) {\n    /* Fail if liquidate not allowed */\n    uint256 allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      address(cTokenCollateral),\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint256).max) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n    }\n\n    /* Fail if repayBorrow fails */\n    (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n    if (repayBorrowError != uint256(Error.NO_ERROR)) {\n      return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n      address(this),\n      address(cTokenCollateral),\n      actualRepayAmount\n    );\n    require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    uint256 seizeError;\n    if (address(cTokenCollateral) == address(this)) {\n      seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n    }\n\n    /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n    require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n    return (uint256(Error.NO_ERROR), actualRepayAmount);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override nonReentrant(true) returns (uint256) {\n    return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n  }\n\n  struct SeizeInternalLocalVars {\n    MathError mathErr;\n    uint256 borrowerTokensNew;\n    uint256 liquidatorTokensNew;\n    uint256 liquidatorSeizeTokens;\n    uint256 protocolSeizeTokens;\n    uint256 protocolSeizeAmount;\n    uint256 exchangeRateMantissa;\n    uint256 totalReservesNew;\n    uint256 totalFuseFeeNew;\n    uint256 totalSupplyNew;\n    uint256 feeSeizeTokens;\n    uint256 feeSeizeAmount;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) internal returns (uint256) {\n    /* Fail if seize not allowed */\n    uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n    }\n\n    SeizeInternalLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n    vars.feeSeizeTokens = mul_(seizeTokens, Exp({ mantissa: feeSeizeShareMantissa }));\n    vars.liquidatorSeizeTokens = sub_(sub_(seizeTokens, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n    vars.protocolSeizeAmount = mul_ScalarTruncate(\n      Exp({ mantissa: vars.exchangeRateMantissa }),\n      vars.protocolSeizeTokens\n    );\n    vars.feeSeizeAmount = mul_ScalarTruncate(Exp({ mantissa: vars.exchangeRateMantissa }), vars.feeSeizeTokens);\n\n    vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n    vars.totalSupplyNew = sub_(sub_(totalSupply, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n    vars.totalFuseFeeNew = add_(totalFuseFees, vars.feeSeizeAmount);\n\n    (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    totalReserves = vars.totalReservesNew;\n    totalSupply = vars.totalSupplyNew;\n    totalFuseFees = vars.totalFuseFeeNew;\n\n    accountTokens[borrower] = vars.borrowerTokensNew;\n    accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n    emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Internal function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint256) {\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n   * @dev Admin function to accrue interest and set a new admin fee\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setAdminFee(uint256 newAdminFeeMantissa) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.\n      return fail(Error(error), FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED);\n    }\n    // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setAdminFeeFresh(newAdminFeeMantissa);\n  }\n\n  /**\n   * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new admin fee\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setAdminFeeFresh(uint256 newAdminFeeMantissa) internal returns (uint256) {\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);\n    }\n\n    // Sanitize newAdminFeeMantissa\n    if (newAdminFeeMantissa == type(uint256).max) newAdminFeeMantissa = adminFeeMantissa;\n\n    // Get latest Fuse fee\n    uint256 newFuseFeeMantissa = getPendingFuseFeeFromAdmin();\n\n    // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa\n    if (add_(add_(reserveFactorMantissa, newAdminFeeMantissa), newFuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n    }\n\n    // If setting admin fee\n    if (adminFeeMantissa != newAdminFeeMantissa) {\n      // Check caller is admin\n      if (!hasAdminRights()) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);\n      }\n\n      // Set admin fee\n      uint256 oldAdminFeeMantissa = adminFeeMantissa;\n      adminFeeMantissa = newAdminFeeMantissa;\n\n      // Emit event\n      emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n    }\n\n    // If setting Fuse fee\n    if (fuseFeeMantissa != newFuseFeeMantissa) {\n      // Set Fuse fee\n      uint256 oldFuseFeeMantissa = fuseFeeMantissa;\n      fuseFeeMantissa = newFuseFeeMantissa;\n\n      // Emit event\n      emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n      return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n    }\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n    }\n\n    // Check newReserveFactor ≤ maxReserveFactor\n    if (add_(add_(newReserveFactorMantissa, adminFeeMantissa), fuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n    }\n\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external override nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n      return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n    }\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n    // totalReserves - reduceAmount\n    uint256 totalReservesNew;\n\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check reduceAmount ≤ reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked reduceAmount <= totalReserves above, so this should never revert.\n    totalReservesNew = sub_(totalReserves, reduceAmount);\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(msg.sender, reduceAmount);\n\n    emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces Fuse fees by transferring to Fuse\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawFuseFees(uint256 withdrawAmount) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.\n      return fail(Error(error), FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED);\n    }\n    // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _withdrawFuseFeesFresh(withdrawAmount);\n  }\n\n  /**\n   * @notice Reduces Fuse fees by transferring to Fuse\n   * @dev Requires fresh interest accrual\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawFuseFeesFresh(uint256 withdrawAmount) internal returns (uint256) {\n    // totalFuseFees - reduceAmount\n    uint256 totalFuseFeesNew;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)\n    if (withdrawAmount > totalFuseFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked withdrawAmount <= totalFuseFees above, so this should never revert.\n    totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);\n\n    // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount\n    totalFuseFees = totalFuseFeesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(address(fuseAdmin), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces admin fees by transferring to admin\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawAdminFees(uint256 withdrawAmount) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.\n      return fail(Error(error), FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED);\n    }\n    // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _withdrawAdminFeesFresh(withdrawAmount);\n  }\n\n  /**\n   * @notice Reduces admin fees by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawAdminFeesFresh(uint256 withdrawAmount) internal returns (uint256) {\n    // totalAdminFees - reduceAmount\n    uint256 totalAdminFeesNew;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)\n    if (withdrawAmount > totalAdminFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked withdrawAmount <= totalAdminFees above, so this should never revert.\n    totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);\n\n    // Store adminFees[n+1] = adminFees[n] - withdrawAmount\n    totalAdminFees = totalAdminFeesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(address(uint160(UnitrollerAdminStorage(address(comptroller)).admin())), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n      return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n    }\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    // Attempt to reset interest checkpoints on old IRM\n    if (address(oldInterestRateModel) != address(0))\n      address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n    // Attempt to add first interest checkpoint on new IRM\n    address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice updates the cToken ERC20 name and symbol\n   * @dev Admin function to update the cToken ERC20 name and symbol\n   * @param _name the new ERC20 token name to use\n   * @param _symbol the new ERC20 token symbol to use\n   */\n  function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n    // Check caller is admin\n    require(hasAdminRights(), \"caller not admin\");\n\n    // Set ERC20 name and symbol\n    name = _name;\n    symbol = _symbol;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\n    return 1;\n  }\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address to, uint256 amount) internal virtual {}\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant(bool localOnly) {\n    _beforeNonReentrant(localOnly);\n    _;\n    _afterNonReentrant(localOnly);\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n   */\n  function _beforeNonReentrant(bool localOnly) private {\n    require(_notEntered, \"re-entered\");\n    if (!localOnly) comptroller._beforeNonReentrant();\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n   */\n  function _afterNonReentrant(bool localOnly) private {\n    _notEntered = true; // get a gas-refund post-Istanbul\n    if (!localOnly) comptroller._afterNonReentrant();\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n}\n"
    },
    "contracts/compound/CErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../oracles/default/IKeydonixUniswapTwapPriceOracle.sol\";\nimport \"../oracles/keydonix/UniswapOracle.sol\";\nimport \"../utils/Multicall.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface, Multicall {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param fuseAdmin_ The FuseFeeDistributor contract address.\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    address payable fuseAdmin_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    // CToken initialize does the bulk of the work\n    uint256 initialExchangeRateMantissa_ = 0.2e18;\n    uint8 decimals_ = EIP20Interface(underlying_).decimals();\n    super.initialize(\n      comptroller_,\n      fuseAdmin_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      reserveFactorMantissa_,\n      adminFeeMantissa_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override returns (uint256) {\n    (uint256 err, ) = mintInternal(mintAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\n    return redeemInternal(redeemTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\n    return redeemUnderlyingInternal(redeemAmount);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\n    return borrowInternal(borrowAmount);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external override returns (uint256) {\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return err;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint256) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n    uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transferFrom.selector, from, address(this), amount),\n      \"TOKEN_TRANSFER_IN_FAILED\"\n    );\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n    require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address to, uint256 amount) internal virtual override {\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount),\n      \"TOKEN_TRANSFER_OUT_FAILED\"\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n    bytes memory returndata = _functionCall(underlying, data, errorMessage);\n    if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(hasAdminRights(), \"only the admin may set the comp-like delegate\");\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n\n  function verifyPrice(address cToken, UniswapOracle.ProofData calldata proofData) public returns (uint256, uint256) {\n    return comptroller.verifyPrice(cToken, proofData);\n  }\n}\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_ENTERED, // no longer possible\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY,\n    SUPPLIER_NOT_WHITELISTED,\n    BORROW_BELOW_MIN,\n    SUPPLY_ABOVE_MAX,\n    NONZERO_TOTAL_SUPPLY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n    SET_WHITELIST_STATUS_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\n    UNSUPPORT_MARKET_OWNER_CHECK,\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\n    UNSUPPORT_MARKET_IN_USE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return uint256(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    BAD_INPUT,\n    COMPTROLLER_REJECTION,\n    COMPTROLLER_CALCULATION_ERROR,\n    INTEREST_RATE_MODEL_ERROR,\n    INVALID_ACCOUNT_PAIR,\n    INVALID_CLOSE_AMOUNT_REQUESTED,\n    INVALID_COLLATERAL_FACTOR,\n    MATH_ERROR,\n    MARKET_NOT_FRESH,\n    MARKET_NOT_LISTED,\n    TOKEN_INSUFFICIENT_ALLOWANCE,\n    TOKEN_INSUFFICIENT_BALANCE,\n    TOKEN_INSUFFICIENT_CASH,\n    TOKEN_TRANSFER_IN_FAILED,\n    TOKEN_TRANSFER_OUT_FAILED,\n    UTILIZATION_ABOVE_MAX\n  }\n\n  /*\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\n   *       This is because FailureInfo grows significantly faster, and\n   *       the order of Error has some meaning, while the order of FailureInfo\n   *       is entirely arbitrary.\n   */\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    BORROW_ACCRUE_INTEREST_FAILED,\n    BORROW_CASH_NOT_AVAILABLE,\n    BORROW_FRESHNESS_CHECK,\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    BORROW_MARKET_NOT_LISTED,\n    BORROW_COMPTROLLER_REJECTION,\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n    LIQUIDATE_COMPTROLLER_REJECTION,\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n    LIQUIDATE_FRESHNESS_CHECK,\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_SEIZE_TOO_MUCH,\n    MINT_ACCRUE_INTEREST_FAILED,\n    MINT_COMPTROLLER_REJECTION,\n    MINT_EXCHANGE_CALCULATION_FAILED,\n    MINT_EXCHANGE_RATE_READ_FAILED,\n    MINT_FRESHNESS_CHECK,\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    MINT_TRANSFER_IN_FAILED,\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\n    REDEEM_ACCRUE_INTEREST_FAILED,\n    REDEEM_COMPTROLLER_REJECTION,\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\n    REDEEM_FRESHNESS_CHECK,\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n    WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_FUSE_FEES_FRESH_CHECK,\n    WITHDRAW_FUSE_FEES_VALIDATION,\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n    WITHDRAW_ADMIN_FEES_VALIDATION,\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n    REDUCE_RESERVES_ADMIN_CHECK,\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n    REDUCE_RESERVES_FRESH_CHECK,\n    REDUCE_RESERVES_VALIDATION,\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_COMPTROLLER_REJECTION,\n    REPAY_BORROW_FRESHNESS_CHECK,\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COMPTROLLER_OWNER_CHECK,\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_ORACLE_MARKET_NOT_LISTED,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n    SET_ADMIN_FEE_ADMIN_CHECK,\n    SET_ADMIN_FEE_FRESH_CHECK,\n    SET_ADMIN_FEE_BOUNDS_CHECK,\n    SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,\n    SET_FUSE_FEE_FRESH_CHECK,\n    SET_FUSE_FEE_BOUNDS_CHECK,\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\n    SET_RESERVE_FACTOR_FRESH_CHECK,\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\n    TRANSFER_COMPTROLLER_REJECTION,\n    TRANSFER_NOT_ALLOWED,\n    TRANSFER_NOT_ENOUGH,\n    TRANSFER_TOO_MUCH,\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n    ADD_RESERVES_FRESH_CHECK,\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\n  }\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mulScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return addUInt(truncate(product), addend);\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\nabstract contract ComptrollerInterface {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n  function exitMarket(address cToken) external virtual returns (uint256);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external virtual returns (uint256);\n\n  function mintWithinLimits(\n    address cToken,\n    uint256 exchangeRateMantissa,\n    uint256 accountTokens,\n    uint256 mintAmount\n  ) external virtual returns (uint256);\n\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 mintAmount,\n    uint256 mintTokens\n  ) external virtual;\n\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external virtual returns (uint256);\n\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external virtual;\n\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external virtual returns (uint256);\n\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external virtual returns (uint256);\n\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external virtual;\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external virtual returns (uint256);\n\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 borrowerIndex\n  ) external virtual;\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external virtual returns (uint256);\n\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    uint256 seizeTokens\n  ) external virtual;\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual returns (uint256);\n\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual;\n\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external virtual returns (uint256);\n\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external virtual;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 repayAmount\n  ) external view virtual returns (uint256, uint256);\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  function _beforeNonReentrant() external virtual;\n\n  function _afterNonReentrant() external virtual;\n\n  /*** Oracle related ***/\n  function verifyPrice(address cToken, UniswapOracle.ProofData calldata proofData)\n    external\n    virtual\n    returns (uint256, uint256);\n}\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n  /*\n   * Administrator for Fuse\n   */\n  address payable public fuseAdmin;\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Whether or not the Fuse admin has admin rights\n   */\n  bool public fuseAdminHasRights = true;\n\n  /**\n   * @notice Whether or not the admin has admin rights\n   */\n  bool public adminHasRights = true;\n\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(fuseAdmin) && fuseAdminHasRights);\n  }\n\n  /**\n   * @notice Active brains of Unitroller\n   */\n  address public comptrollerImplementation;\n\n  /**\n   * @notice Pending brains of Unitroller\n   */\n  address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  PriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /*\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 internal maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => CToken[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    // Multiplier representing the most one can borrow against their collateral in this market.\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\n    // Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /**\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\n   */\n  mapping(address => bool) internal borrowers;\n\n  /// @notice A list of all borrowers who have entered markets\n  address[] public allBorrowers;\n\n  // Indexes of borrower account addresses in the `allBorrowers` array\n  mapping(address => uint256) internal borrowerIndexes;\n\n  /**\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n   */\n  mapping(address => bool) public suppliers;\n\n  /// @notice All cTokens addresses mapped by their underlying token addresses\n  mapping(address => CToken) public cTokensByUnderlying;\n\n  /// @notice Whether or not the supplier whitelist is enforced\n  bool public enforceWhitelist;\n\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n  mapping(address => bool) public whitelist;\n\n  /// @notice An array of all whitelisted accounts\n  address[] public whitelistArray;\n\n  // Indexes of account addresses in the `whitelistArray` array\n  mapping(address => uint256) internal whitelistIndexes;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  /**\n   * @dev Whether or not the implementation should be auto-upgraded.\n   */\n  bool public autoImplementation;\n\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  address public borrowCapGuardian;\n\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  mapping(address => uint256) public borrowCaps;\n\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n  mapping(address => uint256) public supplyCaps;\n\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\n  address[] public rewardsDistributors;\n\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n  bool internal _notEntered;\n\n  /// @dev Whether or not _notEntered has been initialized\n  bool internal _notEnteredInitialized;\n}\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Comptroller.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is changed\n   */\n  event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Event emitted when the Fuse admin rights are changed\n   */\n  event FuseAdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Event emitted when the admin rights are changed\n   */\n  event AdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  constructor(address payable _fuseAdmin) {\n    // Set admin to caller\n    admin = msg.sender;\n    fuseAdmin = _fuseAdmin;\n  }\n\n  /*** Admin Functions ***/\n\n  function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n    }\n    if (\n      !IFuseFeeDistributor(fuseAdmin).comptrollerImplementationWhitelist(\n        comptrollerImplementation,\n        newPendingImplementation\n      )\n    ) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK);\n    }\n    //require(Comptroller(newPendingImplementation).fuseAdmin() == fuseAdmin, \"fuseAdmin not matching\");\n\n    address oldPendingImplementation = pendingComptrollerImplementation;\n    pendingComptrollerImplementation = newPendingImplementation;\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n   * @dev Admin function for new implementation to accept it's role as implementation\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptImplementation() public returns (uint256) {\n    // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n    if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldImplementation = comptrollerImplementation;\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    comptrollerImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = address(0);\n\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles Fuse admin rights.\n   * @param hasRights Boolean indicating if the Fuse admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleFuseAdminRights(bool hasRights) external returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (fuseAdminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    // Set fuseAdminHasRights\n    fuseAdminHasRights = hasRights;\n\n    // Emit FuseAdminRightsToggled()\n    emit FuseAdminRightsToggled(fuseAdminHasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles admin rights.\n   * @param hasRights Boolean indicating if the admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    // Set adminHasRights\n    adminHasRights = hasRights;\n\n    // Emit AdminRightsToggled()\n    emit AdminRightsToggled(hasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  fallback() external payable {\n    // Check for automatic implementation\n    if (msg.sender != address(this)) {\n      (bool callSuccess, bytes memory data) = address(this).staticcall(abi.encodeWithSignature(\"autoImplementation()\"));\n      bool autoImplementation;\n      if (callSuccess) (autoImplementation) = abi.decode(data, (bool));\n\n      if (autoImplementation) {\n        address latestComptrollerImplementation = IFuseFeeDistributor(fuseAdmin).latestComptrollerImplementation(\n          comptrollerImplementation\n        );\n\n        if (comptrollerImplementation != latestComptrollerImplementation) {\n          address oldImplementation = comptrollerImplementation; // Save current value for inclusion in log\n          comptrollerImplementation = latestComptrollerImplementation;\n          emit NewImplementation(oldImplementation, comptrollerImplementation);\n        }\n      }\n    }\n\n    // delegate all other functions to current implementation\n    (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/compound/RewardsDistributorDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"./Comptroller.sol\";\nimport \"./RewardsDistributorStorage.sol\";\n\n/**\n * @title RewardsDistributorDelegate (COMP distribution logic extracted from `Comptroller`)\n * @author Compound\n */\ncontract RewardsDistributorDelegate is RewardsDistributorDelegateStorageV1, ExponentialNoError {\n  /// @dev Notice that this contract is a RewardsDistributor\n  bool public constant isRewardsDistributor = true;\n\n  /// @notice Emitted when pendingAdmin is changed\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /// @notice Emitted when a new COMP speed is calculated for a market\n  event CompSupplySpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n  /// @notice Emitted when a new COMP speed is calculated for a market\n  event CompBorrowSpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n  /// @notice Emitted when a new COMP speed is set for a contributor\n  event ContributorCompSpeedUpdated(address indexed contributor, uint256 newSpeed);\n\n  /// @notice Emitted when COMP is distributed to a supplier\n  event DistributedSupplierComp(\n    CToken indexed cToken,\n    address indexed supplier,\n    uint256 compDelta,\n    uint256 compSupplyIndex\n  );\n\n  /// @notice Emitted when COMP is distributed to a borrower\n  event DistributedBorrowerComp(\n    CToken indexed cToken,\n    address indexed borrower,\n    uint256 compDelta,\n    uint256 compBorrowIndex\n  );\n\n  /// @notice Emitted when COMP is granted by admin\n  event CompGranted(address recipient, uint256 amount);\n\n  /// @notice The initial COMP index for a market\n  uint224 public constant compInitialIndex = 1e36;\n\n  /// @dev Intitializer to set admin to caller and set reward token\n  function initialize(address _rewardToken) external {\n    require(msg.sender == admin, \"Only admin can initialize.\");\n    require(rewardToken == address(0), \"Already initialized.\");\n    require(_rewardToken != address(0), \"Cannot initialize reward token to the zero address.\");\n    rewardToken = _rewardToken;\n  }\n\n  /*** Set Admin ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   */\n  function _setPendingAdmin(address newPendingAdmin) external {\n    // Check caller = admin\n    require(msg.sender == admin, \"RewardsDistributor:_setPendingAdmin: admin only\");\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   */\n  function _acceptAdmin() external {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    require(\n      msg.sender == pendingAdmin && msg.sender != address(0),\n      \"RewardsDistributor:_acceptAdmin: pending admin only\"\n    );\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n  }\n\n  /*** Comp Distribution ***/\n\n  /**\n   * @notice Check the cToken before adding\n   * @param cToken The market to add\n   */\n  function checkCToken(CToken cToken) internal view {\n    // Make sure cToken is listed\n    Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n    (bool isListed, ) = comptroller.markets(address(cToken));\n    require(isListed == true, \"comp market is not listed\");\n\n    // Make sure distributor is added\n    bool distributorAdded = false;\n    address[] memory distributors = comptroller.getRewardsDistributors();\n    for (uint256 i = 0; i < distributors.length; i++) if (distributors[i] == address(this)) distributorAdded = true;\n    require(distributorAdded == true, \"distributor not added\");\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function setCompSupplySpeedInternal(CToken cToken, uint256 compSpeed) internal {\n    uint256 currentCompSpeed = compSupplySpeeds[address(cToken)];\n    if (currentCompSpeed != 0) {\n      // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n      updateCompSupplyIndex(address(cToken));\n    } else if (compSpeed != 0) {\n      // Make sure cToken is listed and distributor is added\n      checkCToken(cToken);\n\n      // Add the COMP market\n      if (compSupplyState[address(cToken)].index == 0) {\n        compSupplyState[address(cToken)] = CompMarketState({\n          index: compInitialIndex,\n          block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n\n        // Add to allMarkets array if not already there\n        if (compBorrowState[address(cToken)].index == 0) {\n          allMarkets.push(cToken);\n        }\n      } else {\n        // Update block number to ensure extra interest is not accrued during the prior period\n        compSupplyState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n      }\n    }\n\n    if (currentCompSpeed != compSpeed) {\n      compSupplySpeeds[address(cToken)] = compSpeed;\n      emit CompSupplySpeedUpdated(cToken, compSpeed);\n    }\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function setCompBorrowSpeedInternal(CToken cToken, uint256 compSpeed) internal {\n    uint256 currentCompSpeed = compBorrowSpeeds[address(cToken)];\n    if (currentCompSpeed != 0) {\n      // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n      Exp memory borrowIndex = Exp({ mantissa: cToken.borrowIndex() });\n      updateCompBorrowIndex(address(cToken), borrowIndex);\n    } else if (compSpeed != 0) {\n      // Make sure cToken is listed and distributor is added\n      checkCToken(cToken);\n\n      // Add the COMP market\n      if (compBorrowState[address(cToken)].index == 0) {\n        compBorrowState[address(cToken)] = CompMarketState({\n          index: compInitialIndex,\n          block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n\n        // Add to allMarkets array if not already there\n        if (compSupplyState[address(cToken)].index == 0) {\n          allMarkets.push(cToken);\n        }\n      } else {\n        // Update block number to ensure extra interest is not accrued during the prior period\n        compBorrowState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n      }\n    }\n\n    if (currentCompSpeed != compSpeed) {\n      compBorrowSpeeds[address(cToken)] = compSpeed;\n      emit CompBorrowSpeedUpdated(cToken, compSpeed);\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the supply index\n   * @param cToken The market whose supply index to update\n   */\n  function updateCompSupplyIndex(address cToken) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    uint256 supplySpeed = compSupplySpeeds[cToken];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, uint256(supplyState.block));\n    if (deltaBlocks > 0 && supplySpeed > 0) {\n      uint256 supplyTokens = CToken(cToken).totalSupply();\n      uint256 compAccrued_ = mul_(deltaBlocks, supplySpeed);\n      Double memory ratio = supplyTokens > 0 ? fraction(compAccrued_, supplyTokens) : Double({ mantissa: 0 });\n      Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n      compSupplyState[cToken] = CompMarketState({\n        index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n        block: safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0 && supplyState.index > 0) {\n      supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the borrow index\n   * @param cToken The market whose borrow index to update\n   */\n  function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    uint256 borrowSpeed = compBorrowSpeeds[cToken];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, uint256(borrowState.block));\n    if (deltaBlocks > 0 && borrowSpeed > 0) {\n      uint256 borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n      uint256 compAccrued_ = mul_(deltaBlocks, borrowSpeed);\n      Double memory ratio = borrowAmount > 0 ? fraction(compAccrued_, borrowAmount) : Double({ mantissa: 0 });\n      Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\n      compBorrowState[cToken] = CompMarketState({\n        index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n        block: safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0 && borrowState.index > 0) {\n      borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n   * @param cToken The market in which the supplier is interacting\n   * @param supplier The address of the supplier to distribute COMP to\n   */\n  function distributeSupplierComp(address cToken, address supplier) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    Double memory supplyIndex = Double({ mantissa: supplyState.index });\n    Double memory supplierIndex = Double({ mantissa: compSupplierIndex[cToken][supplier] });\n    compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n    if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n      supplierIndex.mantissa = compInitialIndex;\n    }\n\n    Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n    uint256 supplierTokens = CToken(cToken).balanceOf(supplier);\n    uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n    uint256 supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n    compAccrued[supplier] = supplierAccrued;\n    emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n   * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n   * @param cToken The market in which the borrower is interacting\n   * @param borrower The address of the borrower to distribute COMP to\n   */\n  function distributeBorrowerComp(\n    address cToken,\n    address borrower,\n    Exp memory marketBorrowIndex\n  ) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    Double memory borrowIndex = Double({ mantissa: borrowState.index });\n    Double memory borrowerIndex = Double({ mantissa: compBorrowerIndex[cToken][borrower] });\n    compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n    if (borrowerIndex.mantissa > 0) {\n      Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n      uint256 borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n      uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n      uint256 borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n      compAccrued[borrower] = borrowerAccrued;\n      emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, supplier);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) external {\n    if (compBorrowState[cToken].index > 0) {\n      Exp memory borrowIndex = Exp({ mantissa: CToken(cToken).borrowIndex() });\n      updateCompBorrowIndex(cToken, borrowIndex);\n      distributeBorrowerComp(cToken, borrower, borrowIndex);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(\n    address cToken,\n    address src,\n    address dst\n  ) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, src);\n      distributeSupplierComp(cToken, dst);\n    }\n  }\n\n  /**\n   * @notice Calculate additional accrued COMP for a contributor since last accrual\n   * @param contributor The address to calculate contributor rewards for\n   */\n  function updateContributorRewards(address contributor) public {\n    uint256 compSpeed = compContributorSpeeds[contributor];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n    if (deltaBlocks > 0 && compSpeed > 0) {\n      uint256 newAccrued = mul_(deltaBlocks, compSpeed);\n      uint256 contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n      compAccrued[contributor] = contributorAccrued;\n      lastContributorBlock[contributor] = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n   * @param holder The address to claim COMP for\n   */\n  function claimRewards(address holder) public {\n    return claimRewards(holder, allMarkets);\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n   * @param holder The address to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   */\n  function claimRewards(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimRewards(holders, cTokens, true, true);\n  }\n\n  /**\n   * @notice Claim all comp accrued by the holders\n   * @param holders The addresses to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   * @param borrowers Whether or not to claim COMP earned by borrowing\n   * @param suppliers Whether or not to claim COMP earned by supplying\n   */\n  function claimRewards(\n    address[] memory holders,\n    CToken[] memory cTokens,\n    bool borrowers,\n    bool suppliers\n  ) public {\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      CToken cToken = cTokens[i];\n      if (borrowers == true && compBorrowState[address(cToken)].index > 0) {\n        Exp memory borrowIndex = Exp({ mantissa: cToken.borrowIndex() });\n        updateCompBorrowIndex(address(cToken), borrowIndex);\n        for (uint256 j = 0; j < holders.length; j++) {\n          distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n        }\n      }\n      if (suppliers == true && compSupplyState[address(cToken)].index > 0) {\n        updateCompSupplyIndex(address(cToken));\n        for (uint256 j = 0; j < holders.length; j++) {\n          distributeSupplierComp(address(cToken), holders[j]);\n        }\n      }\n    }\n    for (uint256 j = 0; j < holders.length; j++) {\n      compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n    }\n  }\n\n  /**\n   * @notice Transfer COMP to the user\n   * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n   * @param user The address of the user to transfer COMP to\n   * @param amount The amount of COMP to (possibly) transfer\n   * @return The amount of COMP which was NOT transferred to the user\n   */\n  function grantCompInternal(address user, uint256 amount) internal returns (uint256) {\n    EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n    uint256 compRemaining = comp.balanceOf(address(this));\n    if (amount > 0 && amount <= compRemaining) {\n      comp.transfer(user, amount);\n      return 0;\n    }\n    return amount;\n  }\n\n  /*** Comp Distribution Admin ***/\n\n  /**\n   * @notice Transfer COMP to the recipient\n   * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n   * @param recipient The address of the recipient to transfer COMP to\n   * @param amount The amount of COMP to (possibly) transfer\n   */\n  function _grantComp(address recipient, uint256 amount) public {\n    require(msg.sender == admin, \"only admin can grant comp\");\n    uint256 amountLeft = grantCompInternal(recipient, amount);\n    require(amountLeft == 0, \"insufficient comp for grant\");\n    emit CompGranted(recipient, amount);\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function _setCompSupplySpeed(CToken cToken, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n    setCompSupplySpeedInternal(cToken, compSpeed);\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function _setCompBorrowSpeed(CToken cToken, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n    setCompBorrowSpeedInternal(cToken, compSpeed);\n  }\n\n  /**\n   * @notice Set COMP borrow and supply speeds for the specified markets.\n   * @param cTokens The markets whose COMP speed to update.\n   * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n   * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n   */\n  function _setCompSpeeds(\n    CToken[] memory cTokens,\n    uint256[] memory supplySpeeds,\n    uint256[] memory borrowSpeeds\n  ) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n\n    uint256 numTokens = cTokens.length;\n    require(\n      numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length,\n      \"RewardsDistributor::_setCompSpeeds invalid input\"\n    );\n\n    for (uint256 i = 0; i < numTokens; ++i) {\n      setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n      setCompBorrowSpeedInternal(cTokens[i], borrowSpeeds[i]);\n    }\n  }\n\n  /**\n   * @notice Set COMP speed for a single contributor\n   * @param contributor The contributor whose COMP speed to update\n   * @param compSpeed New COMP speed for contributor\n   */\n  function _setContributorCompSpeed(address contributor, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n\n    // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n    updateContributorRewards(contributor);\n    if (compSpeed == 0) {\n      // release storage\n      delete lastContributorBlock[contributor];\n    } else {\n      lastContributorBlock[contributor] = getBlockNumber();\n    }\n    compContributorSpeeds[contributor] = compSpeed;\n\n    emit ContributorCompSpeedUpdated(contributor, compSpeed);\n  }\n\n  /*** Helper Functions */\n\n  function getBlockNumber() public view returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns an array of all markets.\n   */\n  function getAllMarkets() external view returns (CToken[] memory) {\n    return allMarkets;\n  }\n}\n"
    },
    "contracts/compound/IFuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IFuseFeeDistributor {\n  function minBorrowEth() external view returns (uint256);\n\n  function maxSupplyEth() external view returns (uint256);\n\n  function maxUtilizationRate() external view returns (uint256);\n\n  function interestFeeRate() external view returns (uint256);\n\n  function comptrollerImplementationWhitelist(address oldImplementation, address newImplementation)\n    external\n    view\n    returns (bool);\n\n  function cErc20DelegateWhitelist(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign\n  ) external view returns (bool);\n\n  function cEtherDelegateWhitelist(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign\n  ) external view returns (bool);\n\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n\n  function latestCErc20Delegate(address oldImplementation)\n    external\n    view\n    returns (\n      address cErc20Delegate,\n      bool allowResign,\n      bytes memory becomeImplementationData\n    );\n\n  function latestCEtherDelegate(address oldImplementation)\n    external\n    view\n    returns (\n      address cEtherDelegate,\n      bool allowResign,\n      bytes memory becomeImplementationData\n    );\n\n  function deployCEther(bytes calldata constructorData) external returns (address);\n\n  function deployCErc20(bytes calldata constructorData) external returns (address);\n\n  fallback() external payable;\n\n  receive() external payable;\n}\n"
    },
    "contracts/oracles/default/IKeydonixUniswapTwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/ICToken.sol\";\nimport \"../keydonix/UniswapOracle.sol\";\n\ninterface IKeydonixUniswapTwapPriceOracle {\n  function verifyPrice(ICToken cToken, UniswapOracle.ProofData calldata proofData) external returns (uint256, uint256);\n\n  event PriceAlreadyVerified(address indexed cToken, uint256 price, uint256 block);\n  event PriceVerified(address indexed cToken, uint256 price, uint256 block);\n}\n"
    },
    "contracts/oracles/keydonix/UniswapOracle.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport { BlockVerifier } from \"./BlockVerifier.sol\";\nimport { MerklePatriciaVerifier } from \"./MerklePatriciaVerifier.sol\";\nimport { Rlp } from \"./Rlp.sol\";\nimport { UQ112x112 } from \"./UQ112x112.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\n\ncontract UniswapOracle {\n  using UQ112x112 for uint224;\n\n  bytes32 public constant reserveTimestampSlotHash = keccak256(abi.encodePacked(uint256(8)));\n  bytes32 public constant token0Slot = keccak256(abi.encodePacked(uint256(9)));\n  bytes32 public constant token1Slot = keccak256(abi.encodePacked(uint256(10)));\n\n  struct ProofData {\n    bytes block;\n    bytes accountProofNodesRlp;\n    bytes reserveAndTimestampProofNodesRlp;\n    bytes priceAccumulatorProofNodesRlp;\n  }\n\n  function getAccountStorageRoot(address uniswapV2Pair, ProofData memory proofData)\n    public\n    view\n    returns (\n      bytes32 storageRootHash,\n      uint256 blockNumber,\n      uint256 blockTimestamp\n    )\n  {\n    bytes32 stateRoot;\n    (stateRoot, blockTimestamp, blockNumber) = BlockVerifier.extractStateRootAndTimestamp(proofData.block);\n    bytes memory accountDetailsBytes = MerklePatriciaVerifier.getValueFromProof(\n      stateRoot,\n      keccak256(abi.encodePacked(uniswapV2Pair)),\n      proofData.accountProofNodesRlp\n    );\n    Rlp.Item[] memory accountDetails = Rlp.toList(Rlp.toItem(accountDetailsBytes));\n    return (Rlp.toBytes32(accountDetails[2]), blockNumber, blockTimestamp);\n  }\n\n  // This function verifies the full block is old enough (MIN_BLOCK_COUNT), not too old (or blockhash will return 0x0) and return the proof values for the two storage slots we care about\n  function verifyBlockAndExtractReserveData(\n    IUniswapV2Pair uniswapV2Pair,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    bytes32 slotHash,\n    ProofData memory proofData\n  )\n    public\n    view\n    returns (\n      uint256 blockTimestamp,\n      uint256 blockNumber,\n      uint256 priceCumulativeLast,\n      uint112 reserve0,\n      uint112 reserve1,\n      uint256 reserveTimestamp\n    )\n  {\n    bytes32 storageRootHash;\n    (storageRootHash, blockNumber, blockTimestamp) = getAccountStorageRoot(address(uniswapV2Pair), proofData);\n    require(blockNumber <= block.number - minBlocksBack, \"Proof does not span enough blocks\");\n    require(blockNumber >= block.number - maxBlocksBack, \"Proof spans too many blocks\");\n\n    priceCumulativeLast = Rlp.rlpBytesToUint256(\n      MerklePatriciaVerifier.getValueFromProof(storageRootHash, slotHash, proofData.priceAccumulatorProofNodesRlp)\n    );\n    uint256 reserve0Reserve1TimestampPacked = Rlp.rlpBytesToUint256(\n      MerklePatriciaVerifier.getValueFromProof(\n        storageRootHash,\n        reserveTimestampSlotHash,\n        proofData.reserveAndTimestampProofNodesRlp\n      )\n    );\n    reserveTimestamp = reserve0Reserve1TimestampPacked >> (112 + 112);\n    reserve1 = uint112((reserve0Reserve1TimestampPacked >> 112) & (2**112 - 1));\n    reserve0 = uint112(reserve0Reserve1TimestampPacked & (2**112 - 1));\n  }\n\n  function getPrice(\n    IUniswapV2Pair uniswapV2Pair,\n    address denominationToken,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    ProofData memory proofData\n  ) public view returns (uint256 price, uint256 blockNumber) {\n    // exchange = the ExchangeV2Pair. check denomination token (USE create2 check?!) check gas cost\n    bool denominationTokenIs0;\n    if (uniswapV2Pair.token0() == denominationToken) {\n      denominationTokenIs0 = true;\n    } else if (uniswapV2Pair.token1() == denominationToken) {\n      denominationTokenIs0 = false;\n    } else {\n      revert(\"denominationToken invalid\");\n    }\n    return getPriceRaw(uniswapV2Pair, denominationTokenIs0, minBlocksBack, maxBlocksBack, proofData);\n  }\n\n  function getPriceRaw(\n    IUniswapV2Pair uniswapV2Pair,\n    bool denominationTokenIs0,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    ProofData memory proofData\n  ) public view returns (uint256 price, uint256 blockNumber) {\n    uint256 historicBlockTimestamp;\n    uint256 historicPriceCumulativeLast;\n    {\n      // Stack-too-deep workaround, manual scope\n      // Side-note: wtf Solidity?\n      uint112 reserve0;\n      uint112 reserve1;\n      uint256 reserveTimestamp;\n      (\n        historicBlockTimestamp,\n        blockNumber,\n        historicPriceCumulativeLast,\n        reserve0,\n        reserve1,\n        reserveTimestamp\n      ) = verifyBlockAndExtractReserveData(\n        uniswapV2Pair,\n        minBlocksBack,\n        maxBlocksBack,\n        denominationTokenIs0 ? token1Slot : token0Slot,\n        proofData\n      );\n      uint256 secondsBetweenReserveUpdateAndHistoricBlock = historicBlockTimestamp - reserveTimestamp;\n      // bring old record up-to-date, in case there was no cumulative update in provided historic block itself\n      if (secondsBetweenReserveUpdateAndHistoricBlock > 0) {\n        historicPriceCumulativeLast +=\n          secondsBetweenReserveUpdateAndHistoricBlock *\n          uint256(\n            UQ112x112.encode(denominationTokenIs0 ? reserve0 : reserve1).uqdiv(\n              denominationTokenIs0 ? reserve1 : reserve0\n            )\n          );\n      }\n    }\n    uint256 secondsBetweenProvidedBlockAndNow = block.timestamp - historicBlockTimestamp;\n    price =\n      (getCurrentPriceCumulativeLast(uniswapV2Pair, denominationTokenIs0) - historicPriceCumulativeLast) /\n      secondsBetweenProvidedBlockAndNow;\n    return (price, blockNumber);\n  }\n\n  function getCurrentPriceCumulativeLast(IUniswapV2Pair uniswapV2Pair, bool denominationTokenIs0)\n    public\n    view\n    returns (uint256 priceCumulativeLast)\n  {\n    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = uniswapV2Pair.getReserves();\n    priceCumulativeLast = denominationTokenIs0\n      ? uniswapV2Pair.price1CumulativeLast()\n      : uniswapV2Pair.price0CumulativeLast();\n    uint256 timeElapsed = block.timestamp - blockTimestampLast;\n    priceCumulativeLast +=\n      timeElapsed *\n      uint256(\n        UQ112x112.encode(denominationTokenIs0 ? reserve0 : reserve1).uqdiv(denominationTokenIs0 ? reserve1 : reserve0)\n      );\n  }\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenAdminStorage {\n  /*\n   * Administrator for Fuse\n   */\n  address payable public fuseAdmin;\n\n  /**\n   * @dev LEGACY USE ONLY: Administrator for this contract\n   */\n  address payable internal __admin;\n\n  /**\n   * @dev LEGACY USE ONLY: Whether or not the Fuse admin has admin rights\n   */\n  bool internal __fuseAdminHasRights;\n\n  /**\n   * @dev LEGACY USE ONLY: Whether or not the admin has admin rights\n   */\n  bool internal __adminHasRights;\n}\n\ncontract CTokenStorage is CTokenAdminStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  /*\n   * Maximum borrow rate that can ever be applied (.0005% / block)\n   */\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  /*\n   * Maximum fraction of interest that can be set aside for reserves + fees\n   */\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n  /*\n   * LEGACY USE ONLY: Pending administrator for this contract\n   */\n  address payable private __pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  /*\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n   */\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for admin fees\n   */\n  uint256 public adminFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for Fuse fees\n   */\n  uint256 public fuseFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total amount of admin fees of the underlying held in this market\n   */\n  uint256 public totalAdminFees;\n\n  /**\n   * @notice Total amount of Fuse fees of the underlying held in this market\n   */\n  uint256 public totalFuseFees;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  /*\n   * Official record of token balances for each account\n   */\n  mapping(address => uint256) internal accountTokens;\n\n  /*\n   * Approved token transfer amounts on behalf of others\n   */\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /*\n   * Mapping of account addresses to outstanding borrow balances\n   */\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /*\n   * Share of seized collateral that is added to reserves\n   */\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n  /*\n   * Share of seized collateral taken as fees\n   */\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n  /**\n   * @notice Indicator that this is a CToken contract (for inspection)\n   */\n  function isCToken() external virtual returns (bool) {\n    return true;\n  }\n\n  /**\n   * @notice Indicator that this is or is not a CEther contract (for inspection)\n   */\n  function isCEther() external virtual returns (bool) {\n    return false;\n  }\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the admin fee is changed\n   */\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n  /**\n   * @notice Event emitted when the Fuse fee is changed\n   */\n  event NewFuseFee(uint256 oldFuseFeeMantissa, uint256 newFuseFeeMantissa);\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external virtual returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external virtual returns (bool);\n\n  function approve(address spender, uint256 amount) external virtual returns (bool);\n\n  function allowance(address owner, address spender) external view virtual returns (uint256);\n\n  function balanceOf(address owner) external view virtual returns (uint256);\n\n  function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view virtual returns (uint256);\n\n  function supplyRatePerBlock() external view virtual returns (uint256);\n\n  function totalBorrowsCurrent() external virtual returns (uint256);\n\n  function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n  function borrowBalanceStored(address account) public view virtual returns (uint256);\n\n  function exchangeRateCurrent() public virtual returns (uint256);\n\n  function exchangeRateStored() public view virtual returns (uint256);\n\n  function getCash() external view virtual returns (uint256);\n\n  function accrueInterest() public virtual returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external virtual returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external virtual returns (uint256);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public virtual returns (uint256);\n}\n\ncontract CErc20Storage {\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external virtual returns (uint256);\n\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n  function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external virtual returns (uint256);\n}\n\ncontract CEtherInterface is CErc20Storage {}\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return uint256 The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool success);\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transfer(address dst, uint256 amount) external;\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view virtual returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/oracles/keydonix/BlockVerifier.sol": {
      "content": "pragma solidity >=0.8.0;\n\nlibrary BlockVerifier {\n\tfunction extractStateRootAndTimestamp(bytes memory rlpBytes) internal view returns (bytes32 stateRoot, uint256 blockTimestamp, uint256 blockNumber) {\n\t\tassembly {\n\t\t\tfunction revertWithReason(message, length) {\n\t\t\t\tmstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\t\t\t\tmstore(4, 0x20)\n\t\t\t\tmstore(0x24, length)\n\t\t\t\tmstore(0x44, message)\n\t\t\t\trevert(0, add(0x44, length))\n\t\t\t}\n\n\t\t\tfunction readDynamic(prefixPointer) -> dataPointer, dataLength {\n\t\t\t\tlet value := byte(0, mload(prefixPointer))\n\t\t\t\tswitch lt(value, 0x80)\n\t\t\t\tcase 1 {\n\t\t\t\t\tdataPointer := prefixPointer\n\t\t\t\t\tdataLength := 1\n\t\t\t\t}\n\t\t\t\tcase 0 {\n\t\t\t\t\tdataPointer := add(prefixPointer, 1)\n\t\t\t\t\tdataLength := sub(value, 0x80)\n\t\t\t\t}\n\t\t\t}\n\n\t\t// get the length of the data\n\t\t\tlet rlpLength := mload(rlpBytes)\n\t\t// move pointer forward, ahead of length\n\t\t\trlpBytes := add(rlpBytes, 0x20)\n\n\t\t// we know the length of the block will be between 483 bytes and 709 bytes, which means it will have 2 length bytes after the prefix byte, so we can skip 3 bytes in\n\t\t// CONSIDER: we could save a trivial amount of gas by compressing most of this into a single add instruction\n\n\t\t\tlet stateRootPointer\n\t\t\t{\n\t\t\t\tlet parentHashPrefixPointer := add(rlpBytes, 3)\n\t\t\t\tlet parentHashPointer := add(parentHashPrefixPointer, 1)\n\t\t\t\tlet uncleHashPrefixPointer := add(parentHashPointer, 32)\n\t\t\t\tlet uncleHashPointer := add(uncleHashPrefixPointer, 1)\n\t\t\t\tlet minerAddressPrefixPointer := add(uncleHashPointer, 32)\n\t\t\t\tlet minerAddressPointer := add(minerAddressPrefixPointer, 1)\n\t\t\t\tlet stateRootPrefixPointer := add(minerAddressPointer, 20)\n\t\t\t\tstateRootPointer := add(stateRootPrefixPointer, 1)\n\t\t\t}\n\n\t\t\tlet blockNumberPointer\n\t\t\tlet blockNumberLength\n\t\t\t{\n\t\t\t\tlet transactionRootPrefixPointer := add(stateRootPointer, 32)\n\t\t\t\tlet transactionRootPointer := add(transactionRootPrefixPointer, 1)\n\t\t\t\tlet receiptsRootPrefixPointer := add(transactionRootPointer, 32)\n\t\t\t\tlet receiptsRootPointer := add(receiptsRootPrefixPointer, 1)\n\t\t\t\tlet logsBloomPrefixPointer := add(receiptsRootPointer, 32)\n\t\t\t\tlet logsBloomPointer := add(logsBloomPrefixPointer, 3)\n\t\t\t\tlet difficultyPrefixPointer := add(logsBloomPointer, 256)\n\t\t\t\tlet difficultyPointer, difficultyLength := readDynamic(difficultyPrefixPointer)\n\t\t\t\tlet blockNumberPrefixPointer := add(difficultyPointer, difficultyLength)\n\t\t\t\tblockNumberPointer, blockNumberLength := readDynamic(blockNumberPrefixPointer)\n\t\t\t}\n\n\n\t\t\tlet timestampPointer\n\t\t\tlet timestampLength\n\t\t\t{\n\t\t\t\tlet gasLimitPrefixPointer := add(blockNumberPointer, blockNumberLength)\n\t\t\t\tlet gasLimitPointer, gasLimitLength := readDynamic(gasLimitPrefixPointer)\n\t\t\t\tlet gasUsedPrefixPointer := add(gasLimitPointer, gasLimitLength)\n\t\t\t\tlet gasUsedPointer, gasUsedLength := readDynamic(gasUsedPrefixPointer)\n\t\t\t\tlet timestampPrefixPointer := add(gasUsedPointer, gasUsedLength)\n\t\t\t\ttimestampPointer, timestampLength := readDynamic(timestampPrefixPointer)\n\t\t\t}\n\n\t\t\tblockNumber := shr(sub(256, mul(blockNumberLength, 8)), mload(blockNumberPointer))\n\t\t\tlet blockHash := blockhash(blockNumber)\n\t\t\tlet rlpHash := keccak256(rlpBytes, rlpLength)\n\t\t\tif iszero(eq(blockHash, rlpHash)) { revertWithReason(\"blockHash != rlpHash\", 20) }\n\n\t\t\tstateRoot := mload(stateRootPointer)\n\t\t\tblockTimestamp := shr(sub(256, mul(timestampLength, 8)), mload(timestampPointer))\n\t\t}\n\t}\n}\n"
    },
    "contracts/oracles/keydonix/MerklePatriciaVerifier.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport { Rlp } from \"./Rlp.sol\";\n\nlibrary MerklePatriciaVerifier {\n  /*\n   * @dev Extracts the value from a merkle proof\n   * @param expectedRoot The expected hash of the root node of the trie.\n   * @param path The path in the trie leading to value.\n   * @param proofNodesRlp RLP encoded array of proof nodes.\n   * @return The value proven to exist in the merkle patricia tree whose root is `expectedRoot` at the path `path`\n   *\n   * WARNING: Does not currently support validation of unset/0 values!\n   */\n  function getValueFromProof(\n    bytes32 expectedRoot,\n    bytes32 path,\n    bytes memory proofNodesRlp\n  ) internal pure returns (bytes memory) {\n    Rlp.Item memory rlpParentNodes = Rlp.toItem(proofNodesRlp);\n    Rlp.Item[] memory parentNodes = Rlp.toList(rlpParentNodes);\n\n    bytes memory currentNode;\n    Rlp.Item[] memory currentNodeList;\n\n    bytes32 nodeKey = expectedRoot;\n    uint256 pathPtr = 0;\n\n    // our input is a 32-byte path, but we have to prepend a single 0 byte to that and pass it along as a 33 byte memory array since that is what getNibbleArray wants\n    bytes memory nibblePath = new bytes(33);\n    assembly {\n      mstore(add(nibblePath, 33), path)\n    }\n    nibblePath = _getNibbleArray(nibblePath);\n\n    require(path.length != 0, \"empty path provided\");\n\n    currentNode = Rlp.toBytes(parentNodes[0]);\n\n    for (uint256 i = 0; i < parentNodes.length; i++) {\n      require(pathPtr <= nibblePath.length, \"Path overflow\");\n\n      currentNode = Rlp.toBytes(parentNodes[i]);\n      require(nodeKey == keccak256(currentNode), \"node doesn't match key\");\n      currentNodeList = Rlp.toList(parentNodes[i]);\n\n      if (currentNodeList.length == 17) {\n        if (pathPtr == nibblePath.length) {\n          return Rlp.toData(currentNodeList[16]);\n        }\n\n        uint8 nextPathNibble = uint8(nibblePath[pathPtr]);\n        require(nextPathNibble <= 16, \"nibble too long\");\n        nodeKey = Rlp.toBytes32(currentNodeList[nextPathNibble]);\n        pathPtr += 1;\n      } else if (currentNodeList.length == 2) {\n        pathPtr += _nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr);\n        // leaf node\n        if (pathPtr == nibblePath.length) {\n          return Rlp.toData(currentNodeList[1]);\n        }\n        //extension node\n        require(_nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr) != 0, \"invalid extension node\");\n\n        nodeKey = Rlp.toBytes32(currentNodeList[1]);\n      } else {\n        require(false, \"unexpected length array\");\n      }\n    }\n    require(false, \"not enough proof nodes\");\n  }\n\n  function _nibblesToTraverse(\n    bytes memory encodedPartialPath,\n    bytes memory path,\n    uint256 pathPtr\n  ) private pure returns (uint256) {\n    uint256 len;\n    // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n    // and slicedPath have elements that are each one hex character (1 nibble)\n    bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n    bytes memory slicedPath = new bytes(partialPath.length);\n\n    // pathPtr counts nibbles in path\n    // partialPath.length is a number of nibbles\n    for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\n      bytes1 pathNibble = path[i];\n      slicedPath[i - pathPtr] = pathNibble;\n    }\n\n    if (keccak256(partialPath) == keccak256(slicedPath)) {\n      len = partialPath.length;\n    } else {\n      len = 0;\n    }\n    return len;\n  }\n\n  // bytes byteArray must be hp encoded\n  function _getNibbleArray(bytes memory byteArray) private pure returns (bytes memory) {\n    bytes memory nibbleArray;\n    if (byteArray.length == 0) return nibbleArray;\n\n    uint8 offset;\n    uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, byteArray));\n    if (hpNibble == 1 || hpNibble == 3) {\n      nibbleArray = new bytes(byteArray.length * 2 - 1);\n      bytes1 oddNibble = _getNthNibbleOfBytes(1, byteArray);\n      nibbleArray[0] = oddNibble;\n      offset = 1;\n    } else {\n      nibbleArray = new bytes(byteArray.length * 2 - 2);\n      offset = 0;\n    }\n\n    for (uint256 i = offset; i < nibbleArray.length; i++) {\n      nibbleArray[i] = _getNthNibbleOfBytes(i - offset + 2, byteArray);\n    }\n    return nibbleArray;\n  }\n\n  function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n    return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n  }\n}\n"
    },
    "contracts/oracles/keydonix/Rlp.sol": {
      "content": "pragma solidity >=0.8.0;\n\nlibrary Rlp {\n  uint256 constant DATA_SHORT_START = 0x80;\n  uint256 constant DATA_LONG_START = 0xB8;\n  uint256 constant LIST_SHORT_START = 0xC0;\n  uint256 constant LIST_LONG_START = 0xF8;\n\n  uint256 constant DATA_LONG_OFFSET = 0xB7;\n  uint256 constant LIST_LONG_OFFSET = 0xF7;\n\n  struct Item {\n    uint256 _unsafe_memPtr; // Pointer to the RLP-encoded bytes.\n    uint256 _unsafe_length; // Number of bytes. This is the full length of the string.\n  }\n\n  struct Iterator {\n    Item _unsafe_item; // Item that's being iterated over.\n    uint256 _unsafe_nextPtr; // Position of the next item in the list.\n  }\n\n  /* Iterator */\n\n  function next(Iterator memory self) internal pure returns (Item memory subItem) {\n    require(hasNext(self), \"Rlp.sol:Rlp:next:1\");\n    uint256 ptr = self._unsafe_nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    subItem._unsafe_memPtr = ptr;\n    subItem._unsafe_length = itemLength;\n    self._unsafe_nextPtr = ptr + itemLength;\n  }\n\n  function next(Iterator memory self, bool strict) internal pure returns (Item memory subItem) {\n    subItem = next(self);\n    require(!strict || _validate(subItem), \"Rlp.sol:Rlp:next:2\");\n  }\n\n  function hasNext(Iterator memory self) internal pure returns (bool) {\n    Rlp.Item memory item = self._unsafe_item;\n    return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\n  }\n\n  /* Item */\n\n  /// @dev Creates an Item from an array of RLP encoded bytes.\n  /// @param self The RLP encoded bytes.\n  /// @return An Item\n  function toItem(bytes memory self) internal pure returns (Item memory) {\n    uint256 len = self.length;\n    if (len == 0) {\n      return Item(0, 0);\n    }\n    uint256 memPtr;\n    assembly {\n      memPtr := add(self, 0x20)\n    }\n    return Item(memPtr, len);\n  }\n\n  /// @dev Creates an Item from an array of RLP encoded bytes.\n  /// @param self The RLP encoded bytes.\n  /// @param strict Will throw if the data is not RLP encoded.\n  /// @return An Item\n  function toItem(bytes memory self, bool strict) internal pure returns (Item memory) {\n    Rlp.Item memory item = toItem(self);\n    if (strict) {\n      uint256 len = self.length;\n      require(_payloadOffset(item) <= len, \"Rlp.sol:Rlp:toItem4\");\n      require(_itemLength(item._unsafe_memPtr) == len, \"Rlp.sol:Rlp:toItem:5\");\n      require(_validate(item), \"Rlp.sol:Rlp:toItem:6\");\n    }\n    return item;\n  }\n\n  /// @dev Check if the Item is null.\n  /// @param self The Item.\n  /// @return 'true' if the item is null.\n  function isNull(Item memory self) internal pure returns (bool) {\n    return self._unsafe_length == 0;\n  }\n\n  /// @dev Check if the Item is a list.\n  /// @param self The Item.\n  /// @return 'true' if the item is a list.\n  function isList(Item memory self) internal pure returns (bool) {\n    if (self._unsafe_length == 0) return false;\n    uint256 memPtr = self._unsafe_memPtr;\n    bool result;\n    assembly {\n      result := iszero(lt(byte(0, mload(memPtr)), 0xC0))\n    }\n    return result;\n  }\n\n  /// @dev Check if the Item is data.\n  /// @param self The Item.\n  /// @return 'true' if the item is data.\n  function isData(Item memory self) internal pure returns (bool) {\n    if (self._unsafe_length == 0) return false;\n    uint256 memPtr = self._unsafe_memPtr;\n    bool result;\n    assembly {\n      result := lt(byte(0, mload(memPtr)), 0xC0)\n    }\n    return result;\n  }\n\n  /// @dev Check if the Item is empty (string or list).\n  /// @param self The Item.\n  /// @return result 'true' if the item is null.\n  function isEmpty(Item memory self) internal pure returns (bool) {\n    if (isNull(self)) return false;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\n  }\n\n  /// @dev Get the number of items in an RLP encoded list.\n  /// @param self The Item.\n  /// @return The number of items.\n  function items(Item memory self) internal pure returns (uint256) {\n    if (!isList(self)) return 0;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    uint256 pos = memPtr + _payloadOffset(self);\n    uint256 last = memPtr + self._unsafe_length - 1;\n    uint256 itms;\n    while (pos <= last) {\n      pos += _itemLength(pos);\n      itms++;\n    }\n    return itms;\n  }\n\n  /// @dev Create an iterator.\n  /// @param self The Item.\n  /// @return An 'Iterator' over the item.\n  function iterator(Item memory self) internal pure returns (Iterator memory) {\n    require(isList(self), \"Rlp.sol:Rlp:iterator:1\");\n    uint256 ptr = self._unsafe_memPtr + _payloadOffset(self);\n    Iterator memory it;\n    it._unsafe_item = self;\n    it._unsafe_nextPtr = ptr;\n    return it;\n  }\n\n  /// @dev Return the RLP encoded bytes.\n  /// @param self The Item.\n  /// @return The bytes.\n  function toBytes(Item memory self) internal pure returns (bytes memory) {\n    uint256 len = self._unsafe_length;\n    require(len != 0, \"Rlp.sol:Rlp:toBytes:2\");\n    bytes memory bts;\n    bts = new bytes(len);\n    _copyToBytes(self._unsafe_memPtr, bts, len);\n    return bts;\n  }\n\n  /// @dev Decode an Item into bytes. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toData(Item memory self) internal pure returns (bytes memory) {\n    require(isData(self));\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    bytes memory bts;\n    bts = new bytes(len);\n    _copyToBytes(rStartPos, bts, len);\n    return bts;\n  }\n\n  /// @dev Get the list of sub-items from an RLP encoded list.\n  /// Warning: This is inefficient, as it requires that the list is read twice.\n  /// @param self The Item.\n  /// @return Array of Items.\n  function toList(Item memory self) internal pure returns (Item[] memory) {\n    require(isList(self), \"Rlp.sol:Rlp:toList:1\");\n    uint256 numItems = items(self);\n    Item[] memory list = new Item[](numItems);\n    Rlp.Iterator memory it = iterator(self);\n    uint256 idx;\n    while (hasNext(it)) {\n      list[idx] = next(it);\n      idx++;\n    }\n    return list;\n  }\n\n  /// @dev Decode an Item into an ascii string. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toAscii(Item memory self) internal pure returns (string memory) {\n    require(isData(self), \"Rlp.sol:Rlp:toAscii:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    bytes memory bts = new bytes(len);\n    _copyToBytes(rStartPos, bts, len);\n    string memory str = string(bts);\n    return str;\n  }\n\n  /// @dev Decode an Item into a uint. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toUint(Item memory self) internal pure returns (uint256) {\n    require(isData(self), \"Rlp.sol:Rlp:toUint:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len <= 32, \"Rlp.sol:Rlp:toUint:3\");\n    require(len != 0, \"Rlp.sol:Rlp:toUint:4\");\n    uint256 data;\n    assembly {\n      data := div(mload(rStartPos), exp(256, sub(32, len)))\n    }\n    return data;\n  }\n\n  /// @dev Decode an Item into a boolean. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toBool(Item memory self) internal pure returns (bool) {\n    require(isData(self), \"Rlp.sol:Rlp:toBool:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 1, \"Rlp.sol:Rlp:toBool:3\");\n    uint256 temp;\n    assembly {\n      temp := byte(0, mload(rStartPos))\n    }\n    require(temp <= 1, \"Rlp.sol:Rlp:toBool:8\");\n    return temp == 1 ? true : false;\n  }\n\n  /// @dev Decode an Item into a byte. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toByte(Item memory self) internal pure returns (bytes1) {\n    require(isData(self), \"Rlp.sol:Rlp:toByte:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 1, \"Rlp.sol:Rlp:toByte:3\");\n    bytes1 temp;\n    assembly {\n      temp := byte(0, mload(rStartPos))\n    }\n    return bytes1(temp);\n  }\n\n  /// @dev Decode an Item into an int. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toInt(Item memory self) internal pure returns (int256) {\n    return int256(toUint(self));\n  }\n\n  /// @dev Decode an Item into a bytes32. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toBytes32(Item memory self) internal pure returns (bytes32) {\n    return bytes32(toUint(self));\n  }\n\n  /// @dev Decode an Item into an address. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toAddress(Item memory self) internal pure returns (address) {\n    require(isData(self), \"Rlp.sol:Rlp:toAddress:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 20, \"Rlp.sol:Rlp:toAddress:3\");\n    address data;\n    assembly {\n      data := div(mload(rStartPos), exp(256, 12))\n    }\n    return data;\n  }\n\n  // Get the payload offset.\n  function _payloadOffset(Item memory self) private pure returns (uint256) {\n    if (self._unsafe_length == 0) return 0;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    if (b0 < DATA_SHORT_START) return 0;\n    if (b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START)) return 1;\n    if (b0 < LIST_SHORT_START) return b0 - DATA_LONG_OFFSET + 1;\n    return b0 - LIST_LONG_OFFSET + 1;\n  }\n\n  // Get the full length of an Item.\n  function _itemLength(uint256 memPtr) private pure returns (uint256 len) {\n    uint256 b0;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    if (b0 < DATA_SHORT_START) len = 1;\n    else if (b0 < DATA_LONG_START) len = b0 - DATA_SHORT_START + 1;\n    else if (b0 < LIST_SHORT_START) {\n      assembly {\n        let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\n        let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n        len := add(1, add(bLen, dLen)) // total length\n      }\n    } else if (b0 < LIST_LONG_START) len = b0 - LIST_SHORT_START + 1;\n    else {\n      assembly {\n        let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\n        let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n        len := add(1, add(bLen, dLen)) // total length\n      }\n    }\n  }\n\n  // Get start position and length of the data.\n  function _decode(Item memory self) private pure returns (uint256 memPtr, uint256 len) {\n    require(isData(self), \"Rlp.sol:Rlp:_decode:1\");\n    uint256 b0;\n    uint256 start = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(start))\n    }\n    if (b0 < DATA_SHORT_START) {\n      memPtr = start;\n      len = 1;\n      return (memPtr, len);\n    }\n    if (b0 < DATA_LONG_START) {\n      len = self._unsafe_length - 1;\n      memPtr = start + 1;\n    } else {\n      uint256 bLen;\n      assembly {\n        bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\n      }\n      len = self._unsafe_length - 1 - bLen;\n      memPtr = start + bLen + 1;\n    }\n    return (memPtr, len);\n  }\n\n  // Assumes that enough memory has been allocated to store in target.\n  function _copyToBytes(\n    uint256 sourceBytes,\n    bytes memory destinationBytes,\n    uint256 btsLen\n  ) internal pure {\n    // Exploiting the fact that 'tgt' was the last thing to be allocated,\n    // we can write entire words, and just overwrite any excess.\n    assembly {\n      let words := div(add(btsLen, 31), 32)\n      let sourcePointer := sourceBytes\n      let destinationPointer := add(destinationBytes, 32)\n      for {\n        let i := 0\n      } lt(i, words) {\n        i := add(i, 1)\n      } {\n        let offset := mul(i, 32)\n        mstore(add(destinationPointer, offset), mload(add(sourcePointer, offset)))\n      }\n      mstore(add(destinationBytes, add(32, mload(destinationBytes))), 0)\n    }\n  }\n\n  // Check that an Item is valid.\n  function _validate(Item memory self) private pure returns (bool ret) {\n    // Check that RLP is well-formed.\n    uint256 b0;\n    uint256 b1;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n      b1 := byte(1, mload(memPtr))\n    }\n    if (b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START) return false;\n    return true;\n  }\n\n  function rlpBytesToUint256(bytes memory source) internal pure returns (uint256 result) {\n    return Rlp.toUint(Rlp.toItem(source));\n  }\n}\n"
    },
    "contracts/oracles/keydonix/UQ112x112.sol": {
      "content": "pragma solidity >=0.8.0;\n\n// https://raw.githubusercontent.com/Uniswap/uniswap-v2-core/master/contracts/libraries/UQ112x112.sol\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n  uint224 constant Q112 = 2**112;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 y) internal pure returns (uint224 z) {\n    z = uint224(y) * Q112; // never overflows\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n    z = x / uint224(y);\n  }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint256 c = a * b;\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    uint256 c = a + b;\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (MathError, uint256) {\n    (MathError err0, uint256 sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n}\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  struct Exp {\n    uint256 mantissa;\n  }\n\n  struct Double {\n    uint256 mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n  }\n}\n"
    },
    "contracts/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface ICToken {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function fuseAdminHasRights() external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function comptroller() external view returns (address);\n\n  function adminFeeMantissa() external view returns (uint256);\n\n  function fuseFeeMantissa() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalAdminFees() external view returns (uint256);\n\n  function totalFuseFees() external view returns (uint256);\n\n  function isCToken() external view returns (bool);\n\n  function isCEther() external view returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./IMulticall.sol\";\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n  /// @inheritdoc IMulticall\n  function multicall(bytes[] calldata data) public payable override returns (bytes[] memory results) {\n    results = new bytes[](data.length);\n    for (uint256 i = 0; i < data.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n      if (!success) {\n        // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n        if (result.length < 68) revert();\n        assembly {\n          result := add(result, 0x04)\n        }\n        revert(abi.decode(result, (string)));\n      }\n\n      results[i] = result;\n    }\n  }\n}\n"
    },
    "contracts/utils/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n  /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n  /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n  /// @param data The encoded function data for each of the calls to make to this contract\n  /// @return results The results from each of the calls passed in via data\n  function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/compound/RewardsDistributorStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\n\ncontract RewardsDistributorDelegatorStorage {\n  /// @notice Administrator for this contract\n  address public admin;\n\n  /// @notice Pending administrator for this contract\n  address public pendingAdmin;\n\n  /// @notice Active brains of RewardsDistributor\n  address public implementation;\n}\n\n/**\n * @title Storage for RewardsDistributorDelegate\n * @notice For future upgrades, do not change RewardsDistributorDelegateStorageV1. Create a new\n * contract which implements RewardsDistributorDelegateStorageV1 and following the naming convention\n * RewardsDistributorDelegateStorageVX.\n */\ncontract RewardsDistributorDelegateStorageV1 is RewardsDistributorDelegatorStorage {\n  /// @dev The token to reward (i.e., COMP)\n  address public rewardToken;\n\n  struct CompMarketState {\n    // The market's last updated compBorrowIndex or compSupplyIndex\n    uint224 index;\n    // The block number the index was last updated at\n    uint32 block;\n  }\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compSupplySpeeds;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compBorrowSpeeds;\n\n  /// @notice The COMP market supply state for each market\n  mapping(address => CompMarketState) public compSupplyState;\n\n  /// @notice The COMP market borrow state for each market\n  mapping(address => CompMarketState) public compBorrowState;\n\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compSupplierIndex;\n\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compBorrowerIndex;\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  mapping(address => uint256) public compAccrued;\n\n  /// @notice The portion of COMP that each contributor receives per block\n  mapping(address => uint256) public compContributorSpeeds;\n\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\n  mapping(address => uint256) public lastContributorBlock;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}