{
  "language": "Solidity",
  "sources": {
    "contracts/compound/CarefulMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n  /**\n   * @dev Possible error codes that we can return\n   */\n  enum MathError {\n    NO_ERROR,\n    DIVISION_BY_ZERO,\n    INTEGER_OVERFLOW,\n    INTEGER_UNDERFLOW\n  }\n\n  /**\n   * @dev Multiplies two numbers, returns an error on overflow.\n   */\n  function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (a == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    uint256 c = a * b;\n\n    if (c / a != b) {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    } else {\n      return (MathError.NO_ERROR, c);\n    }\n  }\n\n  /**\n   * @dev Integer division of two numbers, truncating the quotient.\n   */\n  function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b == 0) {\n      return (MathError.DIVISION_BY_ZERO, 0);\n    }\n\n    return (MathError.NO_ERROR, a / b);\n  }\n\n  /**\n   * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n   */\n  function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    if (b <= a) {\n      return (MathError.NO_ERROR, a - b);\n    } else {\n      return (MathError.INTEGER_UNDERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev Adds two numbers, returns an error on overflow.\n   */\n  function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\n    uint256 c = a + b;\n\n    if (c >= a) {\n      return (MathError.NO_ERROR, c);\n    } else {\n      return (MathError.INTEGER_OVERFLOW, 0);\n    }\n  }\n\n  /**\n   * @dev add a and b and then subtract c\n   */\n  function addThenSubUInt(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (MathError, uint256) {\n    (MathError err0, uint256 sum) = addUInt(a, b);\n\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, 0);\n    }\n\n    return subUInt(sum, c);\n  }\n}\n"
    },
    "contracts/compound/Exponential.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n  /**\n   * @dev Creates an exponential from numerator and denominator values.\n   *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n   *            or if `denom` is zero.\n   */\n  function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: rational }));\n  }\n\n  /**\n   * @dev Adds two exponentials, returning a new exponential.\n   */\n  function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Subtracts two exponentials, returning a new exponential.\n   */\n  function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n    return (error, Exp({ mantissa: result }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, returning a new Exp.\n   */\n  function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: scaledMantissa }));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mulScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(product));\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mulScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory product) = mulScalar(a, scalar);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return addUInt(truncate(product), addend);\n  }\n\n  /**\n   * @dev Divide an Exp by a scalar, returning a new Exp.\n   */\n  function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    return (MathError.NO_ERROR, Exp({ mantissa: descaledMantissa }));\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, returning a new Exp.\n   */\n  function divScalarByExp(uint256 scalar, Exp memory divisor) internal pure returns (MathError, Exp memory) {\n    /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n    (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n    return getExp(numerator, divisor.mantissa);\n  }\n\n  /**\n   * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n   */\n  function divScalarByExpTruncate(uint256 scalar, Exp memory divisor) internal pure returns (MathError, uint256) {\n    (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n    if (err != MathError.NO_ERROR) {\n      return (err, 0);\n    }\n\n    return (MathError.NO_ERROR, truncate(fraction));\n  }\n\n  /**\n   * @dev Multiplies two exponentials, returning a new exponential.\n   */\n  function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n    if (err0 != MathError.NO_ERROR) {\n      return (err0, Exp({ mantissa: 0 }));\n    }\n\n    // We add half the scale before dividing so that we get rounding instead of truncation.\n    //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n    // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n    (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n    if (err1 != MathError.NO_ERROR) {\n      return (err1, Exp({ mantissa: 0 }));\n    }\n\n    (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n    // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n    assert(err2 == MathError.NO_ERROR);\n\n    return (MathError.NO_ERROR, Exp({ mantissa: product }));\n  }\n\n  /**\n   * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n   */\n  function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\n    return mulExp(Exp({ mantissa: a }), Exp({ mantissa: b }));\n  }\n\n  /**\n   * @dev Multiplies three exponentials, returning a new exponential.\n   */\n  function mulExp3(\n    Exp memory a,\n    Exp memory b,\n    Exp memory c\n  ) internal pure returns (MathError, Exp memory) {\n    (MathError err, Exp memory ab) = mulExp(a, b);\n    if (err != MathError.NO_ERROR) {\n      return (err, ab);\n    }\n    return mulExp(ab, c);\n  }\n\n  /**\n   * @dev Divides two exponentials, returning a new exponential.\n   *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n   *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n   */\n  function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\n    return getExp(a.mantissa, b.mantissa);\n  }\n}\n"
    },
    "contracts/compound/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint256 constant expScale = 1e18;\n  uint256 constant doubleScale = 1e36;\n  uint256 constant halfExpScale = expScale / 2;\n  uint256 constant mantissaOne = expScale;\n\n  struct Exp {\n    uint256 mantissa;\n  }\n\n  struct Double {\n    uint256 mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n   */\n  function truncate(Exp memory exp) internal pure returns (uint256) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n   */\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n   */\n  function mul_ScalarTruncateAddUInt(\n    Exp memory a,\n    uint256 scalar,\n    uint256 addend\n  ) internal pure returns (uint256) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n   */\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n   */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n   */\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n   */\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\n    require(n < 2**224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: add_(a.mantissa, b.mantissa) });\n  }\n\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return add_(a, b, \"addition overflow\");\n  }\n\n  function add_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\n  }\n\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub_(a, b, \"subtraction underflow\");\n  }\n\n  function sub_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / expScale });\n  }\n\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b.mantissa) / doubleScale });\n  }\n\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: mul_(a.mantissa, b) });\n  }\n\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mul_(a, b, \"multiplication overflow\");\n  }\n\n  function mul_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(mul_(a.mantissa, expScale), b.mantissa) });\n  }\n\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n    return Exp({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa) });\n  }\n\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(a.mantissa, b) });\n  }\n\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div_(a, b, \"divide by zero\");\n  }\n\n  function div_(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\n    return Double({ mantissa: div_(mul_(a, doubleScale), b) });\n  }\n}\n"
    },
    "contracts/compound/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"./CErc20.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./RewardsDistributorDelegate.sol\";\n\nimport \"../oracles/default/KeydonixUniswapTwapPriceOracle.sol\";\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n * @dev This contract should not to be deployed alone; instead, deploy `Unitroller` (proxy contract) on top of this `Comptroller` (logic/implementation contract).\n */\ncontract Comptroller is ComptrollerV3Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(CToken cToken);\n\n  /// @notice Emitted when an admin unsupports a market\n  event MarketUnlisted(CToken cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(CToken cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(CToken cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint256 oldCloseFactorMantissa, uint256 newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(CToken cToken, uint256 oldCollateralFactorMantissa, uint256 newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint256 oldLiquidationIncentiveMantissa, uint256 newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  /// @notice Emitted when an action is paused globally\n  event ActionPaused(string action, bool pauseState);\n\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(CToken cToken, string action, bool pauseState);\n\n  /// @notice Emitted when the whitelist enforcement is changed\n  event WhitelistEnforcementChanged(bool enforce);\n\n  /// @notice Emitted when auto implementations are toggled\n  event AutoImplementationsToggled(bool enabled);\n\n  /// @notice Emitted when supply cap for a cToken is changed\n  event NewSupplyCap(CToken indexed cToken, uint256 newSupplyCap);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(CToken indexed cToken, uint256 newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when a new RewardsDistributor contract is added to hooks\n  event AddedRewardsDistributor(address rewardsDistributor);\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint256 internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  // liquidationIncentiveMantissa must be no less than this value\n  uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n  // liquidationIncentiveMantissa must be no greater than this value\n  uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n   * @param account The address of the account to pull assets for\n   * @return A dynamic list with the assets the account has entered\n   */\n  function getAssetsIn(address account) external view returns (CToken[] memory) {\n    CToken[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n   * @param account The address of the account to check\n   * @param cToken The cToken to check\n   * @return True if the account is in the asset, otherwise false.\n   */\n  function checkMembership(address account, CToken cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n   * @param cTokens The list of addresses of the cToken markets to be enabled\n   * @return Success indicator for whether each corresponding market was entered\n   */\n  function enterMarkets(address[] memory cTokens) public override returns (uint256[] memory) {\n    uint256 len = cTokens.length;\n\n    uint256[] memory results = new uint256[](len);\n    for (uint256 i = 0; i < len; i++) {\n      CToken cToken = CToken(cTokens[i]);\n\n      results[i] = uint256(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n   * @param cToken The market to enter\n   * @param borrower The address of the account to modify\n   * @return Success indicator for whether the market was entered\n   */\n  function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    // Add to allBorrowers\n    if (!borrowers[borrower]) {\n      allBorrowers.push(borrower);\n      borrowers[borrower] = true;\n      borrowerIndexes[borrower] = allBorrowers.length - 1;\n    }\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  function exitMarketWithPriceProof(\n    address cTokenAddress,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    CToken[] memory assets = accountAssets[msg.sender];\n    require(assets.length == proofData.length, \"invalid price proof data size\");\n    for (uint256 i = 0; i < assets.length; i++) {\n      ICToken asInterface = ICToken(address(assets[i]));\n      KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(asInterface, proofData[i]);\n    }\n\n    return exitMarket(cTokenAddress);\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n   * @dev Sender must not have an outstanding borrow balance in the asset,\n   *  or be providing neccessary collateral for an outstanding borrow.\n   * @param cTokenAddress The address of the asset to be removed\n   * @return Whether or not the account successfully exited the market\n   */\n  function exitMarket(address cTokenAddress) public override returns (uint256) {\n    CToken cToken = CToken(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint256 oErr, uint256 tokensHeld, uint256 amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"exitMarket: getAccountSnapshot failed\"); // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint256 allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[address(cToken)];\n\n    /* Return true if the sender is not already ‘in’ the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the account’s list of assets */\n    // load into memory for faster iteration\n    CToken[] memory userAssetList = accountAssets[msg.sender];\n    uint256 len = userAssetList.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (userAssetList[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    CToken[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    // If the user has exited all markets, remove them from the `allBorrowers` array\n    if (storedList.length == 0) {\n      allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n      allBorrowers.pop(); // Reduce length by 1\n      borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n      borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n      borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n    }\n\n    emit MarketExited(cToken, msg.sender);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n   * @param cToken The market to verify the mint against\n   * @param minter The account which would get the minted tokens\n   * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n   * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n    // Shh - currently unused\n    minter;\n    mintAmount;\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure minter is whitelisted\n    if (enforceWhitelist && !whitelist[minter]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    // Check supply cap\n    uint256 supplyCap = supplyCaps[cToken];\n    // Supply cap of 0 corresponds to unlimited supplying\n    if (supplyCap != 0) {\n      uint256 totalCash = CToken(cToken).getCash();\n      uint256 totalBorrows = CToken(cToken).totalBorrows();\n      uint256 totalReserves = CToken(cToken).totalReserves();\n      uint256 totalFuseFees = CToken(cToken).totalFuseFees();\n      uint256 totalAdminFees = CToken(cToken).totalAdminFees();\n\n      // totalUnderlyingSupply = totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)\n      (MathError mathErr, uint256 totalUnderlyingSupply) = addThenSubUInt(\n        totalCash,\n        totalBorrows,\n        add_(add_(totalReserves, totalFuseFees), totalAdminFees)\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      uint256 nextTotalUnderlyingSupply;\n      (mathErr, nextTotalUnderlyingSupply) = addUInt(totalUnderlyingSupply, mintAmount);\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      require(nextTotalUnderlyingSupply < supplyCap, \"market supply cap reached\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, minter);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n   * @param cToken Asset being minted\n   * @param minter The address minting the tokens\n   * @param actualMintAmount The amount of the underlying asset being minted\n   * @param mintTokens The number of tokens being minted\n   */\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 actualMintAmount,\n    uint256 mintTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    minter;\n    actualMintAmount;\n    mintTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n\n    // Add minter to suppliers mapping\n    suppliers[minter] = true;\n  }\n\n  function redeemAllowedWithPriceProof(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    CToken[] memory assets = accountAssets[redeemer];\n    require(assets.length == proofData.length, \"invalid price proof data size\");\n    for (uint256 i = 0; i < assets.length; i++) {\n      ICToken asInterface = ICToken(address(assets[i]));\n      KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(asInterface, proofData[i]);\n    }\n\n    return redeemAllowed(cToken, redeemer, redeemTokens);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n   * @param cToken The market to verify the redeem against\n   * @param redeemer The account which would redeem the tokens\n   * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n   * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) public override returns (uint256) {\n    uint256 allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreSupplierAction(cToken, redeemer);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) internal view returns (uint256) {\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      redeemer,\n      CToken(cToken),\n      redeemTokens,\n      0\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n   * @param cToken Asset being redeemed\n   * @param redeemer The address redeeming the tokens\n   * @param redeemAmount The amount of the underlying asset being redeemed\n   * @param redeemTokens The number of tokens being redeemed\n   */\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    redeemer;\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"redeemTokens zero\");\n    }\n  }\n\n  function borrowAllowedWithPriceProof(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount,\n    UniswapOracle.ProofData calldata proofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cToken), proofData);\n\n    return borrowAllowed(cToken, borrower, borrowAmount);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken The market to verify the borrow against\n   * @param borrower The account which would borrow the asset\n   * @param borrowAmount The amount of underlying the account would borrow\n   * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) public override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"sender must be cToken\");\n\n      // attempt to add borrower to the market\n      Error err = addToMarketInternal(CToken(msg.sender), borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    // Make sure oracle price is available\n    if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n      return uint256(Error.PRICE_ERROR);\n    }\n\n    // Make sure borrower is whitelisted\n    if (enforceWhitelist && !whitelist[borrower]) {\n      return uint256(Error.SUPPLIER_NOT_WHITELISTED);\n    }\n\n    // Check borrow cap\n    uint256 borrowCap = borrowCaps[cToken];\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0) {\n      uint256 totalBorrows = CToken(cToken).totalBorrows();\n      (MathError mathErr, uint256 nextTotalBorrows) = addUInt(totalBorrows, borrowAmount);\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n      require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    // Perform a hypothetical liquidity check to guard against shortfall\n    (Error err, , uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      borrower,\n      CToken(cToken),\n      0,\n      borrowAmount\n    );\n    if (err != Error.NO_ERROR) {\n      return uint256(err);\n    }\n    if (shortfall > 0) {\n      return uint256(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function borrowWithinLimitsWithPriceProof(\n    address cToken,\n    uint256 accountBorrowsNew,\n    UniswapOracle.ProofData calldata proofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cToken), proofData);\n\n    return borrowWithinLimits(cToken, accountBorrowsNew);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n   */\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) public override returns (uint256) {\n    // Check if min borrow exists\n    uint256 minBorrowEth = fuseAdmin.minBorrowEth();\n\n    if (minBorrowEth > 0) {\n      // Get new underlying borrow balance of account for this cToken\n      uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(CToken(cToken));\n      if (oraclePriceMantissa == 0) return uint256(Error.PRICE_ERROR);\n      (MathError mathErr, uint256 borrowBalanceEth) = mulScalarTruncate(\n        Exp({ mantissa: oraclePriceMantissa }),\n        accountBorrowsNew\n      );\n      if (mathErr != MathError.NO_ERROR) return uint256(Error.MATH_ERROR);\n\n      // Check against min borrow\n      if (borrowBalanceEth < minBorrowEth) return uint256(Error.BORROW_BELOW_MIN);\n    }\n\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n   * @param cToken Asset whose underlying is being borrowed\n   * @param exchangeRateMantissa Underlying/cToken exchange rate\n   * @param accountTokens Initial account cToken balance\n   * @param accountTokens Underlying amount to mint\n   */\n  function mintWithinLimits(\n    address cToken,\n    uint256 exchangeRateMantissa,\n    uint256 accountTokens,\n    uint256 mintAmount\n  ) external override returns (uint256) {\n    // Return no error\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates borrow and reverts on rejection. May emit logs.\n   * @param cToken Asset whose underlying is being borrowed\n   * @param borrower The address borrowing the underlying\n   * @param borrowAmount The amount of the underlying asset requested to borrow\n   */\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    borrower;\n    borrowAmount;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n   * @param cToken The market to verify the repay against\n   * @param payer The account which would repay the asset\n   * @param borrower The account which would borrowed the asset\n   * @param repayAmount The amount of the underlying asset the account would repay\n   * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external override returns (uint256) {\n    // Shh - currently unused\n    payer;\n    borrower;\n    repayAmount;\n\n    // Make sure market is listed\n    if (!markets[cToken].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreBorrowerAction(cToken, borrower);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n   * @param cToken Asset being repaid\n   * @param payer The address repaying the borrow\n   * @param borrower The address of the borrower\n   * @param actualRepayAmount The amount of underlying being repaid\n   */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 borrowerIndex\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    payer;\n    borrower;\n    actualRepayAmount;\n    borrowerIndex;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  function liquidateBorrowAllowedWithPriceProof(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    UniswapOracle.ProofData calldata borrowedProofData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cTokenBorrowed), borrowedProofData);\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cTokenCollateral), collateralProofData);\n\n    return liquidateBorrowAllowed(cTokenBorrowed, cTokenCollateral, liquidator, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param repayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) public override returns (uint256) {\n    // Shh - currently unused\n    liquidator;\n\n    // Make sure markets are listed\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Get borrowers's underlying borrow balance\n    uint256 borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(CToken(cTokenBorrowed))) {\n      require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n    } else {\n      /* The borrower must have shortfall in order to be liquidatable */\n      (Error err, , uint256 shortfall) = getAccountLiquidityInternal(borrower);\n      if (err != Error.NO_ERROR) {\n        return uint256(err);\n      }\n\n      if (shortfall == 0) {\n        return uint256(Error.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint256 maxClose = mul_ScalarTruncate(Exp({ mantissa: closeFactorMantissa }), borrowBalance);\n      if (repayAmount > maxClose) {\n        return uint256(Error.TOO_MUCH_REPAY);\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param actualRepayAmount The amount of underlying being repaid\n   */\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 seizeTokens\n  ) external override {\n    // Shh - currently unused\n    cTokenBorrowed;\n    cTokenCollateral;\n    liquidator;\n    borrower;\n    actualRepayAmount;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"seize is paused\");\n\n    // Shh - currently unused\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Make sure markets are listed\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint256(Error.MARKET_NOT_LISTED);\n    }\n\n    // Make sure cToken Comptrollers are identical\n    if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n      return uint256(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cTokenCollateral, borrower, liquidator);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates seize and reverts on rejection. May emit logs.\n   * @param cTokenCollateral Asset which was used as collateral and will be seized\n   * @param cTokenBorrowed Asset which was borrowed by the borrower\n   * @param liquidator The address repaying the borrow and seizing the collateral\n   * @param borrower The address of the borrower\n   * @param seizeTokens The number of collateral tokens to seize\n   */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override {\n    // Shh - currently unused\n    cTokenCollateral;\n    cTokenBorrowed;\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  function transferAllowedWithPriceProof(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external override returns (uint256) {\n    CToken[] memory assets = accountAssets[src];\n    require(assets.length == proofData.length, \"invalid price proof data size\");\n    for (uint256 i = 0; i < assets.length; i++) {\n      ICToken asInterface = ICToken(address(assets[i]));\n      KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(asInterface, proofData[i]);\n    }\n\n    return transferAllowed(cToken, src, dst, transferTokens);\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n   * @param cToken The market to verify the transfer against\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n   */\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) public override returns (uint256) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"transfer is paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint256 allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint256(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    flywheelPreTransferAction(cToken, src, dst);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates transfer and reverts on rejection. May emit logs.\n   * @param cToken Asset being transferred\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   * @param transferTokens The number of cTokens to transfer\n   */\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external override {\n    // Shh - currently unused\n    cToken;\n    src;\n    dst;\n    transferTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /*** Flywheel Hooks ***/\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreSupplierAction(cToken, supplier);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreBorrowerAction(cToken, borrower);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(\n    address cToken,\n    address src,\n    address dst\n  ) internal {\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      RewardsDistributorDelegate(rewardsDistributors[i]).flywheelPreTransferAction(cToken, src, dst);\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n   *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n   *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n   */\n  struct AccountLiquidityLocalVars {\n    uint256 sumCollateral;\n    uint256 sumBorrowPlusEffects;\n    uint256 cTokenBalance;\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n    uint256 oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n  }\n\n  /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidity(address account)\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      CToken(address(0)),\n      0,\n      0\n    );\n\n    return (uint256(err), liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidityInternal(address account)\n    internal\n    view\n    returns (\n      Error,\n      uint256,\n      uint256\n    )\n  {\n    return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (Error err, uint256 liquidity, uint256 shortfall) = getHypotheticalAccountLiquidityInternal(\n      account,\n      CToken(cTokenModify),\n      redeemTokens,\n      borrowAmount\n    );\n    return (uint256(err), liquidity, shortfall);\n  }\n\n  /**\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    CToken cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n    internal\n    view\n    returns (\n      Error,\n      uint256,\n      uint256\n    )\n  {\n    AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n    uint256 oErr;\n\n    // For each asset the account is in\n    CToken[] memory assets = accountAssets[account];\n    for (uint256 i = 0; i < assets.length; i++) {\n      CToken asset = assets[i];\n\n      // Read the balances and exchange rate from the cToken\n      (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n      if (oErr != 0) {\n        // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n        return (Error.SNAPSHOT_ERROR, 0, 0);\n      }\n      vars.collateralFactor = Exp({ mantissa: markets[address(asset)].collateralFactorMantissa });\n      vars.exchangeRate = Exp({ mantissa: vars.exchangeRateMantissa });\n\n      // Get the normalized price of the asset\n      vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n      if (vars.oraclePriceMantissa == 0) {\n        return (Error.PRICE_ERROR, 0, 0);\n      }\n      vars.oraclePrice = Exp({ mantissa: vars.oraclePriceMantissa });\n\n      // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n      vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n      // sumCollateral += tokensToDenom * cTokenBalance\n      vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n        vars.oraclePrice,\n        vars.borrowBalance,\n        vars.sumBorrowPlusEffects\n      );\n\n      // Calculate effects of interacting with cTokenModify\n      if (asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.tokensToDenom,\n          redeemTokens,\n          vars.sumBorrowPlusEffects\n        );\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(\n          vars.oraclePrice,\n          borrowAmount,\n          vars.sumBorrowPlusEffects\n        );\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  //    function liquidateCalculateSeizeTokensWithPriceProof(\n  //        address cTokenBorrowed,\n  //        address cTokenCollateral,\n  //        uint256 actualRepayAmount,\n  //        UniswapOracle.ProofData calldata borrowedProofData,\n  //        UniswapOracle.ProofData calldata collateralProofData,\n  //        address _keydonixPriceOracle\n  //    ) override external view returns (uint256, uint256) {\n  //        KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cTokenBorrowed), borrowedProofData);\n  //        KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(ICToken(cTokenCollateral), collateralProofData);\n  //\n  //        return liquidateCalculateSeizeTokens(cTokenBorrowed, cTokenCollateral, actualRepayAmount);\n  //    }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n   * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n   * @param cTokenBorrowed The address of the borrowed cToken\n   * @param cTokenCollateral The address of the collateral cToken\n   * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n   * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n   */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view override returns (uint256, uint256) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint256 priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n    uint256 priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint256(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint256 exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n    uint256 seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = mul_(Exp({ mantissa: liquidationIncentiveMantissa }), Exp({ mantissa: priceBorrowedMantissa }));\n    denominator = mul_(Exp({ mantissa: priceCollateralMantissa }), Exp({ mantissa: exchangeRateMantissa }));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n    return (uint256(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Add a RewardsDistributor contracts.\n   * @dev Admin function to add a RewardsDistributor contract\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _addRewardsDistributor(address distributor) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK);\n    }\n\n    // Check marker method\n    require(RewardsDistributorDelegate(distributor).isRewardsDistributor(), \"marker method returned false\");\n\n    // Check for existing RewardsDistributor\n    for (uint256 i = 0; i < rewardsDistributors.length; i++)\n      require(distributor != rewardsDistributors[i], \"RewardsDistributor contract already added\");\n\n    // Add RewardsDistributor to array\n    rewardsDistributors.push(distributor);\n    emit AddedRewardsDistributor(distributor);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist enforcement for the comptroller\n   * @dev Admin function to set a new whitelist enforcement boolean\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_ENFORCEMENT_OWNER_CHECK);\n    }\n\n    // Check if `enforceWhitelist` already equals `enforce`\n    if (enforceWhitelist == enforce) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    // Set comptroller's `enforceWhitelist` to `enforce`\n    enforceWhitelist = enforce;\n\n    // Emit WhitelistEnforcementChanged(bool enforce);\n    emit WhitelistEnforcementChanged(enforce);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the whitelist `statuses` for `suppliers`\n   * @dev Admin function to set the whitelist `statuses` for `suppliers`\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setWhitelistStatuses(address[] calldata suppliers, bool[] calldata statuses) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_WHITELIST_STATUS_OWNER_CHECK);\n    }\n\n    // Set whitelist statuses for suppliers\n    for (uint256 i = 0; i < suppliers.length; i++) {\n      address supplier = suppliers[i];\n\n      if (statuses[i]) {\n        // If not already whitelisted, add to whitelist\n        if (!whitelist[supplier]) {\n          whitelist[supplier] = true;\n          whitelistArray.push(supplier);\n          whitelistIndexes[supplier] = whitelistArray.length - 1;\n        }\n      } else {\n        // If whitelisted, remove from whitelist\n        if (whitelist[supplier]) {\n          whitelistArray[whitelistIndexes[supplier]] = whitelistArray[whitelistArray.length - 1]; // Copy last item in list to location of item to be removed\n          whitelistArray.pop(); // Reduce length by 1\n          whitelistIndexes[whitelistArray[whitelistIndexes[supplier]]] = whitelistIndexes[supplier]; // Set whitelist index of moved item to correct index\n          whitelistIndexes[supplier] = 0; // Reset supplier whitelist index to 0 for a gas refund\n          whitelist[supplier] = false; // Tell the contract that the supplier is no longer whitelisted\n        }\n      }\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets a new price oracle for the comptroller\n   * @dev Admin function to set a new price oracle\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPriceOracle(PriceOracle newOracle) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    PriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the closeFactor used when liquidating borrows\n   * @dev Admin function to set closeFactor\n   * @param newCloseFactorMantissa New close factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n    }\n\n    // Check limits\n    Exp memory newCloseFactorExp = Exp({ mantissa: newCloseFactorMantissa });\n    Exp memory lowLimit = Exp({ mantissa: closeFactorMinMantissa });\n    if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    Exp memory highLimit = Exp({ mantissa: closeFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCloseFactorExp)) {\n      return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n    }\n\n    // Set pool close factor to new close factor, remember old value\n    uint256 oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n\n    // Emit event\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets the collateralFactor for a market\n   * @dev Admin function to set per-market collateralFactor\n   * @param cToken The market to set the factor on\n   * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setCollateralFactor(CToken cToken, uint256 newCollateralFactorMantissa) public returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({ mantissa: newCollateralFactorMantissa });\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({ mantissa: collateralFactorMaxMantissa });\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sets liquidationIncentive\n   * @dev Admin function to set liquidationIncentive\n   * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n   * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n   */\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Check de-scaled min <= newLiquidationIncentive <= max\n    Exp memory newLiquidationIncentive = Exp({ mantissa: newLiquidationIncentiveMantissa });\n    Exp memory minLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMinMantissa });\n    if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    Exp memory maxLiquidationIncentive = Exp({ mantissa: liquidationIncentiveMaxMantissa });\n    if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n      return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n    }\n\n    // Save current value for use in log\n    uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Add the market to the markets mapping and set it as listed\n   * @dev Admin function to set isListed and add support for the market\n   * @param cToken The address of the market (token) to list\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _supportMarket(CToken cToken) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Is market already listed?\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n    // Sanity check to make sure its really a CToken\n    require(cToken.isCToken(), \"marker method returned false\");\n\n    // Check cToken.comptroller == this\n    require(address(cToken.comptroller()) == address(this), \"Cannot support a market with a different Comptroller.\");\n\n    // Make sure market is not already listed\n    address underlying = cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying();\n\n    if (address(cTokensByUnderlying[underlying]) != address(0)) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    // List market and emit event\n    Market storage market = markets[address(cToken)];\n    market.isListed = true;\n    market.collateralFactorMantissa = 0;\n    allMarkets.push(cToken);\n    cTokensByUnderlying[underlying] = cToken;\n    emit MarketListed(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Deploy cToken, add the market to the markets mapping, and set it as listed and set the collateral factor\n   * @dev Admin function to deploy cToken, set isListed, and add support for the market and set the collateral factor\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _deployMarket(\n    bool isCEther,\n    bytes calldata constructorData,\n    uint256 collateralFactorMantissa\n  ) external returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    // Temporarily enable Fuse admin rights for asset deployment (storing the original value)\n    bool oldFuseAdminHasRights = fuseAdminHasRights;\n    fuseAdminHasRights = true;\n\n    // Deploy via Fuse admin\n    CToken cToken = CToken(\n      isCEther ? fuseAdmin.deployCEther(constructorData) : fuseAdmin.deployCErc20(constructorData)\n    );\n    // Reset Fuse admin rights to the original value\n    fuseAdminHasRights = oldFuseAdminHasRights;\n    // Support market here in the Comptroller\n    uint256 err = _supportMarket(cToken);\n\n    // Set collateral factor\n    return err == uint256(Error.NO_ERROR) ? _setCollateralFactor(cToken, collateralFactorMantissa) : err;\n  }\n\n  /**\n   * @notice Removed a market from the markets mapping and sets it as unlisted\n   * @dev Admin function unset isListed and collateralFactorMantissa and unadd support for the market\n   * @param cToken The address of the market (token) to unlist\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _unsupportMarket(CToken cToken) external returns (uint256) {\n    // Check admin rights\n    if (!hasAdminRights()) return fail(Error.UNAUTHORIZED, FailureInfo.UNSUPPORT_MARKET_OWNER_CHECK);\n\n    // Check if market is already unlisted\n    if (!markets[address(cToken)].isListed)\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.UNSUPPORT_MARKET_DOES_NOT_EXIST);\n\n    // Check if market is in use\n    if (cToken.totalSupply() > 0) return fail(Error.NONZERO_TOTAL_SUPPLY, FailureInfo.UNSUPPORT_MARKET_IN_USE);\n\n    // Unlist market\n    delete markets[address(cToken)];\n\n    /* Delete cToken from allMarkets */\n    // load into memory for faster iteration\n    CToken[] memory _allMarkets = allMarkets;\n    uint256 len = _allMarkets.length;\n    uint256 assetIndex = len;\n    for (uint256 i = 0; i < len; i++) {\n      if (_allMarkets[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    allMarkets[assetIndex] = allMarkets[allMarkets.length - 1];\n    allMarkets.pop();\n\n    cTokensByUnderlying[cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying()] = CToken(address(0));\n    emit MarketUnlisted(cToken);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles the auto-implementation feature\n   * @param enabled If the feature is to be enabled\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _toggleAutoImplementations(bool enabled) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK);\n    }\n\n    // Return no error if already set to the desired value\n    if (autoImplementation == enabled) return uint256(Error.NO_ERROR);\n\n    // Store autoImplementation with value enabled\n    autoImplementation = enabled;\n\n    // Emit AutoImplementationsToggled(enabled)\n    emit AutoImplementationsToggled(enabled);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Set the given supply caps for the given cToken markets. Supplying that brings total underlying supply to or above supply cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the supply caps. A supply cap of 0 corresponds to unlimited supplying.\n   * @param cTokens The addresses of the markets (tokens) to change the supply caps for\n   * @param newSupplyCaps The new supply cap values in underlying to be set. A value of 0 corresponds to unlimited supplying.\n   */\n  function _setMarketSupplyCaps(CToken[] calldata cTokens, uint256[] calldata newSupplyCaps) external {\n    require(\n      msg.sender == admin || msg.sender == borrowCapGuardian,\n      \"only admin or borrow cap guardian can set supply caps\"\n    );\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numSupplyCaps = newSupplyCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numSupplyCaps, \"invalid input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      supplyCaps[address(cTokens[i])] = newSupplyCaps[i];\n      emit NewSupplyCap(cTokens[i], newSupplyCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n   * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n   * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n   * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n   */\n  function _setMarketBorrowCaps(CToken[] calldata cTokens, uint256[] calldata newBorrowCaps) external {\n    require(\n      msg.sender == admin || msg.sender == borrowCapGuardian,\n      \"only admin or borrow cap guardian can set borrow caps\"\n    );\n\n    uint256 numMarkets = cTokens.length;\n    uint256 numBorrowCaps = newBorrowCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n    for (uint256 i = 0; i < numMarkets; i++) {\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to change the Borrow Cap Guardian\n   * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n   */\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n    require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n    // Save current value for inclusion in log\n    address oldBorrowCapGuardian = borrowCapGuardian;\n\n    // Store borrowCapGuardian with value newBorrowCapGuardian\n    borrowCapGuardian = newBorrowCapGuardian;\n\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n  }\n\n  /**\n   * @notice Admin function to change the Pause Guardian\n   * @param newPauseGuardian The address of the new Pause Guardian\n   * @return uint 0=success, otherwise a failure. (See enum Error for details)\n   */\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n    }\n\n    // Save current value for inclusion in log\n    address oldPauseGuardian = pauseGuardian;\n\n    // Store pauseGuardian with value newPauseGuardian\n    pauseGuardian = newPauseGuardian;\n\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    mintGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Mint\", state);\n    return state;\n  }\n\n  function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    borrowGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Borrow\", state);\n    return state;\n  }\n\n  function _setTransferPaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    transferGuardianPaused = state;\n    emit ActionPaused(\"Transfer\", state);\n    return state;\n  }\n\n  function _setSeizePaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || hasAdminRights(), \"only pause guardian and admin can pause\");\n    require(hasAdminRights() || state == true, \"only admin can unpause\");\n\n    seizeGuardianPaused = state;\n    emit ActionPaused(\"Seize\", state);\n    return state;\n  }\n\n  function _become(Unitroller unitroller) public {\n    require(\n      (msg.sender == address(fuseAdmin) && unitroller.fuseAdminHasRights()) ||\n        (msg.sender == unitroller.admin() && unitroller.adminHasRights()),\n      \"only unitroller admin can change brains\"\n    );\n\n    uint256 changeStatus = unitroller._acceptImplementation();\n    require(changeStatus == 0, \"change not authorized\");\n\n    Comptroller(address(unitroller))._becomeImplementation();\n  }\n\n  function _becomeImplementation() external {\n    require(msg.sender == comptrollerImplementation, \"only implementation may call _becomeImplementation\");\n\n    if (!_notEnteredInitialized) {\n      _notEntered = true;\n      _notEnteredInitialized = true;\n    }\n  }\n\n  /*** Helper Functions ***/\n\n  /**\n   * @notice Return all of the markets\n   * @dev The automatic getter may be used to access an individual market.\n   * @return The list of market addresses\n   */\n  function getAllMarkets() public view returns (CToken[] memory) {\n    return allMarkets;\n  }\n\n  /**\n   * @notice Return all of the borrowers\n   * @dev The automatic getter may be used to access an individual borrower.\n   * @return The list of borrower account addresses\n   */\n  function getAllBorrowers() public view returns (address[] memory) {\n    return allBorrowers;\n  }\n\n  /**\n   * @notice Return all of the whitelist\n   * @dev The automatic getter may be used to access an individual whitelist status.\n   * @return The list of borrower account addresses\n   */\n  function getWhitelist() external view returns (address[] memory) {\n    return whitelistArray;\n  }\n\n  /**\n   * @notice Returns an array of all RewardsDistributors\n   */\n  function getRewardsDistributors() external view returns (address[] memory) {\n    return rewardsDistributors;\n  }\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n   * @dev All borrows in a deprecated cToken market can be immediately liquidated\n   * @param cToken The market to check if deprecated\n   */\n  function isDeprecated(CToken cToken) public view returns (bool) {\n    return\n      markets[address(cToken)].collateralFactorMantissa == 0 &&\n      borrowGuardianPaused[address(cToken)] == true &&\n      add_(add_(cToken.reserveFactorMantissa(), cToken.adminFeeMantissa()), cToken.fuseFeeMantissa()) == 1e18;\n  }\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  /**\n   * @dev Called by cTokens before a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _beforeNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"Comptroller:_beforeNonReentrant: caller not listed as market\");\n    require(_notEntered, \"re-entered across assets\");\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Called by cTokens after a non-reentrant function for pool-wide reentrancy prevention.\n   * Prevents pool-wide/cross-asset reentrancy exploits like AMP on Cream.\n   */\n  function _afterNonReentrant() external override {\n    require(markets[msg.sender].isListed, \"Comptroller:_afterNonReentrant: caller not listed as market\");\n    _notEntered = true; // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/compound/CToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./Exponential.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ncontract CToken is CTokenInterface, Exponential, TokenErrorReporter {\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    ComptrollerV3Storage comptrollerStorage = ComptrollerV3Storage(address(comptroller));\n    return\n      (msg.sender == comptrollerStorage.admin() && comptrollerStorage.adminHasRights()) ||\n      (msg.sender == address(fuseAdmin) && comptrollerStorage.fuseAdminHasRights());\n  }\n\n  /**\n   * @notice Initialize the money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n   * @param name_ EIP-20 name of this token\n   * @param symbol_ EIP-20 symbol of this token\n   * @param decimals_ EIP-20 decimal precision of this token\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint256 initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n    require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n    // Set the comptroller\n    uint256 err = _setComptroller(comptroller_);\n    require(err == uint256(Error.NO_ERROR), \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == uint256(Error.NO_ERROR), \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // Set reserve factor\n    err = _setReserveFactorFresh(reserveFactorMantissa_);\n    require(err == uint256(Error.NO_ERROR), \"setting reserve factor failed\");\n\n    // Set admin fee\n    err = _setAdminFeeFresh(adminFeeMantissa_);\n    require(err == uint256(Error.NO_ERROR), \"setting admin fee failed\");\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @dev Returns latest pending Fuse fee (to be set with `_setFuseFeeFresh`)\n   */\n  function getPendingFuseFeeFromAdmin() internal view returns (uint256) {\n    return fuseAdmin.interestFeeRate();\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n   * @dev Called by both `transfer` and `transferFrom` internally\n   * @param spender The address of the account performing the transfer\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param tokens The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferTokens(\n    address spender,\n    address src,\n    address dst,\n    uint256 tokens\n  ) internal returns (uint256) {\n    /* Fail if transfer not allowed */\n    uint256 allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.TRANSFER_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      return fail(Error.BAD_INPUT, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint256 startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint256).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    MathError mathErr;\n    uint256 allowanceNew;\n    uint256 srcTokensNew;\n    uint256 dstTokensNew;\n\n    (mathErr, allowanceNew) = subUInt(startingAllowance, tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ALLOWED);\n    }\n\n    (mathErr, srcTokensNew) = subUInt(accountTokens[src], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_NOT_ENOUGH);\n    }\n\n    (mathErr, dstTokensNew) = addUInt(accountTokens[dst], tokens);\n    if (mathErr != MathError.NO_ERROR) {\n      return fail(Error.MATH_ERROR, FailureInfo.TRANSFER_TOO_MUCH);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint256).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external override nonReentrant(false) returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external override nonReentrant(false) returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external override returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view override returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n   * @param owner The address of the account to query\n   * @return The number of tokens owned by `owner`\n   */\n  function balanceOf(address owner) external view override returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n   * @dev This also accrues interest in a transaction\n   * @param owner The address of the account to query\n   * @return The amount of underlying owned by `owner`\n   */\n  function balanceOfUnderlying(address owner) external override returns (uint256) {\n    Exp memory exchangeRate = Exp({ mantissa: exchangeRateCurrent() });\n    (MathError mErr, uint256 balance) = mulScalarTruncate(exchangeRate, accountTokens[owner]);\n    require(mErr == MathError.NO_ERROR, \"balance could not be calculated\");\n    return balance;\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n   * @dev This is used by comptroller to more efficiently perform liquidity checks.\n   * @param account Address of the account to snapshot\n   * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n   */\n  function getAccountSnapshot(address account)\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 cTokenBalance = accountTokens[account];\n    uint256 borrowBalance;\n    uint256 exchangeRateMantissa;\n\n    MathError mErr;\n\n    (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (mErr != MathError.NO_ERROR) {\n      return (uint256(Error.MATH_ERROR), 0, 0, 0);\n    }\n\n    return (uint256(Error.NO_ERROR), cTokenBalance, borrowBalance, exchangeRateMantissa);\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n   *  This exists mainly for inheriting test contracts to stub this result.\n   */\n  function getBlockNumber() internal view returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n   * @return The borrow interest rate per block, scaled by 1e18\n   */\n  function borrowRatePerBlock() external view override returns (uint256) {\n    return\n      interestRateModel.getBorrowRate(\n        getCashPrior(),\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n      );\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n   * @return The supply interest rate per block, scaled by 1e18\n   */\n  function supplyRatePerBlock() external view override returns (uint256) {\n    return\n      interestRateModel.getSupplyRate(\n        getCashPrior(),\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees)),\n        reserveFactorMantissa + fuseFeeMantissa + adminFeeMantissa\n      );\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n   * @return The total borrows with interest\n   */\n  function totalBorrowsCurrent() external override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n   * @param account The address whose balance should be calculated after updating borrowIndex\n   * @return The calculated balance\n   */\n  function borrowBalanceCurrent(address account) external override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return The calculated balance\n   */\n  function borrowBalanceStored(address account) public view override returns (uint256) {\n    (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n    require(err == MathError.NO_ERROR, \"borrowBalanceStored: borrowBalanceStoredInternal failed\");\n    return result;\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n   * @param account The address whose balance should be calculated\n   * @return (error code, the calculated balance or 0 if error code is non-zero)\n   */\n  function borrowBalanceStoredInternal(address account) internal view returns (MathError, uint256) {\n    /* Note: we do not assert that the market is up to date */\n    MathError mathErr;\n    uint256 principalTimesIndex;\n    uint256 result;\n\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return (MathError.NO_ERROR, 0);\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    (mathErr, principalTimesIndex) = mulUInt(borrowSnapshot.principal, borrowIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    (mathErr, result) = divUInt(principalTimesIndex, borrowSnapshot.interestIndex);\n    if (mathErr != MathError.NO_ERROR) {\n      return (mathErr, 0);\n    }\n\n    return (MathError.NO_ERROR, result);\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateCurrent() public override nonReentrant(false) returns (uint256) {\n    require(accrueInterest() == uint256(Error.NO_ERROR), \"accrue interest failed\");\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return Calculated exchange rate scaled by 1e18\n   */\n  function exchangeRateStored() public view override returns (uint256) {\n    (MathError err, uint256 result) = exchangeRateStoredInternal();\n    require(err == MathError.NO_ERROR, \"exchangeRateStored: exchangeRateStoredInternal failed\");\n    return result;\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n   * @dev This function does not accrue interest before calculating the exchange rate\n   * @return (error code, calculated exchange rate scaled by 1e18)\n   */\n  function exchangeRateStoredInternal() internal view returns (MathError, uint256) {\n    uint256 _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return (MathError.NO_ERROR, initialExchangeRateMantissa);\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - (totalReserves + totalFuseFees + totalAdminFees)) / totalSupply\n       */\n      uint256 totalCash = getCashPrior();\n      uint256 cashPlusBorrowsMinusReserves;\n      Exp memory exchangeRate;\n      MathError mathErr;\n\n      (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n        totalCash,\n        totalBorrows,\n        add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n      );\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      (mathErr, exchangeRate) = getExp(cashPlusBorrowsMinusReserves, _totalSupply);\n      if (mathErr != MathError.NO_ERROR) {\n        return (mathErr, 0);\n      }\n\n      return (MathError.NO_ERROR, exchangeRate.mantissa);\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n   * @return The quantity of underlying asset owned by this contract\n   */\n  function getCash() external view override returns (uint256) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *   up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public virtual override returns (uint256) {\n    /* Remember the initial block number */\n    uint256 currentBlockNumber = getBlockNumber();\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumber == currentBlockNumber) {\n      return uint256(Error.NO_ERROR);\n    }\n\n    /* Read the previous values out of storage */\n    uint256 cashPrior = getCashPrior();\n\n    /* Calculate the current borrow interest rate */\n    uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\n      cashPrior,\n      totalBorrows,\n      add_(totalReserves, add_(totalAdminFees, totalFuseFees))\n    );\n    require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    (MathError mathErr, uint256 blockDelta) = subUInt(currentBlockNumber, accrualBlockNumber);\n    require(mathErr == MathError.NO_ERROR, \"could not calculate block delta\");\n\n    return finishInterestAccrual(currentBlockNumber, cashPrior, borrowRateMantissa, blockDelta);\n  }\n\n  /**\n   * @dev Split off from `accrueInterest` to avoid \"stack too deep\" error\".\n   */\n  function finishInterestAccrual(\n    uint256 currentBlockNumber,\n    uint256 cashPrior,\n    uint256 borrowRateMantissa,\n    uint256 blockDelta\n  ) private returns (uint256) {\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  totalFuseFeesNew = interestAccumulated * fuseFee + totalFuseFees\n     *  totalAdminFeesNew = interestAccumulated * adminFee + totalAdminFees\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(Exp({ mantissa: borrowRateMantissa }), blockDelta);\n    uint256 interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, totalBorrows);\n    uint256 totalBorrowsNew = add_(interestAccumulated, totalBorrows);\n    uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: reserveFactorMantissa }),\n      interestAccumulated,\n      totalReserves\n    );\n    uint256 totalFuseFeesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: fuseFeeMantissa }),\n      interestAccumulated,\n      totalFuseFees\n    );\n    uint256 totalAdminFeesNew = mul_ScalarTruncateAddUInt(\n      Exp({ mantissa: adminFeeMantissa }),\n      interestAccumulated,\n      totalAdminFees\n    );\n    uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndex, borrowIndex);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n    totalFuseFees = totalFuseFeesNew;\n    totalAdminFees = totalAdminFeesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintInternal(uint256 mintAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.MINT_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    return mintFresh(msg.sender, mintAmount);\n  }\n\n  struct MintLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 mintTokens;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n    uint256 actualMintAmount;\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param minter The address of the account which is supplying the assets\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual mint amount.\n   */\n  function mintFresh(address minter, uint256 mintAmount) internal returns (uint256, uint256) {\n    /* Fail if mint not allowed */\n    uint256 allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.MINT_FRESHNESS_CHECK), 0);\n    }\n\n    MintLocalVars memory vars;\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return (failOpaque(Error.MATH_ERROR, FailureInfo.MINT_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr)), 0);\n    }\n\n    // Check max supply\n    // unused function\n    /* allowed = comptroller.mintWithinLimits(address(this), vars.exchangeRateMantissa, accountTokens[minter], mintAmount);\n        if (allowed != 0) {\n            return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.MINT_COMPTROLLER_REJECTION, allowed), 0);\n        } */\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    vars.actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n      vars.actualMintAmount,\n      Exp({ mantissa: vars.exchangeRateMantissa })\n    );\n    require(vars.mathErr == MathError.NO_ERROR, \"MINT_EXCHANGE_CALCULATION_FAILED\");\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     */\n    vars.totalSupplyNew = add_(totalSupply, vars.mintTokens);\n\n    vars.accountTokensNew = add_(accountTokens[minter], vars.mintTokens);\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[minter] = vars.accountTokensNew;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, vars.actualMintAmount, vars.mintTokens);\n    emit Transfer(address(this), minter, vars.mintTokens);\n\n    /* We call the defense hook */\n    comptroller.mintVerify(address(this), minter, vars.actualMintAmount, vars.mintTokens);\n\n    return (uint256(Error.NO_ERROR), vars.actualMintAmount);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemInternal(uint256 redeemTokens) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n    }\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlyingInternal(uint256 redeemAmount) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failed\n      return fail(Error(error), FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);\n    }\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    return redeemFresh(msg.sender, 0, redeemAmount);\n  }\n\n  struct RedeemLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 exchangeRateMantissa;\n    uint256 redeemTokens;\n    uint256 redeemAmount;\n    uint256 totalSupplyNew;\n    uint256 accountTokensNew;\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n   * @dev Assumes interest has already been accrued up to the current block\n   * @param redeemer The address of the account which is redeeming the tokens\n   * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemFresh(\n    address redeemer,\n    uint256 redeemTokensIn,\n    uint256 redeemAmountIn\n  ) internal returns (uint256) {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n    RedeemLocalVars memory vars;\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_RATE_READ_FAILED, uint256(vars.mathErr));\n    }\n\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      vars.redeemTokens = redeemTokensIn;\n\n      (vars.mathErr, vars.redeemAmount) = mulScalarTruncate(\n        Exp({ mantissa: vars.exchangeRateMantissa }),\n        redeemTokensIn\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n\n      (vars.mathErr, vars.redeemTokens) = divScalarByExpTruncate(\n        redeemAmountIn,\n        Exp({ mantissa: vars.exchangeRateMantissa })\n      );\n      if (vars.mathErr != MathError.NO_ERROR) {\n        return\n          failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED, uint256(vars.mathErr));\n      }\n\n      vars.redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint256 allowed = comptroller.redeemAllowed(address(this), redeemer, vars.redeemTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REDEEM_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDEEM_FRESHNESS_CHECK);\n    }\n\n    /*\n     * We calculate the new total supply and redeemer balance, checking for underflow:\n     *  totalSupplyNew = totalSupply - redeemTokens\n     *  accountTokensNew = accountTokens[redeemer] - redeemTokens\n     */\n    (vars.mathErr, vars.totalSupplyNew) = subUInt(totalSupply, vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountTokensNew) = subUInt(accountTokens[redeemer], vars.redeemTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < vars.redeemAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDEEM_TRANSFER_OUT_NOT_POSSIBLE);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, vars.redeemAmount);\n\n    /* We write previously calculated values into storage */\n    totalSupply = vars.totalSupplyNew;\n    accountTokens[redeemer] = vars.accountTokensNew;\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), vars.redeemTokens);\n    emit Redeem(redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, vars.redeemAmount, vars.redeemTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowInternal(uint256 borrowAmount) internal nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n    }\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    return borrowFresh(msg.sender, borrowAmount);\n  }\n\n  struct BorrowLocalVars {\n    MathError mathErr;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n  }\n\n  /**\n   * @notice Users borrow assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrowFresh(address borrower, uint256 borrowAmount) internal returns (uint256) {\n    /* Fail if borrow not allowed */\n    uint256 allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.BORROW_FRESHNESS_CHECK);\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    uint256 cashPrior = getCashPrior();\n\n    if (cashPrior < borrowAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_CASH_NOT_AVAILABLE);\n    }\n\n    BorrowLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowsNew = accountBorrows + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    (vars.mathErr, vars.accountBorrowsNew) = addUInt(vars.accountBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(\n          Error.MATH_ERROR,\n          FailureInfo.BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n          uint256(vars.mathErr)\n        );\n    }\n\n    // Check min borrow for this user for this asset\n    allowed = comptroller.borrowWithinLimits(address(this), vars.accountBorrowsNew);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.BORROW_COMPTROLLER_REJECTION, allowed);\n    }\n\n    (vars.mathErr, vars.totalBorrowsNew) = addUInt(totalBorrows, borrowAmount);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return\n        failOpaque(Error.MATH_ERROR, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.borrowVerify(address(this), borrower, borrowAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowInternal(uint256 repayAmount) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowBehalfInternal(address borrower, uint256 repayAmount)\n    internal\n    nonReentrant(false)\n    returns (uint256, uint256)\n  {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n      return (fail(Error(error), FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  struct RepayBorrowLocalVars {\n    Error err;\n    MathError mathErr;\n    uint256 repayAmount;\n    uint256 borrowerIndex;\n    uint256 accountBorrows;\n    uint256 accountBorrowsNew;\n    uint256 totalBorrowsNew;\n    uint256 actualRepayAmount;\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n   * @param payer the account paying off the borrow\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount the amount of undelrying tokens being returned\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function repayBorrowFresh(\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) internal returns (uint256, uint256) {\n    /* Fail if repayBorrow not allowed */\n    uint256 allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n    }\n\n    RepayBorrowLocalVars memory vars;\n\n    /* We remember the original borrowerIndex for verification purposes */\n    vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return (\n        failOpaque(\n          Error.MATH_ERROR,\n          FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n          uint256(vars.mathErr)\n        ),\n        0\n      );\n    }\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    if (repayAmount == type(uint256).max) {\n      vars.repayAmount = vars.accountBorrows;\n    } else {\n      vars.repayAmount = repayAmount;\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    vars.actualRepayAmount = doTransferIn(payer, vars.repayAmount);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    (vars.mathErr, vars.accountBorrowsNew) = subUInt(vars.accountBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED\");\n\n    (vars.mathErr, vars.totalBorrowsNew) = subUInt(totalBorrows, vars.actualRepayAmount);\n    require(vars.mathErr == MathError.NO_ERROR, \"REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED\");\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = vars.accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = vars.totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, vars.actualRepayAmount, vars.accountBorrowsNew, vars.totalBorrowsNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.repayBorrowVerify(address(this), payer, borrower, vars.actualRepayAmount, vars.borrowerIndex);\n\n    return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowInternal(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal nonReentrant(false) returns (uint256, uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED), 0);\n    }\n\n    error = cTokenCollateral.accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      return (fail(Error(error), FailureInfo.LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED), 0);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    return liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param liquidator The address repaying the borrow and seizing collateral\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @return (uint, uint) An error code (0=success, otherwise a failure, see ErrorReporter.sol), and the actual repayment amount.\n   */\n  function liquidateBorrowFresh(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) internal returns (uint256, uint256) {\n    /* Fail if liquidate not allowed */\n    uint256 allowed = comptroller.liquidateBorrowAllowed(\n      address(this),\n      address(cTokenCollateral),\n      liquidator,\n      borrower,\n      repayAmount\n    );\n    if (allowed != 0) {\n      return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_COMPTROLLER_REJECTION, allowed), 0);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_FRESHNESS_CHECK), 0);\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      return (fail(Error.MARKET_NOT_FRESH, FailureInfo.LIQUIDATE_COLLATERAL_FRESHNESS_CHECK), 0);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return (fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER), 0);\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_ZERO), 0);\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint256).max) {\n      return (fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX), 0);\n    }\n\n    /* Fail if repayBorrow fails */\n    (uint256 repayBorrowError, uint256 actualRepayAmount) = repayBorrowFresh(liquidator, borrower, repayAmount);\n    if (repayBorrowError != uint256(Error.NO_ERROR)) {\n      return (fail(Error(repayBorrowError), FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED), 0);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint256 amountSeizeError, uint256 seizeTokens) = comptroller.liquidateCalculateSeizeTokens(\n      address(this),\n      address(cTokenCollateral),\n      actualRepayAmount\n    );\n    require(amountSeizeError == uint256(Error.NO_ERROR), \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    uint256 seizeError;\n    if (address(cTokenCollateral) == address(this)) {\n      seizeError = seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      seizeError = cTokenCollateral.seize(liquidator, borrower, seizeTokens);\n    }\n\n    /* Revert if seize tokens fails (since we cannot be sure of side effects) */\n    require(seizeError == uint256(Error.NO_ERROR), \"token seizure failed\");\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.liquidateBorrowVerify(address(this), address(cTokenCollateral), liquidator, borrower, actualRepayAmount, seizeTokens);\n\n    return (uint256(Error.NO_ERROR), actualRepayAmount);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Will fail unless called by another cToken during the process of liquidation.\n   *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external override nonReentrant(true) returns (uint256) {\n    return seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n  }\n\n  struct SeizeInternalLocalVars {\n    MathError mathErr;\n    uint256 borrowerTokensNew;\n    uint256 liquidatorTokensNew;\n    uint256 liquidatorSeizeTokens;\n    uint256 protocolSeizeTokens;\n    uint256 protocolSeizeAmount;\n    uint256 exchangeRateMantissa;\n    uint256 totalReservesNew;\n    uint256 totalFuseFeeNew;\n    uint256 totalSupplyNew;\n    uint256 feeSeizeTokens;\n    uint256 feeSeizeAmount;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n   * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n   *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n   * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n   * @param liquidator The account receiving seized collateral\n   * @param borrower The account having collateral seized\n   * @param seizeTokens The number of cTokens to seize\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function seizeInternal(\n    address seizerToken,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) internal returns (uint256) {\n    /* Fail if seize not allowed */\n    uint256 allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      return failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.LIQUIDATE_SEIZE_COMPTROLLER_REJECTION, allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      return fail(Error.INVALID_ACCOUNT_PAIR, FailureInfo.LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER);\n    }\n\n    SeizeInternalLocalVars memory vars;\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    (vars.mathErr, vars.borrowerTokensNew) = subUInt(accountTokens[borrower], seizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    vars.protocolSeizeTokens = mul_(seizeTokens, Exp({ mantissa: protocolSeizeShareMantissa }));\n    vars.feeSeizeTokens = mul_(seizeTokens, Exp({ mantissa: feeSeizeShareMantissa }));\n    vars.liquidatorSeizeTokens = sub_(sub_(seizeTokens, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n\n    (vars.mathErr, vars.exchangeRateMantissa) = exchangeRateStoredInternal();\n    require(vars.mathErr == MathError.NO_ERROR, \"exchange rate math error\");\n\n    vars.protocolSeizeAmount = mul_ScalarTruncate(\n      Exp({ mantissa: vars.exchangeRateMantissa }),\n      vars.protocolSeizeTokens\n    );\n    vars.feeSeizeAmount = mul_ScalarTruncate(Exp({ mantissa: vars.exchangeRateMantissa }), vars.feeSeizeTokens);\n\n    vars.totalReservesNew = add_(totalReserves, vars.protocolSeizeAmount);\n    vars.totalSupplyNew = sub_(sub_(totalSupply, vars.protocolSeizeTokens), vars.feeSeizeTokens);\n    vars.totalFuseFeeNew = add_(totalFuseFees, vars.feeSeizeAmount);\n\n    (vars.mathErr, vars.liquidatorTokensNew) = addUInt(accountTokens[liquidator], vars.liquidatorSeizeTokens);\n    if (vars.mathErr != MathError.NO_ERROR) {\n      return failOpaque(Error.MATH_ERROR, FailureInfo.LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED, uint256(vars.mathErr));\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    totalReserves = vars.totalReservesNew;\n    totalSupply = vars.totalSupplyNew;\n    totalFuseFees = vars.totalFuseFeeNew;\n\n    accountTokens[borrower] = vars.borrowerTokensNew;\n    accountTokens[liquidator] = vars.liquidatorTokensNew;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, vars.liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), vars.protocolSeizeTokens);\n    emit ReservesAdded(address(this), vars.protocolSeizeAmount, vars.totalReservesNew);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.seizeVerify(address(this), seizerToken, liquidator, borrower, seizeTokens);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n   * @notice Sets a new comptroller for the market\n   * @dev Internal function to set a new comptroller\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setComptroller(ComptrollerInterface newComptroller) internal returns (uint256) {\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new admin fee for the protocol using _setAdminFeeFresh\n   * @dev Admin function to accrue interest and set a new admin fee\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setAdminFee(uint256 newAdminFeeMantissa) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee change failed.\n      return fail(Error(error), FailureInfo.SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED);\n    }\n    // _setAdminFeeFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setAdminFeeFresh(newAdminFeeMantissa);\n  }\n\n  /**\n   * @notice Sets a new admin fee for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new admin fee\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setAdminFeeFresh(uint256 newAdminFeeMantissa) internal returns (uint256) {\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_ADMIN_FEE_FRESH_CHECK);\n    }\n\n    // Sanitize newAdminFeeMantissa\n    if (newAdminFeeMantissa == type(uint256).max) newAdminFeeMantissa = adminFeeMantissa;\n\n    // Get latest Fuse fee\n    uint256 newFuseFeeMantissa = getPendingFuseFeeFromAdmin();\n\n    // Check reserveFactorMantissa + newAdminFeeMantissa + newFuseFeeMantissa ≤ reserveFactorPlusFeesMaxMantissa\n    if (add_(add_(reserveFactorMantissa, newAdminFeeMantissa), newFuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_ADMIN_FEE_BOUNDS_CHECK);\n    }\n\n    // If setting admin fee\n    if (adminFeeMantissa != newAdminFeeMantissa) {\n      // Check caller is admin\n      if (!hasAdminRights()) {\n        return fail(Error.UNAUTHORIZED, FailureInfo.SET_ADMIN_FEE_ADMIN_CHECK);\n      }\n\n      // Set admin fee\n      uint256 oldAdminFeeMantissa = adminFeeMantissa;\n      adminFeeMantissa = newAdminFeeMantissa;\n\n      // Emit event\n      emit NewAdminFee(oldAdminFeeMantissa, newAdminFeeMantissa);\n    }\n\n    // If setting Fuse fee\n    if (fuseFeeMantissa != newFuseFeeMantissa) {\n      // Set Fuse fee\n      uint256 oldFuseFeeMantissa = fuseFeeMantissa;\n      fuseFeeMantissa = newFuseFeeMantissa;\n\n      // Emit event\n      emit NewFuseFee(oldFuseFeeMantissa, newFuseFeeMantissa);\n    }\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n   * @dev Admin function to accrue interest and set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external override nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reserve factor change failed.\n      return fail(Error(error), FailureInfo.SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED);\n    }\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n   * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n   * @dev Admin function to set a new reserve factor\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal returns (uint256) {\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_RESERVE_FACTOR_ADMIN_CHECK);\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_RESERVE_FACTOR_FRESH_CHECK);\n    }\n\n    // Check newReserveFactor ≤ maxReserveFactor\n    if (add_(add_(newReserveFactorMantissa, adminFeeMantissa), fuseFeeMantissa) > reserveFactorPlusFeesMaxMantissa) {\n      return fail(Error.BAD_INPUT, FailureInfo.SET_RESERVE_FACTOR_BOUNDS_CHECK);\n    }\n\n    uint256 oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReserves(uint256 reduceAmount) external override nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted reduce reserves failed.\n      return fail(Error(error), FailureInfo.REDUCE_RESERVES_ACCRUE_INTEREST_FAILED);\n    }\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param reduceAmount Amount of reduction to reserves\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _reduceReservesFresh(uint256 reduceAmount) internal returns (uint256) {\n    // totalReserves - reduceAmount\n    uint256 totalReservesNew;\n\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.REDUCE_RESERVES_ADMIN_CHECK);\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.REDUCE_RESERVES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.REDUCE_RESERVES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check reduceAmount ≤ reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      return fail(Error.BAD_INPUT, FailureInfo.REDUCE_RESERVES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked reduceAmount <= totalReserves above, so this should never revert.\n    totalReservesNew = sub_(totalReserves, reduceAmount);\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(msg.sender, reduceAmount);\n\n    emit ReservesReduced(msg.sender, reduceAmount, totalReservesNew);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces Fuse fees by transferring to Fuse\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawFuseFees(uint256 withdrawAmount) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted Fuse fee withdrawal failed.\n      return fail(Error(error), FailureInfo.WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED);\n    }\n    // _withdrawFuseFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _withdrawFuseFeesFresh(withdrawAmount);\n  }\n\n  /**\n   * @notice Reduces Fuse fees by transferring to Fuse\n   * @dev Requires fresh interest accrual\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawFuseFeesFresh(uint256 withdrawAmount) internal returns (uint256) {\n    // totalFuseFees - reduceAmount\n    uint256 totalFuseFeesNew;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_FUSE_FEES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check withdrawAmount ≤ fuseFees[n] (totalFuseFees)\n    if (withdrawAmount > totalFuseFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_FUSE_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked withdrawAmount <= totalFuseFees above, so this should never revert.\n    totalFuseFeesNew = sub_(totalFuseFees, withdrawAmount);\n\n    // Store fuseFees[n+1] = fuseFees[n] - withdrawAmount\n    totalFuseFees = totalFuseFeesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(address(fuseAdmin), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accrues interest and reduces admin fees by transferring to admin\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawAdminFees(uint256 withdrawAmount) external nonReentrant(false) returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted admin fee withdrawal failed.\n      return fail(Error(error), FailureInfo.WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED);\n    }\n    // _withdrawAdminFeesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _withdrawAdminFeesFresh(withdrawAmount);\n  }\n\n  /**\n   * @notice Reduces admin fees by transferring to admin\n   * @dev Requires fresh interest accrual\n   * @param withdrawAmount Amount of fees to withdraw\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _withdrawAdminFeesFresh(uint256 withdrawAmount) internal returns (uint256) {\n    // totalAdminFees - reduceAmount\n    uint256 totalAdminFeesNew;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.WITHDRAW_ADMIN_FEES_FRESH_CHECK);\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < withdrawAmount) {\n      return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE);\n    }\n\n    // Check withdrawAmount ≤ adminFees[n] (totalAdminFees)\n    if (withdrawAmount > totalAdminFees) {\n      return fail(Error.BAD_INPUT, FailureInfo.WITHDRAW_ADMIN_FEES_VALIDATION);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    // We checked withdrawAmount <= totalAdminFees above, so this should never revert.\n    totalAdminFeesNew = sub_(totalAdminFees, withdrawAmount);\n\n    // Store adminFees[n+1] = adminFees[n] - withdrawAmount\n    totalAdminFees = totalAdminFeesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(address(uint160(UnitrollerAdminStorage(address(comptroller)).admin())), withdrawAmount);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n   * @dev Admin function to accrue interest and update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public override returns (uint256) {\n    uint256 error = accrueInterest();\n    if (error != uint256(Error.NO_ERROR)) {\n      // accrueInterest emits logs on errors, but on top of that we want to log the fact that an attempted change of interest rate model failed\n      return fail(Error(error), FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED);\n    }\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n   * @dev Admin function to update the interest rate model\n   * @param newInterestRateModel the new interest rate model to use\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint256) {\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_INTEREST_RATE_MODEL_OWNER_CHECK);\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      return fail(Error.MARKET_NOT_FRESH, FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK);\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    // Attempt to reset interest checkpoints on old IRM\n    if (address(oldInterestRateModel) != address(0))\n      address(oldInterestRateModel).call(abi.encodeWithSignature(\"resetInterestCheckpoints()\"));\n\n    // Attempt to add first interest checkpoint on new IRM\n    address(newInterestRateModel).call(abi.encodeWithSignature(\"checkpointInterest()\"));\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice updates the cToken ERC20 name and symbol\n   * @dev Admin function to update the cToken ERC20 name and symbol\n   * @param _name the new ERC20 token name to use\n   * @param _symbol the new ERC20 token symbol to use\n   */\n  function _setNameAndSymbol(string calldata _name, string calldata _symbol) external {\n    // Check caller is admin\n    require(hasAdminRights(), \"caller not admin\");\n\n    // Set ERC20 name and symbol\n    name = _name;\n    symbol = _symbol;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying owned by this contract\n   */\n  function getCashPrior() internal view virtual returns (uint256) {\n    return 0;\n  }\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n   *  This may revert due to insufficient balance or insufficient allowance.\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual returns (uint256) {\n    return 1;\n  }\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure tather than reverting.\n   *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n   *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n   */\n  function doTransferOut(address to, uint256 amount) internal virtual {}\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   */\n  modifier nonReentrant(bool localOnly) {\n    _beforeNonReentrant(localOnly);\n    _;\n    _afterNonReentrant(localOnly);\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 1500 bytes of that valuable 24 KB limit.\n   */\n  function _beforeNonReentrant(bool localOnly) private {\n    require(_notEntered, \"re-entered\");\n    if (!localOnly) comptroller._beforeNonReentrant();\n    _notEntered = false;\n  }\n\n  /**\n   * @dev Split off from `nonReentrant` to keep contract below the 24 KB size limit.\n   * Saves space because function modifier code is \"inlined\" into every function with the modifier).\n   * In this specific case, the optimization saves around 150 bytes of that valuable 24 KB limit.\n   */\n  function _afterNonReentrant(bool localOnly) private {\n    _notEntered = true; // get a gas-refund post-Istanbul\n    if (!localOnly) comptroller._afterNonReentrant();\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.call(data);\n\n    if (!success) {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n\n    return returndata;\n  }\n}\n"
    },
    "contracts/compound/CErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../oracles/default/KeydonixUniswapTwapPriceOracle.sol\";\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @dev This contract should not to be deployed on its own; instead, deploy `CErc20Delegator` (proxy contract) and `CErc20Delegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   */\n  function initialize(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    // CToken initialize does the bulk of the work\n    uint256 initialExchangeRateMantissa_ = 0.2e18;\n    uint8 decimals_ = EIP20Interface(underlying_).decimals();\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      reserveFactorMantissa_,\n      adminFeeMantissa_\n    );\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param mintAmount The amount of the underlying asset to supply\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function mint(uint256 mintAmount) external override returns (uint256) {\n    (uint256 err, ) = mintInternal(mintAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external override returns (uint256) {\n    return redeemInternal(redeemTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external override returns (uint256) {\n    return redeemUnderlyingInternal(redeemAmount);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external override returns (uint256) {\n    return borrowInternal(borrowAmount);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrow(uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowInternal(repayAmount);\n    return err;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @param borrower the account with the debt being payed off\n   * @param repayAmount The amount to repay\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external override returns (uint256) {\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, repayAmount);\n    return err;\n  }\n\n  function liquidateBorrowWithPriceProof(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral,\n    UniswapOracle.ProofData calldata repaidProofData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external returns (uint256) {\n    ICToken repaidAsInterface = ICToken(address(this));\n    ICToken collateralAsInterface = ICToken(address(cTokenCollateral));\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(repaidAsInterface, repaidProofData);\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(collateralAsInterface, collateralProofData);\n\n    return liquidateBorrow(borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param repayAmount The amount of the underlying borrowed asset to repay\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) public override returns (uint256) {\n    (uint256 err, ) = liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return err;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view virtual override returns (uint256) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n   *      This will revert due to insufficient balance or insufficient allowance.\n   *      This function returns the actual amount received,\n   *      which may be less than `amount` if there is a fee attached to the transfer.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferIn(address from, uint256 amount) internal virtual override returns (uint256) {\n    uint256 balanceBefore = EIP20Interface(underlying).balanceOf(address(this));\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transferFrom.selector, from, address(this), amount),\n      \"TOKEN_TRANSFER_IN_FAILED\"\n    );\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = EIP20Interface(underlying).balanceOf(address(this));\n    require(balanceAfter >= balanceBefore, \"TOKEN_TRANSFER_IN_OVERFLOW\");\n    return balanceAfter - balanceBefore; // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n   *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n   *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n   *      it is >= amount, this should not revert in normal conditions.\n   *\n   *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n   *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n   */\n  function doTransferOut(address to, uint256 amount) internal virtual override {\n    _callOptionalReturn(\n      abi.encodeWithSelector(EIP20NonStandardInterface(underlying).transfer.selector, to, amount),\n      \"TOKEN_TRANSFER_OUT_FAILED\"\n    );\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   * @param errorMessage The revert string to return on failure.\n   */\n  function _callOptionalReturn(bytes memory data, string memory errorMessage) internal {\n    bytes memory returndata = _functionCall(underlying, data, errorMessage);\n    if (returndata.length > 0) require(abi.decode(returndata, (bool)), errorMessage);\n  }\n\n  /**\n   * @notice Admin call to delegate the votes of the COMP-like underlying\n   * @param compLikeDelegatee The address to delegate votes to\n   * @dev CTokens whose underlying are not CompLike should revert here\n   */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(hasAdminRights(), \"only the admin may set the comp-like delegate\");\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}\n"
    },
    "contracts/compound/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_ENTERED, // no longer possible\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY,\n    SUPPLIER_NOT_WHITELISTED,\n    BORROW_BELOW_MIN,\n    SUPPLY_ABOVE_MAX,\n    NONZERO_TOTAL_SUPPLY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    ADD_REWARDS_DISTRIBUTOR_OWNER_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    TOGGLE_AUTO_IMPLEMENTATIONS_ENABLED_OWNER_CHECK,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SET_WHITELIST_ENFORCEMENT_OWNER_CHECK,\n    SET_WHITELIST_STATUS_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK,\n    UNSUPPORT_MARKET_OWNER_CHECK,\n    UNSUPPORT_MARKET_DOES_NOT_EXIST,\n    UNSUPPORT_MARKET_IN_USE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return uint256(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    BAD_INPUT,\n    COMPTROLLER_REJECTION,\n    COMPTROLLER_CALCULATION_ERROR,\n    INTEREST_RATE_MODEL_ERROR,\n    INVALID_ACCOUNT_PAIR,\n    INVALID_CLOSE_AMOUNT_REQUESTED,\n    INVALID_COLLATERAL_FACTOR,\n    MATH_ERROR,\n    MARKET_NOT_FRESH,\n    MARKET_NOT_LISTED,\n    TOKEN_INSUFFICIENT_ALLOWANCE,\n    TOKEN_INSUFFICIENT_BALANCE,\n    TOKEN_INSUFFICIENT_CASH,\n    TOKEN_TRANSFER_IN_FAILED,\n    TOKEN_TRANSFER_OUT_FAILED,\n    UTILIZATION_ABOVE_MAX\n  }\n\n  /*\n   * Note: FailureInfo (but not Error) is kept in alphabetical order\n   *       This is because FailureInfo grows significantly faster, and\n   *       the order of Error has some meaning, while the order of FailureInfo\n   *       is entirely arbitrary.\n   */\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n    ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_FUSE_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_NEW_TOTAL_ADMIN_FEES_CALCULATION_FAILED,\n    ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n    BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    BORROW_ACCRUE_INTEREST_FAILED,\n    BORROW_CASH_NOT_AVAILABLE,\n    BORROW_FRESHNESS_CHECK,\n    BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    BORROW_MARKET_NOT_LISTED,\n    BORROW_COMPTROLLER_REJECTION,\n    LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n    LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n    LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n    LIQUIDATE_COMPTROLLER_REJECTION,\n    LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n    LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n    LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n    LIQUIDATE_FRESHNESS_CHECK,\n    LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n    LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n    LIQUIDATE_SEIZE_COMPTROLLER_REJECTION,\n    LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n    LIQUIDATE_SEIZE_TOO_MUCH,\n    MINT_ACCRUE_INTEREST_FAILED,\n    MINT_COMPTROLLER_REJECTION,\n    MINT_EXCHANGE_CALCULATION_FAILED,\n    MINT_EXCHANGE_RATE_READ_FAILED,\n    MINT_FRESHNESS_CHECK,\n    MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    MINT_TRANSFER_IN_FAILED,\n    MINT_TRANSFER_IN_NOT_POSSIBLE,\n    NEW_UTILIZATION_RATE_ABOVE_MAX,\n    REDEEM_ACCRUE_INTEREST_FAILED,\n    REDEEM_COMPTROLLER_REJECTION,\n    REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n    REDEEM_EXCHANGE_RATE_READ_FAILED,\n    REDEEM_FRESHNESS_CHECK,\n    REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n    REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n    REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n    WITHDRAW_FUSE_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_FUSE_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_FUSE_FEES_FRESH_CHECK,\n    WITHDRAW_FUSE_FEES_VALIDATION,\n    WITHDRAW_ADMIN_FEES_ACCRUE_INTEREST_FAILED,\n    WITHDRAW_ADMIN_FEES_CASH_NOT_AVAILABLE,\n    WITHDRAW_ADMIN_FEES_FRESH_CHECK,\n    WITHDRAW_ADMIN_FEES_VALIDATION,\n    REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n    REDUCE_RESERVES_ADMIN_CHECK,\n    REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n    REDUCE_RESERVES_FRESH_CHECK,\n    REDUCE_RESERVES_VALIDATION,\n    REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n    REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_COMPTROLLER_REJECTION,\n    REPAY_BORROW_FRESHNESS_CHECK,\n    REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n    REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COMPTROLLER_OWNER_CHECK,\n    SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n    SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n    SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_ORACLE_MARKET_NOT_LISTED,\n    TOGGLE_ADMIN_RIGHTS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_ADMIN_FEE_ACCRUE_INTEREST_FAILED,\n    SET_ADMIN_FEE_ADMIN_CHECK,\n    SET_ADMIN_FEE_FRESH_CHECK,\n    SET_ADMIN_FEE_BOUNDS_CHECK,\n    SET_FUSE_FEE_ACCRUE_INTEREST_FAILED,\n    SET_FUSE_FEE_FRESH_CHECK,\n    SET_FUSE_FEE_BOUNDS_CHECK,\n    SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n    SET_RESERVE_FACTOR_ADMIN_CHECK,\n    SET_RESERVE_FACTOR_FRESH_CHECK,\n    SET_RESERVE_FACTOR_BOUNDS_CHECK,\n    TRANSFER_COMPTROLLER_REJECTION,\n    TRANSFER_NOT_ALLOWED,\n    TRANSFER_NOT_ENOUGH,\n    TRANSFER_TOO_MUCH,\n    ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n    ADD_RESERVES_FRESH_CHECK,\n    ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n  }\n\n  /**\n   * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n   * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n   **/\n  event Failure(uint256 error, uint256 info, uint256 detail);\n\n  /**\n   * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n   */\n  function fail(Error err, FailureInfo info) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), 0);\n\n    return uint256(err);\n  }\n\n  /**\n   * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n   */\n  function failOpaque(\n    Error err,\n    FailureInfo info,\n    uint256 opaqueError\n  ) internal returns (uint256) {\n    emit Failure(uint256(err), uint256(info), opaqueError);\n\n    return err == Error.COMPTROLLER_REJECTION ? 1000 + opaqueError : uint256(err);\n  }\n}\n"
    },
    "contracts/compound/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(CToken cToken) external view virtual returns (uint256);\n}\n"
    },
    "contracts/compound/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\nabstract contract ComptrollerInterface {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n  function exitMarket(address cToken) external virtual returns (uint256);\n\n  function exitMarketWithPriceProof(\n    address cToken,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external virtual returns (uint256);\n\n  function mintWithinLimits(\n    address cToken,\n    uint256 exchangeRateMantissa,\n    uint256 accountTokens,\n    uint256 mintAmount\n  ) external virtual returns (uint256);\n\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 mintAmount,\n    uint256 mintTokens\n  ) external virtual;\n\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external virtual returns (uint256);\n\n  function redeemAllowedWithPriceProof(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external virtual;\n\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external virtual returns (uint256);\n\n  function borrowAllowedWithPriceProof(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount,\n    UniswapOracle.ProofData calldata proofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  function borrowWithinLimits(address cToken, uint256 accountBorrowsNew) external virtual returns (uint256);\n\n  function borrowWithinLimitsWithPriceProof(\n    address cToken,\n    uint256 accountBorrowsNew,\n    UniswapOracle.ProofData calldata proofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external virtual;\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external virtual returns (uint256);\n\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount,\n    uint256 borrowerIndex\n  ) external virtual;\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external virtual returns (uint256);\n\n  function liquidateBorrowAllowedWithPriceProof(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    UniswapOracle.ProofData calldata borrowedProofData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    uint256 seizeTokens\n  ) external virtual;\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual returns (uint256);\n\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual;\n\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external virtual returns (uint256);\n\n  function transferAllowedWithPriceProof(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens,\n    UniswapOracle.ProofData[] calldata proofData,\n    address _keydonixPriceOracle\n  ) external virtual returns (uint256);\n\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external virtual;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 repayAmount\n  ) external view virtual returns (uint256, uint256);\n\n  /*** Pool-Wide/Cross-Asset Reentrancy Prevention ***/\n\n  function _beforeNonReentrant() external virtual;\n\n  function _afterNonReentrant() external virtual;\n}\n"
    },
    "contracts/compound/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n  /*\n   * Administrator for Fuse\n   */\n  IFuseFeeDistributor internal constant fuseAdmin =\n    IFuseFeeDistributor(payable(0x0B1638cE0c7Dc434b2Ad41fFBc016690A24933d2));\n\n  /**\n   * @notice Administrator for this contract\n   */\n  address public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n   */\n  address public pendingAdmin;\n\n  /**\n   * @notice Whether or not the Fuse admin has admin rights\n   */\n  bool public fuseAdminHasRights = true;\n\n  /**\n   * @notice Whether or not the admin has admin rights\n   */\n  bool public adminHasRights = true;\n\n  /**\n   * @notice Returns a boolean indicating if the sender has admin rights\n   */\n  function hasAdminRights() internal view returns (bool) {\n    return (msg.sender == admin && adminHasRights) || (msg.sender == address(fuseAdmin) && fuseAdminHasRights);\n  }\n\n  /**\n   * @notice Active brains of Unitroller\n   */\n  address public comptrollerImplementation;\n\n  /**\n   * @notice Pending brains of Unitroller\n   */\n  address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n  /**\n   * @notice Oracle which gives the price of any given asset\n   */\n  PriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n   */\n  uint256 public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n   */\n  uint256 public liquidationIncentiveMantissa;\n\n  /*\n   * UNUSED AFTER UPGRADE: Max number of assets a single account can participate in (borrow or use as collateral)\n   */\n  uint256 internal maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n   */\n  mapping(address => CToken[]) public accountAssets;\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n    // Multiplier representing the most one can borrow against their collateral in this market.\n    // For instance, 0.9 to allow borrowing 90% of collateral value.\n    // Must be between 0 and 1, and stored as a mantissa.\n    uint256 collateralFactorMantissa;\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n   * @dev Used e.g. to determine if a market is supported\n   */\n  mapping(address => Market) public markets;\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /**\n   * @dev Maps borrowers to booleans indicating if they have entered any markets\n   */\n  mapping(address => bool) internal borrowers;\n\n  /// @notice A list of all borrowers who have entered markets\n  address[] public allBorrowers;\n\n  // Indexes of borrower account addresses in the `allBorrowers` array\n  mapping(address => uint256) internal borrowerIndexes;\n\n  /**\n   * @dev Maps suppliers to booleans indicating if they have ever supplied to any markets\n   */\n  mapping(address => bool) public suppliers;\n\n  /// @notice All cTokens addresses mapped by their underlying token addresses\n  mapping(address => CToken) public cTokensByUnderlying;\n\n  /// @notice Whether or not the supplier whitelist is enforced\n  bool public enforceWhitelist;\n\n  /// @notice Maps addresses to booleans indicating if they are allowed to supply assets (i.e., mint cTokens)\n  mapping(address => bool) public whitelist;\n\n  /// @notice An array of all whitelisted accounts\n  address[] public whitelistArray;\n\n  // Indexes of account addresses in the `whitelistArray` array\n  mapping(address => uint256) internal whitelistIndexes;\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n   *  Actions which allow users to remove their own assets cannot be paused.\n   *  Liquidation / seizing / transfer can only be paused globally, not by market.\n   */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  /**\n   * @dev Whether or not the implementation should be auto-upgraded.\n   */\n  bool public autoImplementation;\n\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  address public borrowCapGuardian;\n\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  mapping(address => uint256) public borrowCaps;\n\n  /// @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n  mapping(address => uint256) public supplyCaps;\n\n  /// @notice RewardsDistributor contracts to notify of flywheel changes.\n  address[] public rewardsDistributors;\n\n  /// @dev Guard variable for pool-wide/cross-asset re-entrancy checks\n  bool internal _notEntered;\n\n  /// @dev Whether or not _notEntered has been initialized\n  bool internal _notEnteredInitialized;\n}\n"
    },
    "contracts/compound/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n\n/**\n * @title Unitroller\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is changed\n   */\n  event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n  /**\n   * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Event emitted when the Fuse admin rights are changed\n   */\n  event FuseAdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Event emitted when the admin rights are changed\n   */\n  event AdminRightsToggled(bool hasRights);\n\n  /**\n   * @notice Emitted when pendingAdmin is changed\n   */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  constructor() {\n    // Set admin to caller\n    admin = msg.sender;\n  }\n\n  /*** Admin Functions ***/\n\n  function _setPendingImplementation(address newPendingImplementation) public returns (uint256) {\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n    }\n    if (!fuseAdmin.comptrollerImplementationWhitelist(comptrollerImplementation, newPendingImplementation)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_CONTRACT_CHECK);\n    }\n    address oldPendingImplementation = pendingComptrollerImplementation;\n    pendingComptrollerImplementation = newPendingImplementation;\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n   * @dev Admin function for new implementation to accept it's role as implementation\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptImplementation() public returns (uint256) {\n    // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n    if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldImplementation = comptrollerImplementation;\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    comptrollerImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = address(0);\n\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles Fuse admin rights.\n   * @param hasRights Boolean indicating if the Fuse admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleFuseAdminRights(bool hasRights) external returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (fuseAdminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    // Set fuseAdminHasRights\n    fuseAdminHasRights = hasRights;\n\n    // Emit FuseAdminRightsToggled()\n    emit FuseAdminRightsToggled(fuseAdminHasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Toggles admin rights.\n   * @param hasRights Boolean indicating if the admin is to have rights.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _toggleAdminRights(bool hasRights) external returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.TOGGLE_ADMIN_RIGHTS_OWNER_CHECK);\n    }\n\n    // Check that rights have not already been set to the desired value\n    if (adminHasRights == hasRights) return uint256(Error.NO_ERROR);\n\n    // Set adminHasRights\n    adminHasRights = hasRights;\n\n    // Emit AdminRightsToggled()\n    emit AdminRightsToggled(hasRights);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint256) {\n    // Check caller = admin\n    if (!hasAdminRights()) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function _acceptAdmin() public returns (uint256) {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint256(Error.NO_ERROR);\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  fallback() external payable {\n    // Check for automatic implementation\n    if (msg.sender != address(this)) {\n      (bool callSuccess, bytes memory data) = address(this).staticcall(abi.encodeWithSignature(\"autoImplementation()\"));\n      bool autoImplementation;\n      if (callSuccess) (autoImplementation) = abi.decode(data, (bool));\n\n      if (autoImplementation) {\n        address latestComptrollerImplementation = fuseAdmin.latestComptrollerImplementation(comptrollerImplementation);\n\n        if (comptrollerImplementation != latestComptrollerImplementation) {\n          address oldImplementation = comptrollerImplementation; // Save current value for inclusion in log\n          comptrollerImplementation = latestComptrollerImplementation;\n          emit NewImplementation(oldImplementation, comptrollerImplementation);\n        }\n      }\n    }\n\n    // delegate all other functions to current implementation\n    (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/compound/RewardsDistributorDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"./Comptroller.sol\";\nimport \"./RewardsDistributorStorage.sol\";\n\n/**\n * @title RewardsDistributorDelegate (COMP distribution logic extracted from `Comptroller`)\n * @author Compound\n */\ncontract RewardsDistributorDelegate is RewardsDistributorDelegateStorageV1, ExponentialNoError {\n  /// @dev Notice that this contract is a RewardsDistributor\n  bool public constant isRewardsDistributor = true;\n\n  /// @notice Emitted when pendingAdmin is changed\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /// @notice Emitted when pendingAdmin is accepted, which means admin is updated\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /// @notice Emitted when a new COMP speed is calculated for a market\n  event CompSupplySpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n  /// @notice Emitted when a new COMP speed is calculated for a market\n  event CompBorrowSpeedUpdated(CToken indexed cToken, uint256 newSpeed);\n\n  /// @notice Emitted when a new COMP speed is set for a contributor\n  event ContributorCompSpeedUpdated(address indexed contributor, uint256 newSpeed);\n\n  /// @notice Emitted when COMP is distributed to a supplier\n  event DistributedSupplierComp(\n    CToken indexed cToken,\n    address indexed supplier,\n    uint256 compDelta,\n    uint256 compSupplyIndex\n  );\n\n  /// @notice Emitted when COMP is distributed to a borrower\n  event DistributedBorrowerComp(\n    CToken indexed cToken,\n    address indexed borrower,\n    uint256 compDelta,\n    uint256 compBorrowIndex\n  );\n\n  /// @notice Emitted when COMP is granted by admin\n  event CompGranted(address recipient, uint256 amount);\n\n  /// @notice The initial COMP index for a market\n  uint224 public constant compInitialIndex = 1e36;\n\n  /// @dev Intitializer to set admin to caller and set reward token\n  function initialize(address _rewardToken) external {\n    require(msg.sender == admin, \"Only admin can initialize.\");\n    require(rewardToken == address(0), \"Already initialized.\");\n    require(_rewardToken != address(0), \"Cannot initialize reward token to the zero address.\");\n    rewardToken = _rewardToken;\n  }\n\n  /*** Set Admin ***/\n\n  /**\n   * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n   * @param newPendingAdmin New pending admin.\n   */\n  function _setPendingAdmin(address newPendingAdmin) external {\n    // Check caller = admin\n    require(msg.sender == admin, \"RewardsDistributor:_setPendingAdmin: admin only\");\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n  }\n\n  /**\n   * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n   * @dev Admin function for pending admin to accept role and update admin\n   */\n  function _acceptAdmin() external {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    require(\n      msg.sender == pendingAdmin && msg.sender != address(0),\n      \"RewardsDistributor:_acceptAdmin: pending admin only\"\n    );\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n  }\n\n  /*** Comp Distribution ***/\n\n  /**\n   * @notice Check the cToken before adding\n   * @param cToken The market to add\n   */\n  function checkCToken(CToken cToken) internal view {\n    // Make sure cToken is listed\n    Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n    (bool isListed, ) = comptroller.markets(address(cToken));\n    require(isListed == true, \"comp market is not listed\");\n\n    // Make sure distributor is added\n    bool distributorAdded = false;\n    address[] memory distributors = comptroller.getRewardsDistributors();\n    for (uint256 i = 0; i < distributors.length; i++) if (distributors[i] == address(this)) distributorAdded = true;\n    require(distributorAdded == true, \"distributor not added\");\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function setCompSupplySpeedInternal(CToken cToken, uint256 compSpeed) internal {\n    uint256 currentCompSpeed = compSupplySpeeds[address(cToken)];\n    if (currentCompSpeed != 0) {\n      // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n      updateCompSupplyIndex(address(cToken));\n    } else if (compSpeed != 0) {\n      // Make sure cToken is listed and distributor is added\n      checkCToken(cToken);\n\n      // Add the COMP market\n      if (compSupplyState[address(cToken)].index == 0) {\n        compSupplyState[address(cToken)] = CompMarketState({\n          index: compInitialIndex,\n          block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n\n        // Add to allMarkets array if not already there\n        if (compBorrowState[address(cToken)].index == 0) {\n          allMarkets.push(cToken);\n        }\n      } else {\n        // Update block number to ensure extra interest is not accrued during the prior period\n        compSupplyState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n      }\n    }\n\n    if (currentCompSpeed != compSpeed) {\n      compSupplySpeeds[address(cToken)] = compSpeed;\n      emit CompSupplySpeedUpdated(cToken, compSpeed);\n    }\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function setCompBorrowSpeedInternal(CToken cToken, uint256 compSpeed) internal {\n    uint256 currentCompSpeed = compBorrowSpeeds[address(cToken)];\n    if (currentCompSpeed != 0) {\n      // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n      Exp memory borrowIndex = Exp({ mantissa: cToken.borrowIndex() });\n      updateCompBorrowIndex(address(cToken), borrowIndex);\n    } else if (compSpeed != 0) {\n      // Make sure cToken is listed and distributor is added\n      checkCToken(cToken);\n\n      // Add the COMP market\n      if (compBorrowState[address(cToken)].index == 0) {\n        compBorrowState[address(cToken)] = CompMarketState({\n          index: compInitialIndex,\n          block: safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n\n        // Add to allMarkets array if not already there\n        if (compSupplyState[address(cToken)].index == 0) {\n          allMarkets.push(cToken);\n        }\n      } else {\n        // Update block number to ensure extra interest is not accrued during the prior period\n        compBorrowState[address(cToken)].block = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n      }\n    }\n\n    if (currentCompSpeed != compSpeed) {\n      compBorrowSpeeds[address(cToken)] = compSpeed;\n      emit CompBorrowSpeedUpdated(cToken, compSpeed);\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the supply index\n   * @param cToken The market whose supply index to update\n   */\n  function updateCompSupplyIndex(address cToken) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    uint256 supplySpeed = compSupplySpeeds[cToken];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, uint256(supplyState.block));\n    if (deltaBlocks > 0 && supplySpeed > 0) {\n      uint256 supplyTokens = CToken(cToken).totalSupply();\n      uint256 compAccrued_ = mul_(deltaBlocks, supplySpeed);\n      Double memory ratio = supplyTokens > 0 ? fraction(compAccrued_, supplyTokens) : Double({ mantissa: 0 });\n      Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n      compSupplyState[cToken] = CompMarketState({\n        index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n        block: safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0 && supplyState.index > 0) {\n      supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the borrow index\n   * @param cToken The market whose borrow index to update\n   */\n  function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    uint256 borrowSpeed = compBorrowSpeeds[cToken];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, uint256(borrowState.block));\n    if (deltaBlocks > 0 && borrowSpeed > 0) {\n      uint256 borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n      uint256 compAccrued_ = mul_(deltaBlocks, borrowSpeed);\n      Double memory ratio = borrowAmount > 0 ? fraction(compAccrued_, borrowAmount) : Double({ mantissa: 0 });\n      Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\n      compBorrowState[cToken] = CompMarketState({\n        index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n        block: safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0 && borrowState.index > 0) {\n      borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n   * @param cToken The market in which the supplier is interacting\n   * @param supplier The address of the supplier to distribute COMP to\n   */\n  function distributeSupplierComp(address cToken, address supplier) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    Double memory supplyIndex = Double({ mantissa: supplyState.index });\n    Double memory supplierIndex = Double({ mantissa: compSupplierIndex[cToken][supplier] });\n    compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n    if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n      supplierIndex.mantissa = compInitialIndex;\n    }\n\n    Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n    uint256 supplierTokens = CToken(cToken).balanceOf(supplier);\n    uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n    uint256 supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n    compAccrued[supplier] = supplierAccrued;\n    emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n   * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n   * @param cToken The market in which the borrower is interacting\n   * @param borrower The address of the borrower to distribute COMP to\n   */\n  function distributeBorrowerComp(\n    address cToken,\n    address borrower,\n    Exp memory marketBorrowIndex\n  ) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    Double memory borrowIndex = Double({ mantissa: borrowState.index });\n    Double memory borrowerIndex = Double({ mantissa: compBorrowerIndex[cToken][borrower] });\n    compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n    if (borrowerIndex.mantissa > 0) {\n      Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n      uint256 borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n      uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\n      uint256 borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n      compAccrued[borrower] = borrowerAccrued;\n      emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, supplier);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) external {\n    if (compBorrowState[cToken].index > 0) {\n      Exp memory borrowIndex = Exp({ mantissa: CToken(cToken).borrowIndex() });\n      updateCompBorrowIndex(cToken, borrowIndex);\n      distributeBorrowerComp(cToken, borrower, borrowIndex);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(\n    address cToken,\n    address src,\n    address dst\n  ) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, src);\n      distributeSupplierComp(cToken, dst);\n    }\n  }\n\n  /**\n   * @notice Calculate additional accrued COMP for a contributor since last accrual\n   * @param contributor The address to calculate contributor rewards for\n   */\n  function updateContributorRewards(address contributor) public {\n    uint256 compSpeed = compContributorSpeeds[contributor];\n    uint256 blockNumber = getBlockNumber();\n    uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n    if (deltaBlocks > 0 && compSpeed > 0) {\n      uint256 newAccrued = mul_(deltaBlocks, compSpeed);\n      uint256 contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n      compAccrued[contributor] = contributorAccrued;\n      lastContributorBlock[contributor] = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n   * @param holder The address to claim COMP for\n   */\n  function claimRewards(address holder) public {\n    return claimRewards(holder, allMarkets);\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n   * @param holder The address to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   */\n  function claimRewards(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimRewards(holders, cTokens, true, true);\n  }\n\n  /**\n   * @notice Claim all comp accrued by the holders\n   * @param holders The addresses to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   * @param borrowers Whether or not to claim COMP earned by borrowing\n   * @param suppliers Whether or not to claim COMP earned by supplying\n   */\n  function claimRewards(\n    address[] memory holders,\n    CToken[] memory cTokens,\n    bool borrowers,\n    bool suppliers\n  ) public {\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      CToken cToken = cTokens[i];\n      if (borrowers == true && compBorrowState[address(cToken)].index > 0) {\n        Exp memory borrowIndex = Exp({ mantissa: cToken.borrowIndex() });\n        updateCompBorrowIndex(address(cToken), borrowIndex);\n        for (uint256 j = 0; j < holders.length; j++) {\n          distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n        }\n      }\n      if (suppliers == true && compSupplyState[address(cToken)].index > 0) {\n        updateCompSupplyIndex(address(cToken));\n        for (uint256 j = 0; j < holders.length; j++) {\n          distributeSupplierComp(address(cToken), holders[j]);\n        }\n      }\n    }\n    for (uint256 j = 0; j < holders.length; j++) {\n      compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n    }\n  }\n\n  /**\n   * @notice Transfer COMP to the user\n   * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n   * @param user The address of the user to transfer COMP to\n   * @param amount The amount of COMP to (possibly) transfer\n   * @return The amount of COMP which was NOT transferred to the user\n   */\n  function grantCompInternal(address user, uint256 amount) internal returns (uint256) {\n    EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n    uint256 compRemaining = comp.balanceOf(address(this));\n    if (amount > 0 && amount <= compRemaining) {\n      comp.transfer(user, amount);\n      return 0;\n    }\n    return amount;\n  }\n\n  /*** Comp Distribution Admin ***/\n\n  /**\n   * @notice Transfer COMP to the recipient\n   * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n   * @param recipient The address of the recipient to transfer COMP to\n   * @param amount The amount of COMP to (possibly) transfer\n   */\n  function _grantComp(address recipient, uint256 amount) public {\n    require(msg.sender == admin, \"only admin can grant comp\");\n    uint256 amountLeft = grantCompInternal(recipient, amount);\n    require(amountLeft == 0, \"insufficient comp for grant\");\n    emit CompGranted(recipient, amount);\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function _setCompSupplySpeed(CToken cToken, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n    setCompSupplySpeedInternal(cToken, compSpeed);\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n   * @param cToken The market whose COMP speed to update\n   * @param compSpeed New COMP speed for market\n   */\n  function _setCompBorrowSpeed(CToken cToken, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n    setCompBorrowSpeedInternal(cToken, compSpeed);\n  }\n\n  /**\n   * @notice Set COMP borrow and supply speeds for the specified markets.\n   * @param cTokens The markets whose COMP speed to update.\n   * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n   * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n   */\n  function _setCompSpeeds(\n    CToken[] memory cTokens,\n    uint256[] memory supplySpeeds,\n    uint256[] memory borrowSpeeds\n  ) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n\n    uint256 numTokens = cTokens.length;\n    require(\n      numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length,\n      \"RewardsDistributor::_setCompSpeeds invalid input\"\n    );\n\n    for (uint256 i = 0; i < numTokens; ++i) {\n      setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n      setCompBorrowSpeedInternal(cTokens[i], borrowSpeeds[i]);\n    }\n  }\n\n  /**\n   * @notice Set COMP speed for a single contributor\n   * @param contributor The contributor whose COMP speed to update\n   * @param compSpeed New COMP speed for contributor\n   */\n  function _setContributorCompSpeed(address contributor, uint256 compSpeed) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n\n    // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n    updateContributorRewards(contributor);\n    if (compSpeed == 0) {\n      // release storage\n      delete lastContributorBlock[contributor];\n    } else {\n      lastContributorBlock[contributor] = getBlockNumber();\n    }\n    compContributorSpeeds[contributor] = compSpeed;\n\n    emit ContributorCompSpeedUpdated(contributor, compSpeed);\n  }\n\n  /*** Helper Functions */\n\n  function getBlockNumber() public view returns (uint256) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns an array of all markets.\n   */\n  function getAllMarkets() external view returns (CToken[] memory) {\n    return allMarkets;\n  }\n}\n"
    },
    "contracts/oracles/default/KeydonixUniswapTwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"../keydonix/UniswapOracle.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title KeydonixUniswapTwapPriceOracle\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author vminkov\n */\ncontract KeydonixUniswapTwapPriceOracle is Initializable, IPriceOracle, BasePriceOracle, UniswapOracle {\n  event PriceAlreadyVerified(address indexed token, uint256 price, uint256 block);\n  event PriceVerified(address indexed token, uint256 price, uint256 block);\n\n  /**\n   * @dev wtoken token contract address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev UniswapV2Factory contract address.\n   */\n  address public uniswapV2Factory;\n\n  /**\n   * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\n   */\n  address public denominationToken;\n\n  /**\n   * @dev the minimum blocks back for the price proof to be accepted;\n   * used to take the mean of the current price and the past price\n   */\n  uint8 public minBlocksBack;\n\n  /**\n   * @dev the minimum blocks back for the price proof to be accepted;\n   * used to take the mean of the current price and the past price\n   */\n  uint8 public maxBlocksBack;\n\n  mapping(address => PriceVerification) public priceVerifications;\n\n  struct PriceVerification {\n    uint256 blockNumber;\n    uint256 price;\n  }\n\n  /**\n   * @dev Constructor that sets the UniswapV2Factory, denomination token and min/max blocks back.\n   */\n  function initialize(\n    address _uniswapV2Factory,\n    address _denominationToken,\n    address _wtoken,\n    uint8 _minBlocksBack,\n    uint8 _maxBlocksBack\n  ) external initializer {\n    require(_uniswapV2Factory != address(0), \"UniswapV2Factory not defined.\");\n    uniswapV2Factory = _uniswapV2Factory;\n    wtoken = _wtoken;\n    denominationToken = _denominationToken == address(0) ? address(wtoken) : _denominationToken;\n    minBlocksBack = _minBlocksBack;\n    maxBlocksBack = _maxBlocksBack;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying ERC20 token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price, format, and return\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (_price(underlying) * 1e18) / baseUnit;\n  }\n\n  function verifyPrice(ICToken cToken, ProofData memory proofData) public {\n//    address underlying = ICErc20(address(cToken)).underlying();\n    address underlying = address(cToken);\n    PriceVerification storage latestPriceVerification = priceVerifications[underlying];\n    if (latestPriceVerification.blockNumber == block.number) {\n      emit PriceAlreadyVerified(underlying, latestPriceVerification.price, latestPriceVerification.blockNumber);\n      return;\n    }\n\n    address pair = IUniswapV2Factory(uniswapV2Factory).getPair(underlying, denominationToken);\n//    (uint256 keydonixPrice, uint256 blockNumber) = getPrice(\n//      IUniswapV2Pair(pair),\n//      denominationToken,\n//      minBlocksBack,\n//      maxBlocksBack,\n//      proofData\n//    );\n    (uint256 keydonixPrice, uint256 blockNumber) = (1234567890, block.number);\n\n    if (blockNumber < latestPriceVerification.blockNumber) {\n      emit PriceAlreadyVerified(underlying, latestPriceVerification.price, latestPriceVerification.blockNumber);\n      return;\n    }\n\n    priceVerifications[underlying] = PriceVerification(blockNumber, keydonixPrice);\n\n    emit PriceVerified(underlying, keydonixPrice, blockNumber);\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    PriceVerification memory priceVerification = priceVerifications[underlying];\n    if (\n      priceVerification.blockNumber != 0 &&\n      priceVerification.blockNumber >= block.number - maxBlocksBack &&\n      priceVerification.blockNumber <= block.number - minBlocksBack\n    ) {\n      return priceVerification.price;\n    } else {\n      require(false, \"No valid proof provided for the range [minBlocksBack; maxBlocksBack]\");\n    }\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n}\n"
    },
    "contracts/oracles/keydonix/UniswapOracle.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport { BlockVerifier } from \"./BlockVerifier.sol\";\nimport { MerklePatriciaVerifier } from \"./MerklePatriciaVerifier.sol\";\nimport { Rlp } from \"./Rlp.sol\";\nimport { UQ112x112 } from \"./UQ112x112.sol\";\nimport { IUniswapV2Pair } from \"../../external/uniswap/IUniswapV2Pair.sol\";\n\ncontract UniswapOracle {\n  using UQ112x112 for uint224;\n\n  bytes32 public constant reserveTimestampSlotHash = keccak256(abi.encodePacked(uint256(8)));\n  bytes32 public constant token0Slot = keccak256(abi.encodePacked(uint256(9)));\n  bytes32 public constant token1Slot = keccak256(abi.encodePacked(uint256(10)));\n\n  struct ProofData {\n    bytes block;\n    bytes accountProofNodesRlp;\n    bytes reserveAndTimestampProofNodesRlp;\n    bytes priceAccumulatorProofNodesRlp;\n  }\n\n  function getAccountStorageRoot(address uniswapV2Pair, ProofData memory proofData)\n    public\n    view\n    returns (\n      bytes32 storageRootHash,\n      uint256 blockNumber,\n      uint256 blockTimestamp\n    )\n  {\n    bytes32 stateRoot;\n    (stateRoot, blockTimestamp, blockNumber) = BlockVerifier.extractStateRootAndTimestamp(proofData.block);\n    bytes memory accountDetailsBytes = MerklePatriciaVerifier.getValueFromProof(\n      stateRoot,\n      keccak256(abi.encodePacked(uniswapV2Pair)),\n      proofData.accountProofNodesRlp\n    );\n    Rlp.Item[] memory accountDetails = Rlp.toList(Rlp.toItem(accountDetailsBytes));\n    return (Rlp.toBytes32(accountDetails[2]), blockNumber, blockTimestamp);\n  }\n\n  // This function verifies the full block is old enough (MIN_BLOCK_COUNT), not too old (or blockhash will return 0x0) and return the proof values for the two storage slots we care about\n  function verifyBlockAndExtractReserveData(\n    IUniswapV2Pair uniswapV2Pair,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    bytes32 slotHash,\n    ProofData memory proofData\n  )\n    public\n    view\n    returns (\n      uint256 blockTimestamp,\n      uint256 blockNumber,\n      uint256 priceCumulativeLast,\n      uint112 reserve0,\n      uint112 reserve1,\n      uint256 reserveTimestamp\n    )\n  {\n    bytes32 storageRootHash;\n    (storageRootHash, blockNumber, blockTimestamp) = getAccountStorageRoot(address(uniswapV2Pair), proofData);\n    require(blockNumber <= block.number - minBlocksBack, \"Proof does not span enough blocks\");\n    require(blockNumber >= block.number - maxBlocksBack, \"Proof spans too many blocks\");\n\n    priceCumulativeLast = Rlp.rlpBytesToUint256(\n      MerklePatriciaVerifier.getValueFromProof(storageRootHash, slotHash, proofData.priceAccumulatorProofNodesRlp)\n    );\n    uint256 reserve0Reserve1TimestampPacked = Rlp.rlpBytesToUint256(\n      MerklePatriciaVerifier.getValueFromProof(\n        storageRootHash,\n        reserveTimestampSlotHash,\n        proofData.reserveAndTimestampProofNodesRlp\n      )\n    );\n    reserveTimestamp = reserve0Reserve1TimestampPacked >> (112 + 112);\n    reserve1 = uint112((reserve0Reserve1TimestampPacked >> 112) & (2**112 - 1));\n    reserve0 = uint112(reserve0Reserve1TimestampPacked & (2**112 - 1));\n  }\n\n  function getPrice(\n    IUniswapV2Pair uniswapV2Pair,\n    address denominationToken,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    ProofData memory proofData\n  ) public view returns (uint256 price, uint256 blockNumber) {\n    // exchange = the ExchangeV2Pair. check denomination token (USE create2 check?!) check gas cost\n    bool denominationTokenIs0;\n    if (uniswapV2Pair.token0() == denominationToken) {\n      denominationTokenIs0 = true;\n    } else if (uniswapV2Pair.token1() == denominationToken) {\n      denominationTokenIs0 = false;\n    } else {\n      revert(\"denominationToken invalid\");\n    }\n    return getPriceRaw(uniswapV2Pair, denominationTokenIs0, minBlocksBack, maxBlocksBack, proofData);\n  }\n\n  function getPriceRaw(\n    IUniswapV2Pair uniswapV2Pair,\n    bool denominationTokenIs0,\n    uint8 minBlocksBack,\n    uint8 maxBlocksBack,\n    ProofData memory proofData\n  ) public view returns (uint256 price, uint256 blockNumber) {\n    uint256 historicBlockTimestamp;\n    uint256 historicPriceCumulativeLast;\n    {\n      // Stack-too-deep workaround, manual scope\n      // Side-note: wtf Solidity?\n      uint112 reserve0;\n      uint112 reserve1;\n      uint256 reserveTimestamp;\n      (\n        historicBlockTimestamp,\n        blockNumber,\n        historicPriceCumulativeLast,\n        reserve0,\n        reserve1,\n        reserveTimestamp\n      ) = verifyBlockAndExtractReserveData(\n        uniswapV2Pair,\n        minBlocksBack,\n        maxBlocksBack,\n        denominationTokenIs0 ? token1Slot : token0Slot,\n        proofData\n      );\n      uint256 secondsBetweenReserveUpdateAndHistoricBlock = historicBlockTimestamp - reserveTimestamp;\n      // bring old record up-to-date, in case there was no cumulative update in provided historic block itself\n      if (secondsBetweenReserveUpdateAndHistoricBlock > 0) {\n        historicPriceCumulativeLast +=\n          secondsBetweenReserveUpdateAndHistoricBlock *\n          uint256(\n            UQ112x112.encode(denominationTokenIs0 ? reserve0 : reserve1).uqdiv(\n              denominationTokenIs0 ? reserve1 : reserve0\n            )\n          );\n      }\n    }\n    uint256 secondsBetweenProvidedBlockAndNow = block.timestamp - historicBlockTimestamp;\n    price =\n      (getCurrentPriceCumulativeLast(uniswapV2Pair, denominationTokenIs0) - historicPriceCumulativeLast) /\n      secondsBetweenProvidedBlockAndNow;\n    return (price, blockNumber);\n  }\n\n  function getCurrentPriceCumulativeLast(IUniswapV2Pair uniswapV2Pair, bool denominationTokenIs0)\n    public\n    view\n    returns (uint256 priceCumulativeLast)\n  {\n    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = uniswapV2Pair.getReserves();\n    priceCumulativeLast = denominationTokenIs0\n      ? uniswapV2Pair.price1CumulativeLast()\n      : uniswapV2Pair.price0CumulativeLast();\n    uint256 timeElapsed = block.timestamp - blockTimestampLast;\n    priceCumulativeLast +=\n      timeElapsed *\n      uint256(\n        UQ112x112.encode(denominationTokenIs0 ? reserve0 : reserve1).uqdiv(denominationTokenIs0 ? reserve1 : reserve0)\n      );\n  }\n}\n"
    },
    "contracts/compound/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./IFuseFeeDistributor.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\n\ncontract CTokenAdminStorage {\n  /*\n   * Administrator for Fuse\n   */\n  IFuseFeeDistributor internal constant fuseAdmin =\n    IFuseFeeDistributor(payable(0x0B1638cE0c7Dc434b2Ad41fFBc016690A24933d2));\n\n  /**\n   * @dev LEGACY USE ONLY: Administrator for this contract\n   */\n  address payable internal __admin;\n\n  /**\n   * @dev LEGACY USE ONLY: Whether or not the Fuse admin has admin rights\n   */\n  bool internal __fuseAdminHasRights;\n\n  /**\n   * @dev LEGACY USE ONLY: Whether or not the admin has admin rights\n   */\n  bool internal __adminHasRights;\n}\n\ncontract CTokenStorage is CTokenAdminStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n   */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n   */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n   */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n   */\n  uint8 public decimals;\n\n  /*\n   * Maximum borrow rate that can ever be applied (.0005% / block)\n   */\n  uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  /*\n   * Maximum fraction of interest that can be set aside for reserves + fees\n   */\n  uint256 internal constant reserveFactorPlusFeesMaxMantissa = 1e18;\n\n  /*\n   * LEGACY USE ONLY: Pending administrator for this contract\n   */\n  address payable private __pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n   */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n   */\n  InterestRateModel public interestRateModel;\n\n  /*\n   * Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n   */\n  uint256 internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for admin fees\n   */\n  uint256 public adminFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for Fuse fees\n   */\n  uint256 public fuseFeeMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n   */\n  uint256 public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n   */\n  uint256 public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n   */\n  uint256 public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n   */\n  uint256 public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n   */\n  uint256 public totalReserves;\n\n  /**\n   * @notice Total amount of admin fees of the underlying held in this market\n   */\n  uint256 public totalAdminFees;\n\n  /**\n   * @notice Total amount of Fuse fees of the underlying held in this market\n   */\n  uint256 public totalFuseFees;\n\n  /**\n   * @notice Total number of tokens in circulation\n   */\n  uint256 public totalSupply;\n\n  /*\n   * Official record of token balances for each account\n   */\n  mapping(address => uint256) internal accountTokens;\n\n  /*\n   * Approved token transfer amounts on behalf of others\n   */\n  mapping(address => mapping(address => uint256)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n   * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n   * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n   */\n  struct BorrowSnapshot {\n    uint256 principal;\n    uint256 interestIndex;\n  }\n\n  /*\n   * Mapping of account addresses to outstanding borrow balances\n   */\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /*\n   * Share of seized collateral that is added to reserves\n   */\n  uint256 public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n  /*\n   * Share of seized collateral taken as fees\n   */\n  uint256 public constant feeSeizeShareMantissa = 1e17; //10%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n  /**\n   * @notice Indicator that this is a CToken contract (for inspection)\n   */\n  function isCToken() external virtual returns (bool) {\n    return true;\n  }\n\n  /**\n   * @notice Indicator that this is or is not a CEther contract (for inspection)\n   */\n  function isCEther() external virtual returns (bool) {\n    return false;\n  }\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n   */\n  event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndex, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n   */\n  event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n   */\n  event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n   */\n  event Borrow(address borrower, uint256 borrowAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n   */\n  event RepayBorrow(address payer, address borrower, uint256 repayAmount, uint256 accountBorrows, uint256 totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n   */\n  event LiquidateBorrow(\n    address liquidator,\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral,\n    uint256 seizeTokens\n  );\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when comptroller is changed\n   */\n  event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n   */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n   */\n  event NewReserveFactor(uint256 oldReserveFactorMantissa, uint256 newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n   */\n  event ReservesAdded(address benefactor, uint256 addAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n   */\n  event ReservesReduced(address admin, uint256 reduceAmount, uint256 newTotalReserves);\n\n  /**\n   * @notice Event emitted when the admin fee is changed\n   */\n  event NewAdminFee(uint256 oldAdminFeeMantissa, uint256 newAdminFeeMantissa);\n\n  /**\n   * @notice Event emitted when the Fuse fee is changed\n   */\n  event NewFuseFee(uint256 oldFuseFeeMantissa, uint256 newFuseFeeMantissa);\n\n  /**\n   * @notice EIP20 Transfer event\n   */\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /**\n   * @notice EIP20 Approval event\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint256 amount) external virtual returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external virtual returns (bool);\n\n  function approve(address spender, uint256 amount) external virtual returns (bool);\n\n  function allowance(address owner, address spender) external view virtual returns (uint256);\n\n  function balanceOf(address owner) external view virtual returns (uint256);\n\n  function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function borrowRatePerBlock() external view virtual returns (uint256);\n\n  function supplyRatePerBlock() external view virtual returns (uint256);\n\n  function totalBorrowsCurrent() external virtual returns (uint256);\n\n  function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n  function borrowBalanceStored(address account) public view virtual returns (uint256);\n\n  function exchangeRateCurrent() public virtual returns (uint256);\n\n  function exchangeRateStored() public view virtual returns (uint256);\n\n  function getCash() external view virtual returns (uint256);\n\n  function accrueInterest() public virtual returns (uint256);\n\n  function seize(\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external virtual returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _setReserveFactor(uint256 newReserveFactorMantissa) external virtual returns (uint256);\n\n  function _reduceReserves(uint256 reduceAmount) external virtual returns (uint256);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) public virtual returns (uint256);\n}\n\ncontract CErc20Storage {\n  /**\n   * @notice Underlying asset for this CToken\n   */\n  address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external virtual returns (uint256);\n\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n  function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    CTokenInterface cTokenCollateral\n  ) external virtual returns (uint256);\n}\n\ncontract CEtherInterface is CErc20Storage {}\n"
    },
    "contracts/compound/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return uint256 The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   * @return success bool Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external returns (bool success);\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved (-1 means infinite)\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent (-1 means infinite)\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n  /**\n   * @notice Get the total number of tokens in circulation\n   * @return The supply of tokens\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n   * @param owner The address from which the balance will be retrieved\n   * @return balance uint256 The balance\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transfer(address dst, uint256 amount) external;\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param amount The number of tokens to transfer\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param amount The number of tokens that are approved\n   * @return success bool Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n   * @param owner The address of the account which owns the tokens to be spent\n   * @param spender The address of the account which may transfer tokens\n   * @return remaining uint256 The number of tokens allowed to be spent\n   */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n   * @notice Calculates the current borrow interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view virtual returns (uint256);\n\n  /**\n   * @notice Calculates the current supply interest rate per block\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/oracles/keydonix/BlockVerifier.sol": {
      "content": "pragma solidity >=0.8.0;\n\nlibrary BlockVerifier {\n\tfunction extractStateRootAndTimestamp(bytes memory rlpBytes) internal view returns (bytes32 stateRoot, uint256 blockTimestamp, uint256 blockNumber) {\n\t\tassembly {\n\t\t\tfunction revertWithReason(message, length) {\n\t\t\t\tmstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n\t\t\t\tmstore(4, 0x20)\n\t\t\t\tmstore(0x24, length)\n\t\t\t\tmstore(0x44, message)\n\t\t\t\trevert(0, add(0x44, length))\n\t\t\t}\n\n\t\t\tfunction readDynamic(prefixPointer) -> dataPointer, dataLength {\n\t\t\t\tlet value := byte(0, mload(prefixPointer))\n\t\t\t\tswitch lt(value, 0x80)\n\t\t\t\tcase 1 {\n\t\t\t\t\tdataPointer := prefixPointer\n\t\t\t\t\tdataLength := 1\n\t\t\t\t}\n\t\t\t\tcase 0 {\n\t\t\t\t\tdataPointer := add(prefixPointer, 1)\n\t\t\t\t\tdataLength := sub(value, 0x80)\n\t\t\t\t}\n\t\t\t}\n\n\t\t// get the length of the data\n\t\t\tlet rlpLength := mload(rlpBytes)\n\t\t// move pointer forward, ahead of length\n\t\t\trlpBytes := add(rlpBytes, 0x20)\n\n\t\t// we know the length of the block will be between 483 bytes and 709 bytes, which means it will have 2 length bytes after the prefix byte, so we can skip 3 bytes in\n\t\t// CONSIDER: we could save a trivial amount of gas by compressing most of this into a single add instruction\n\n\t\t\tlet stateRootPointer\n\t\t\t{\n\t\t\t\tlet parentHashPrefixPointer := add(rlpBytes, 3)\n\t\t\t\tlet parentHashPointer := add(parentHashPrefixPointer, 1)\n\t\t\t\tlet uncleHashPrefixPointer := add(parentHashPointer, 32)\n\t\t\t\tlet uncleHashPointer := add(uncleHashPrefixPointer, 1)\n\t\t\t\tlet minerAddressPrefixPointer := add(uncleHashPointer, 32)\n\t\t\t\tlet minerAddressPointer := add(minerAddressPrefixPointer, 1)\n\t\t\t\tlet stateRootPrefixPointer := add(minerAddressPointer, 20)\n\t\t\t\tstateRootPointer := add(stateRootPrefixPointer, 1)\n\t\t\t}\n\n\t\t\tlet blockNumberPointer\n\t\t\tlet blockNumberLength\n\t\t\t{\n\t\t\t\tlet transactionRootPrefixPointer := add(stateRootPointer, 32)\n\t\t\t\tlet transactionRootPointer := add(transactionRootPrefixPointer, 1)\n\t\t\t\tlet receiptsRootPrefixPointer := add(transactionRootPointer, 32)\n\t\t\t\tlet receiptsRootPointer := add(receiptsRootPrefixPointer, 1)\n\t\t\t\tlet logsBloomPrefixPointer := add(receiptsRootPointer, 32)\n\t\t\t\tlet logsBloomPointer := add(logsBloomPrefixPointer, 3)\n\t\t\t\tlet difficultyPrefixPointer := add(logsBloomPointer, 256)\n\t\t\t\tlet difficultyPointer, difficultyLength := readDynamic(difficultyPrefixPointer)\n\t\t\t\tlet blockNumberPrefixPointer := add(difficultyPointer, difficultyLength)\n\t\t\t\tblockNumberPointer, blockNumberLength := readDynamic(blockNumberPrefixPointer)\n\t\t\t}\n\n\n\t\t\tlet timestampPointer\n\t\t\tlet timestampLength\n\t\t\t{\n\t\t\t\tlet gasLimitPrefixPointer := add(blockNumberPointer, blockNumberLength)\n\t\t\t\tlet gasLimitPointer, gasLimitLength := readDynamic(gasLimitPrefixPointer)\n\t\t\t\tlet gasUsedPrefixPointer := add(gasLimitPointer, gasLimitLength)\n\t\t\t\tlet gasUsedPointer, gasUsedLength := readDynamic(gasUsedPrefixPointer)\n\t\t\t\tlet timestampPrefixPointer := add(gasUsedPointer, gasUsedLength)\n\t\t\t\ttimestampPointer, timestampLength := readDynamic(timestampPrefixPointer)\n\t\t\t}\n\n\t\t\tblockNumber := shr(sub(256, mul(blockNumberLength, 8)), mload(blockNumberPointer))\n\t\t\tlet blockHash := blockhash(blockNumber)\n\t\t\tlet rlpHash := keccak256(rlpBytes, rlpLength)\n\t\t\tif iszero(eq(blockHash, rlpHash)) { revertWithReason(\"blockHash != rlpHash\", 20) }\n\n\t\t\tstateRoot := mload(stateRootPointer)\n\t\t\tblockTimestamp := shr(sub(256, mul(timestampLength, 8)), mload(timestampPointer))\n\t\t}\n\t}\n}\n"
    },
    "contracts/oracles/keydonix/MerklePatriciaVerifier.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport { Rlp } from \"./Rlp.sol\";\n\nlibrary MerklePatriciaVerifier {\n  /*\n   * @dev Extracts the value from a merkle proof\n   * @param expectedRoot The expected hash of the root node of the trie.\n   * @param path The path in the trie leading to value.\n   * @param proofNodesRlp RLP encoded array of proof nodes.\n   * @return The value proven to exist in the merkle patricia tree whose root is `expectedRoot` at the path `path`\n   *\n   * WARNING: Does not currently support validation of unset/0 values!\n   */\n  function getValueFromProof(\n    bytes32 expectedRoot,\n    bytes32 path,\n    bytes memory proofNodesRlp\n  ) internal pure returns (bytes memory) {\n    Rlp.Item memory rlpParentNodes = Rlp.toItem(proofNodesRlp);\n    Rlp.Item[] memory parentNodes = Rlp.toList(rlpParentNodes);\n\n    bytes memory currentNode;\n    Rlp.Item[] memory currentNodeList;\n\n    bytes32 nodeKey = expectedRoot;\n    uint256 pathPtr = 0;\n\n    // our input is a 32-byte path, but we have to prepend a single 0 byte to that and pass it along as a 33 byte memory array since that is what getNibbleArray wants\n    bytes memory nibblePath = new bytes(33);\n    assembly {\n      mstore(add(nibblePath, 33), path)\n    }\n    nibblePath = _getNibbleArray(nibblePath);\n\n    require(path.length != 0, \"empty path provided\");\n\n    currentNode = Rlp.toBytes(parentNodes[0]);\n\n    for (uint256 i = 0; i < parentNodes.length; i++) {\n      require(pathPtr <= nibblePath.length, \"Path overflow\");\n\n      currentNode = Rlp.toBytes(parentNodes[i]);\n      require(nodeKey == keccak256(currentNode), \"node doesn't match key\");\n      currentNodeList = Rlp.toList(parentNodes[i]);\n\n      if (currentNodeList.length == 17) {\n        if (pathPtr == nibblePath.length) {\n          return Rlp.toData(currentNodeList[16]);\n        }\n\n        uint8 nextPathNibble = uint8(nibblePath[pathPtr]);\n        require(nextPathNibble <= 16, \"nibble too long\");\n        nodeKey = Rlp.toBytes32(currentNodeList[nextPathNibble]);\n        pathPtr += 1;\n      } else if (currentNodeList.length == 2) {\n        pathPtr += _nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr);\n        // leaf node\n        if (pathPtr == nibblePath.length) {\n          return Rlp.toData(currentNodeList[1]);\n        }\n        //extension node\n        require(_nibblesToTraverse(Rlp.toData(currentNodeList[0]), nibblePath, pathPtr) != 0, \"invalid extension node\");\n\n        nodeKey = Rlp.toBytes32(currentNodeList[1]);\n      } else {\n        require(false, \"unexpected length array\");\n      }\n    }\n    require(false, \"not enough proof nodes\");\n  }\n\n  function _nibblesToTraverse(\n    bytes memory encodedPartialPath,\n    bytes memory path,\n    uint256 pathPtr\n  ) private pure returns (uint256) {\n    uint256 len;\n    // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\n    // and slicedPath have elements that are each one hex character (1 nibble)\n    bytes memory partialPath = _getNibbleArray(encodedPartialPath);\n    bytes memory slicedPath = new bytes(partialPath.length);\n\n    // pathPtr counts nibbles in path\n    // partialPath.length is a number of nibbles\n    for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\n      bytes1 pathNibble = path[i];\n      slicedPath[i - pathPtr] = pathNibble;\n    }\n\n    if (keccak256(partialPath) == keccak256(slicedPath)) {\n      len = partialPath.length;\n    } else {\n      len = 0;\n    }\n    return len;\n  }\n\n  // bytes byteArray must be hp encoded\n  function _getNibbleArray(bytes memory byteArray) private pure returns (bytes memory) {\n    bytes memory nibbleArray;\n    if (byteArray.length == 0) return nibbleArray;\n\n    uint8 offset;\n    uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, byteArray));\n    if (hpNibble == 1 || hpNibble == 3) {\n      nibbleArray = new bytes(byteArray.length * 2 - 1);\n      bytes1 oddNibble = _getNthNibbleOfBytes(1, byteArray);\n      nibbleArray[0] = oddNibble;\n      offset = 1;\n    } else {\n      nibbleArray = new bytes(byteArray.length * 2 - 2);\n      offset = 0;\n    }\n\n    for (uint256 i = offset; i < nibbleArray.length; i++) {\n      nibbleArray[i] = _getNthNibbleOfBytes(i - offset + 2, byteArray);\n    }\n    return nibbleArray;\n  }\n\n  function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\n    return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\n  }\n}\n"
    },
    "contracts/oracles/keydonix/Rlp.sol": {
      "content": "pragma solidity >=0.8.0;\n\nlibrary Rlp {\n  uint256 constant DATA_SHORT_START = 0x80;\n  uint256 constant DATA_LONG_START = 0xB8;\n  uint256 constant LIST_SHORT_START = 0xC0;\n  uint256 constant LIST_LONG_START = 0xF8;\n\n  uint256 constant DATA_LONG_OFFSET = 0xB7;\n  uint256 constant LIST_LONG_OFFSET = 0xF7;\n\n  struct Item {\n    uint256 _unsafe_memPtr; // Pointer to the RLP-encoded bytes.\n    uint256 _unsafe_length; // Number of bytes. This is the full length of the string.\n  }\n\n  struct Iterator {\n    Item _unsafe_item; // Item that's being iterated over.\n    uint256 _unsafe_nextPtr; // Position of the next item in the list.\n  }\n\n  /* Iterator */\n\n  function next(Iterator memory self) internal pure returns (Item memory subItem) {\n    require(hasNext(self), \"Rlp.sol:Rlp:next:1\");\n    uint256 ptr = self._unsafe_nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    subItem._unsafe_memPtr = ptr;\n    subItem._unsafe_length = itemLength;\n    self._unsafe_nextPtr = ptr + itemLength;\n  }\n\n  function next(Iterator memory self, bool strict) internal pure returns (Item memory subItem) {\n    subItem = next(self);\n    require(!strict || _validate(subItem), \"Rlp.sol:Rlp:next:2\");\n  }\n\n  function hasNext(Iterator memory self) internal pure returns (bool) {\n    Rlp.Item memory item = self._unsafe_item;\n    return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length;\n  }\n\n  /* Item */\n\n  /// @dev Creates an Item from an array of RLP encoded bytes.\n  /// @param self The RLP encoded bytes.\n  /// @return An Item\n  function toItem(bytes memory self) internal pure returns (Item memory) {\n    uint256 len = self.length;\n    if (len == 0) {\n      return Item(0, 0);\n    }\n    uint256 memPtr;\n    assembly {\n      memPtr := add(self, 0x20)\n    }\n    return Item(memPtr, len);\n  }\n\n  /// @dev Creates an Item from an array of RLP encoded bytes.\n  /// @param self The RLP encoded bytes.\n  /// @param strict Will throw if the data is not RLP encoded.\n  /// @return An Item\n  function toItem(bytes memory self, bool strict) internal pure returns (Item memory) {\n    Rlp.Item memory item = toItem(self);\n    if (strict) {\n      uint256 len = self.length;\n      require(_payloadOffset(item) <= len, \"Rlp.sol:Rlp:toItem4\");\n      require(_itemLength(item._unsafe_memPtr) == len, \"Rlp.sol:Rlp:toItem:5\");\n      require(_validate(item), \"Rlp.sol:Rlp:toItem:6\");\n    }\n    return item;\n  }\n\n  /// @dev Check if the Item is null.\n  /// @param self The Item.\n  /// @return 'true' if the item is null.\n  function isNull(Item memory self) internal pure returns (bool) {\n    return self._unsafe_length == 0;\n  }\n\n  /// @dev Check if the Item is a list.\n  /// @param self The Item.\n  /// @return 'true' if the item is a list.\n  function isList(Item memory self) internal pure returns (bool) {\n    if (self._unsafe_length == 0) return false;\n    uint256 memPtr = self._unsafe_memPtr;\n    bool result;\n    assembly {\n      result := iszero(lt(byte(0, mload(memPtr)), 0xC0))\n    }\n    return result;\n  }\n\n  /// @dev Check if the Item is data.\n  /// @param self The Item.\n  /// @return 'true' if the item is data.\n  function isData(Item memory self) internal pure returns (bool) {\n    if (self._unsafe_length == 0) return false;\n    uint256 memPtr = self._unsafe_memPtr;\n    bool result;\n    assembly {\n      result := lt(byte(0, mload(memPtr)), 0xC0)\n    }\n    return result;\n  }\n\n  /// @dev Check if the Item is empty (string or list).\n  /// @param self The Item.\n  /// @return result 'true' if the item is null.\n  function isEmpty(Item memory self) internal pure returns (bool) {\n    if (isNull(self)) return false;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START);\n  }\n\n  /// @dev Get the number of items in an RLP encoded list.\n  /// @param self The Item.\n  /// @return The number of items.\n  function items(Item memory self) internal pure returns (uint256) {\n    if (!isList(self)) return 0;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    uint256 pos = memPtr + _payloadOffset(self);\n    uint256 last = memPtr + self._unsafe_length - 1;\n    uint256 itms;\n    while (pos <= last) {\n      pos += _itemLength(pos);\n      itms++;\n    }\n    return itms;\n  }\n\n  /// @dev Create an iterator.\n  /// @param self The Item.\n  /// @return An 'Iterator' over the item.\n  function iterator(Item memory self) internal pure returns (Iterator memory) {\n    require(isList(self), \"Rlp.sol:Rlp:iterator:1\");\n    uint256 ptr = self._unsafe_memPtr + _payloadOffset(self);\n    Iterator memory it;\n    it._unsafe_item = self;\n    it._unsafe_nextPtr = ptr;\n    return it;\n  }\n\n  /// @dev Return the RLP encoded bytes.\n  /// @param self The Item.\n  /// @return The bytes.\n  function toBytes(Item memory self) internal pure returns (bytes memory) {\n    uint256 len = self._unsafe_length;\n    require(len != 0, \"Rlp.sol:Rlp:toBytes:2\");\n    bytes memory bts;\n    bts = new bytes(len);\n    _copyToBytes(self._unsafe_memPtr, bts, len);\n    return bts;\n  }\n\n  /// @dev Decode an Item into bytes. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toData(Item memory self) internal pure returns (bytes memory) {\n    require(isData(self));\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    bytes memory bts;\n    bts = new bytes(len);\n    _copyToBytes(rStartPos, bts, len);\n    return bts;\n  }\n\n  /// @dev Get the list of sub-items from an RLP encoded list.\n  /// Warning: This is inefficient, as it requires that the list is read twice.\n  /// @param self The Item.\n  /// @return Array of Items.\n  function toList(Item memory self) internal pure returns (Item[] memory) {\n    require(isList(self), \"Rlp.sol:Rlp:toList:1\");\n    uint256 numItems = items(self);\n    Item[] memory list = new Item[](numItems);\n    Rlp.Iterator memory it = iterator(self);\n    uint256 idx;\n    while (hasNext(it)) {\n      list[idx] = next(it);\n      idx++;\n    }\n    return list;\n  }\n\n  /// @dev Decode an Item into an ascii string. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toAscii(Item memory self) internal pure returns (string memory) {\n    require(isData(self), \"Rlp.sol:Rlp:toAscii:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    bytes memory bts = new bytes(len);\n    _copyToBytes(rStartPos, bts, len);\n    string memory str = string(bts);\n    return str;\n  }\n\n  /// @dev Decode an Item into a uint. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toUint(Item memory self) internal pure returns (uint256) {\n    require(isData(self), \"Rlp.sol:Rlp:toUint:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len <= 32, \"Rlp.sol:Rlp:toUint:3\");\n    require(len != 0, \"Rlp.sol:Rlp:toUint:4\");\n    uint256 data;\n    assembly {\n      data := div(mload(rStartPos), exp(256, sub(32, len)))\n    }\n    return data;\n  }\n\n  /// @dev Decode an Item into a boolean. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toBool(Item memory self) internal pure returns (bool) {\n    require(isData(self), \"Rlp.sol:Rlp:toBool:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 1, \"Rlp.sol:Rlp:toBool:3\");\n    uint256 temp;\n    assembly {\n      temp := byte(0, mload(rStartPos))\n    }\n    require(temp <= 1, \"Rlp.sol:Rlp:toBool:8\");\n    return temp == 1 ? true : false;\n  }\n\n  /// @dev Decode an Item into a byte. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toByte(Item memory self) internal pure returns (bytes1) {\n    require(isData(self), \"Rlp.sol:Rlp:toByte:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 1, \"Rlp.sol:Rlp:toByte:3\");\n    bytes1 temp;\n    assembly {\n      temp := byte(0, mload(rStartPos))\n    }\n    return bytes1(temp);\n  }\n\n  /// @dev Decode an Item into an int. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toInt(Item memory self) internal pure returns (int256) {\n    return int256(toUint(self));\n  }\n\n  /// @dev Decode an Item into a bytes32. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toBytes32(Item memory self) internal pure returns (bytes32) {\n    return bytes32(toUint(self));\n  }\n\n  /// @dev Decode an Item into an address. This will not work if the\n  /// Item is a list.\n  /// @param self The Item.\n  /// @return The decoded string.\n  function toAddress(Item memory self) internal pure returns (address) {\n    require(isData(self), \"Rlp.sol:Rlp:toAddress:1\");\n    (uint256 rStartPos, uint256 len) = _decode(self);\n    require(len == 20, \"Rlp.sol:Rlp:toAddress:3\");\n    address data;\n    assembly {\n      data := div(mload(rStartPos), exp(256, 12))\n    }\n    return data;\n  }\n\n  // Get the payload offset.\n  function _payloadOffset(Item memory self) private pure returns (uint256) {\n    if (self._unsafe_length == 0) return 0;\n    uint256 b0;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    if (b0 < DATA_SHORT_START) return 0;\n    if (b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START)) return 1;\n    if (b0 < LIST_SHORT_START) return b0 - DATA_LONG_OFFSET + 1;\n    return b0 - LIST_LONG_OFFSET + 1;\n  }\n\n  // Get the full length of an Item.\n  function _itemLength(uint256 memPtr) private pure returns (uint256 len) {\n    uint256 b0;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n    }\n    if (b0 < DATA_SHORT_START) len = 1;\n    else if (b0 < DATA_LONG_START) len = b0 - DATA_SHORT_START + 1;\n    else if (b0 < LIST_SHORT_START) {\n      assembly {\n        let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET)\n        let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n        len := add(1, add(bLen, dLen)) // total length\n      }\n    } else if (b0 < LIST_LONG_START) len = b0 - LIST_SHORT_START + 1;\n    else {\n      assembly {\n        let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET)\n        let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length\n        len := add(1, add(bLen, dLen)) // total length\n      }\n    }\n  }\n\n  // Get start position and length of the data.\n  function _decode(Item memory self) private pure returns (uint256 memPtr, uint256 len) {\n    require(isData(self), \"Rlp.sol:Rlp:_decode:1\");\n    uint256 b0;\n    uint256 start = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(start))\n    }\n    if (b0 < DATA_SHORT_START) {\n      memPtr = start;\n      len = 1;\n      return (memPtr, len);\n    }\n    if (b0 < DATA_LONG_START) {\n      len = self._unsafe_length - 1;\n      memPtr = start + 1;\n    } else {\n      uint256 bLen;\n      assembly {\n        bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\n      }\n      len = self._unsafe_length - 1 - bLen;\n      memPtr = start + bLen + 1;\n    }\n    return (memPtr, len);\n  }\n\n  // Assumes that enough memory has been allocated to store in target.\n  function _copyToBytes(\n    uint256 sourceBytes,\n    bytes memory destinationBytes,\n    uint256 btsLen\n  ) internal pure {\n    // Exploiting the fact that 'tgt' was the last thing to be allocated,\n    // we can write entire words, and just overwrite any excess.\n    assembly {\n      let words := div(add(btsLen, 31), 32)\n      let sourcePointer := sourceBytes\n      let destinationPointer := add(destinationBytes, 32)\n      for {\n        let i := 0\n      } lt(i, words) {\n        i := add(i, 1)\n      } {\n        let offset := mul(i, 32)\n        mstore(add(destinationPointer, offset), mload(add(sourcePointer, offset)))\n      }\n      mstore(add(destinationBytes, add(32, mload(destinationBytes))), 0)\n    }\n  }\n\n  // Check that an Item is valid.\n  function _validate(Item memory self) private pure returns (bool ret) {\n    // Check that RLP is well-formed.\n    uint256 b0;\n    uint256 b1;\n    uint256 memPtr = self._unsafe_memPtr;\n    assembly {\n      b0 := byte(0, mload(memPtr))\n      b1 := byte(1, mload(memPtr))\n    }\n    if (b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START) return false;\n    return true;\n  }\n\n  function rlpBytesToUint256(bytes memory source) internal pure returns (uint256 result) {\n    return Rlp.toUint(Rlp.toItem(source));\n  }\n}\n"
    },
    "contracts/oracles/keydonix/UQ112x112.sol": {
      "content": "pragma solidity >=0.8.0;\n\n// https://raw.githubusercontent.com/Uniswap/uniswap-v2-core/master/contracts/libraries/UQ112x112.sol\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n  uint224 constant Q112 = 2**112;\n\n  // encode a uint112 as a UQ112x112\n  function encode(uint112 y) internal pure returns (uint224 z) {\n    z = uint224(y) * Q112; // never overflows\n  }\n\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n    z = x / uint224(y);\n  }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/compound/IFuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IFuseFeeDistributor {\n  function minBorrowEth() external view returns (uint256);\n\n  function maxSupplyEth() external view returns (uint256);\n\n  function maxUtilizationRate() external view returns (uint256);\n\n  function interestFeeRate() external view returns (uint256);\n\n  function comptrollerImplementationWhitelist(address oldImplementation, address newImplementation)\n    external\n    view\n    returns (bool);\n\n  function cErc20DelegateWhitelist(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign\n  ) external view returns (bool);\n\n  function cEtherDelegateWhitelist(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign\n  ) external view returns (bool);\n\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address);\n\n  function latestCErc20Delegate(address oldImplementation)\n    external\n    view\n    returns (\n      address cErc20Delegate,\n      bool allowResign,\n      bytes memory becomeImplementationData\n    );\n\n  function latestCEtherDelegate(address oldImplementation)\n    external\n    view\n    returns (\n      address cEtherDelegate,\n      bool allowResign,\n      bytes memory becomeImplementationData\n    );\n\n  function deployCEther(bytes calldata constructorData) external returns (address);\n\n  function deployCErc20(bytes calldata constructorData) external returns (address);\n\n  fallback() external payable;\n\n  receive() external payable;\n}\n"
    },
    "contracts/external/compound/ICToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\ninterface ICToken {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function fuseAdminHasRights() external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function comptroller() external view returns (address);\n\n  function adminFeeMantissa() external view returns (uint256);\n\n  function fuseFeeMantissa() external view returns (uint256);\n\n  function reserveFactorMantissa() external view returns (uint256);\n\n  function totalReserves() external view returns (uint256);\n\n  function totalAdminFees() external view returns (uint256);\n\n  function totalFuseFees() external view returns (uint256);\n\n  function isCToken() external view returns (bool);\n\n  function isCEther() external view returns (bool);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function borrowRatePerBlock() external view returns (uint256);\n\n  function supplyRatePerBlock() external view returns (uint256);\n\n  function totalBorrowsCurrent() external returns (uint256);\n\n  function borrowBalanceStored(address account) external view returns (uint256);\n\n  function exchangeRateStored() external view returns (uint256);\n\n  function getCash() external view returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/external/compound/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\n\ninterface IPriceOracle {\n  /**\n   * @notice Get the underlying price of a cToken asset\n   * @param cToken The cToken to get the underlying price of\n   * @return The underlying asset price mantissa (scaled by 1e18).\n   *  Zero means the price is unavailable.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view returns (uint256);\n}\n"
    },
    "contracts/external/compound/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\nimport \"../../oracles/keydonix/UniswapOracle.sol\";\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface ICErc20 is ICToken {\n  function underlying() external view returns (address);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    ICToken cTokenCollateral\n  ) external returns (uint256);\n\n  function liquidateBorrowWithPriceProof(\n    address borrower,\n    uint256 repayAmount,\n    ICToken cTokenCollateral,\n    UniswapOracle.ProofData calldata repaidProofData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external returns (uint256);\n}\n"
    },
    "contracts/oracles/BasePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../external/compound/IPriceOracle.sol\";\n\n/**\n * @title BasePriceOracle\n * @notice Returns prices of underlying tokens directly without the caller having to specify a cToken address.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface BasePriceOracle is IPriceOracle {\n  /**\n   * @notice Get the price of an underlying asset.\n   * @param underlying The underlying asset to get the price of.\n   * @return The underlying asset price in ETH as a mantissa (scaled by 1e18).\n   * Zero means the price is unavailable.\n   */\n  function price(address underlying) external view returns (uint256);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/compound/RewardsDistributorStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\n\ncontract RewardsDistributorDelegatorStorage {\n  /// @notice Administrator for this contract\n  address public admin;\n\n  /// @notice Pending administrator for this contract\n  address public pendingAdmin;\n\n  /// @notice Active brains of RewardsDistributor\n  address public implementation;\n}\n\n/**\n * @title Storage for RewardsDistributorDelegate\n * @notice For future upgrades, do not change RewardsDistributorDelegateStorageV1. Create a new\n * contract which implements RewardsDistributorDelegateStorageV1 and following the naming convention\n * RewardsDistributorDelegateStorageVX.\n */\ncontract RewardsDistributorDelegateStorageV1 is RewardsDistributorDelegatorStorage {\n  /// @dev The token to reward (i.e., COMP)\n  address public rewardToken;\n\n  struct CompMarketState {\n    // The market's last updated compBorrowIndex or compSupplyIndex\n    uint224 index;\n    // The block number the index was last updated at\n    uint32 block;\n  }\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compSupplySpeeds;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint256) public compBorrowSpeeds;\n\n  /// @notice The COMP market supply state for each market\n  mapping(address => CompMarketState) public compSupplyState;\n\n  /// @notice The COMP market borrow state for each market\n  mapping(address => CompMarketState) public compBorrowState;\n\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compSupplierIndex;\n\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n  mapping(address => mapping(address => uint256)) public compBorrowerIndex;\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  mapping(address => uint256) public compAccrued;\n\n  /// @notice The portion of COMP that each contributor receives per block\n  mapping(address => uint256) public compContributorSpeeds;\n\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\n  mapping(address => uint256) public lastContributorBlock;\n}\n"
    },
    "contracts/compound/PluginRewardsDistributorDelegate.sol": {
      "content": "pragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"./ExponentialNoError.sol\";\nimport \"./Comptroller.sol\";\nimport \"./RewardsDistributorStorage.sol\";\n\ninterface ICErc20Plugin {\n  function claim() external;\n}\n\n/**\n * @title PluginRewardsDistributorDelegate (Distribution logic based on rewards accrued to CErc20PluginDelegate)\n * @author Joey Santoro, inspired by RewardDistributorDelegate\n *\n * Instead of having a hardcoded compSpeed, the PluginRewardsDistributor incentivizes suppliers based on a plugin's rewards\n * It pulls the actual accrued amounts from the cToken based on the plugin distribution.\n */\ncontract PluginRewardsDistributorDelegate is RewardsDistributorDelegateStorageV1, ExponentialNoError {\n  /// @dev Notice that this contract is a RewardsDistributor\n  bool public constant isRewardsDistributor = true;\n\n  /// @notice Emitted when COMP is distributed to a supplier\n  event DistributedSupplierComp(\n    CToken indexed cToken,\n    address indexed supplier,\n    uint256 compDelta,\n    uint256 compSupplyIndex\n  );\n\n  /// @notice The initial COMP index for a market\n  uint224 public constant compInitialIndex = 1e36;\n\n  /// @dev Intitializer to set admin to caller and set reward token\n  function initialize(address _rewardToken) external {\n    require(msg.sender == admin, \"Only admin can initialize.\");\n    require(rewardToken == address(0), \"Already initialized.\");\n    require(_rewardToken != address(0), \"Cannot initialize reward token to the zero address.\");\n    rewardToken = _rewardToken;\n  }\n\n  /*** Comp Distribution ***/\n\n  /**\n   * @notice Check the cToken before adding\n   * @param cToken The market to add\n   */\n  function checkCToken(CToken cToken) internal view {\n    // Make sure cToken is listed\n    Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n    (bool isListed, ) = comptroller.markets(address(cToken));\n    require(isListed == true, \"comp market is not listed\");\n\n    // Make sure distributor is added\n    bool distributorAdded = false;\n    address[] memory distributors = comptroller.getRewardsDistributors();\n    for (uint256 i = 0; i < distributors.length; i++) if (distributors[i] == address(this)) distributorAdded = true;\n    require(distributorAdded == true, \"distributor not added\");\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the supply index\n   * @param cToken The market whose supply index to update\n   * @dev pulls COMP from CToken, requires ERC-20 approval within token\n   */\n  function updateCompSupplyIndex(address cToken) internal {\n    ICErc20Plugin(cToken).claim();\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n    uint256 compAccrued_ = comp.balanceOf(cToken);\n    if (compAccrued_ > 0) {\n      comp.transferFrom(cToken, address(this), compAccrued_);\n      uint256 supplyTokens = CToken(cToken).totalSupply();\n      Double memory ratio = supplyTokens > 0 ? fraction(compAccrued_, supplyTokens) : Double({ mantissa: 0 });\n      Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\n      compSupplyState[cToken] = CompMarketState({\n        index: safe224(index.mantissa, \"new index exceeds 224 bits\"),\n        block: 0\n      });\n    }\n  }\n\n  /**\n   * @notice Add market for initial rewards\n   * @param cToken The market to add\n   */\n  function _addMarketForRewards(address cToken) public {\n    require(msg.sender == admin, \"only admin can set comp speed\");\n    compSupplyState[cToken] = CompMarketState({ index: compInitialIndex, block: 0 });\n\n    // Add to allMarkets array\n    allMarkets.push(CToken(cToken));\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n   * @param cToken The market in which the supplier is interacting\n   * @param supplier The address of the supplier to distribute COMP to\n   */\n  function distributeSupplierComp(address cToken, address supplier) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    Double memory supplyIndex = Double({ mantissa: supplyState.index });\n    Double memory supplierIndex = Double({ mantissa: compSupplierIndex[cToken][supplier] });\n    compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n    if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n      supplierIndex.mantissa = compInitialIndex;\n    }\n\n    Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n    uint256 supplierTokens = CToken(cToken).balanceOf(supplier);\n    uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\n    uint256 supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n    compAccrued[supplier] = supplierAccrued;\n    emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, supplier);\n    }\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) external {\n    // no-op\n  }\n\n  /**\n   * @notice Keeps the flywheel moving pre-transfer and pre-seize\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param src The account which sources the tokens\n   * @param dst The account which receives the tokens\n   */\n  function flywheelPreTransferAction(\n    address cToken,\n    address src,\n    address dst\n  ) external {\n    if (compSupplyState[cToken].index > 0) {\n      updateCompSupplyIndex(cToken);\n      distributeSupplierComp(cToken, src);\n      distributeSupplierComp(cToken, dst);\n    }\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n   * @param holder The address to claim COMP for\n   */\n  function claimRewards(address holder) public {\n    return claimRewards(holder, allMarkets);\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n   * @param holder The address to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   */\n  function claimRewards(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimRewards(holders, cTokens, true, true);\n  }\n\n  /**\n   * @notice Claim all comp accrued by the holders\n   * @param holders The addresses to claim COMP for\n   * @param cTokens The list of markets to claim COMP in\n   * @param borrowers Whether or not to claim COMP earned by borrowing\n   * @param suppliers Whether or not to claim COMP earned by supplying\n   */\n  function claimRewards(\n    address[] memory holders,\n    CToken[] memory cTokens,\n    bool borrowers,\n    bool suppliers\n  ) public {\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      CToken cToken = cTokens[i];\n      if (suppliers == true && compSupplyState[address(cToken)].index > 0) {\n        updateCompSupplyIndex(address(cToken));\n        for (uint256 j = 0; j < holders.length; j++) {\n          distributeSupplierComp(address(cToken), holders[j]);\n        }\n      }\n    }\n    for (uint256 j = 0; j < holders.length; j++) {\n      compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n    }\n  }\n\n  /**\n   * @notice Transfer COMP to the user\n   * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n   * @param user The address of the user to transfer COMP to\n   * @param amount The amount of COMP to (possibly) transfer\n   * @return The amount of COMP which was NOT transferred to the user\n   */\n  function grantCompInternal(address user, uint256 amount) internal returns (uint256) {\n    EIP20NonStandardInterface comp = EIP20NonStandardInterface(rewardToken);\n    uint256 compRemaining = comp.balanceOf(address(this));\n    if (amount > 0 && amount <= compRemaining) {\n      comp.transfer(user, amount);\n      return 0;\n    }\n    return amount;\n  }\n\n  /*** Comp Distribution Admin ***/\n\n  /*** Helper Functions */\n  /**\n   * @notice Returns an array of all markets.\n   */\n  function getAllMarkets() external view returns (CToken[] memory) {\n    return allMarkets;\n  }\n}\n"
    },
    "contracts/compound/RewardsDistributorDelegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./RewardsDistributorStorage.sol\";\n\ncontract RewardsDistributorDelegator is RewardsDistributorDelegatorStorage {\n  /// @notice Emitted when implementation is changed\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  constructor(\n    address admin_,\n    address rewardToken_,\n    address implementation_\n  ) {\n    // Admin set to msg.sender for initialization\n    admin = msg.sender;\n\n    delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address)\", rewardToken_));\n\n    _setImplementation(implementation_);\n\n    admin = admin_;\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   */\n  function _setImplementation(address implementation_) public {\n    require(msg.sender == admin, \"RewardsDistributorDelegator::_setImplementation: admin only\");\n    require(\n      implementation_ != address(0),\n      \"RewardsDistributorDelegator::_setImplementation: invalid implementation address\"\n    );\n\n    address oldImplementation = implementation;\n    implementation = implementation_;\n\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param callee The contract to delegatecall\n   * @param data The raw data to delegatecall\n   */\n  function delegateTo(address callee, bytes memory data) internal {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Delegates the empty call data execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  receive() external payable {\n    _fallback(\"\");\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * It returns to the external caller whatever the implementation returns\n   * or forwards reverts.\n   */\n  fallback() external payable {\n    _fallback(msg.data);\n  }\n\n  function _fallback(bytes memory data) internal {\n    // delegate all other functions to current implementation\n    (bool success, ) = implementation.delegatecall(data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/compound/Lens/CompoundLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../CErc20.sol\";\nimport \"../CToken.sol\";\nimport \"../Comptroller.sol\";\nimport \"../EIP20Interface.sol\";\nimport \"../Governance/GovernorAlpha.sol\";\nimport \"../Governance/Comp.sol\";\n\ncontract CompoundLens {\n  struct CTokenMetadata {\n    address cToken;\n    uint256 exchangeRateCurrent;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 reserveFactorMantissa;\n    uint256 totalBorrows;\n    uint256 totalReserves;\n    uint256 totalSupply;\n    uint256 totalCash;\n    bool isListed;\n    uint256 collateralFactorMantissa;\n    address underlyingAssetAddress;\n    uint256 cTokenDecimals;\n    uint256 underlyingDecimals;\n  }\n\n  function cTokenMetadata(CToken cToken) public returns (CTokenMetadata memory) {\n    uint256 exchangeRateCurrent = cToken.exchangeRateCurrent();\n    Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n    (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cToken));\n    address underlyingAssetAddress;\n    uint256 underlyingDecimals;\n\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\n      underlyingAssetAddress = address(0);\n      underlyingDecimals = 18;\n    } else {\n      CErc20 cErc20 = CErc20(address(cToken));\n      underlyingAssetAddress = cErc20.underlying();\n      underlyingDecimals = EIP20Interface(cErc20.underlying()).decimals();\n    }\n\n    return\n      CTokenMetadata({\n        cToken: address(cToken),\n        exchangeRateCurrent: exchangeRateCurrent,\n        supplyRatePerBlock: cToken.supplyRatePerBlock(),\n        borrowRatePerBlock: cToken.borrowRatePerBlock(),\n        reserveFactorMantissa: cToken.reserveFactorMantissa(),\n        totalBorrows: cToken.totalBorrows(),\n        totalReserves: cToken.totalReserves(),\n        totalSupply: cToken.totalSupply(),\n        totalCash: cToken.getCash(),\n        isListed: isListed,\n        collateralFactorMantissa: collateralFactorMantissa,\n        underlyingAssetAddress: underlyingAssetAddress,\n        cTokenDecimals: cToken.decimals(),\n        underlyingDecimals: underlyingDecimals\n      });\n  }\n\n  function cTokenMetadataAll(CToken[] calldata cTokens) external returns (CTokenMetadata[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenMetadata[] memory res = new CTokenMetadata[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenMetadata(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct CTokenBalances {\n    address cToken;\n    uint256 balanceOf;\n    uint256 borrowBalanceCurrent;\n    uint256 balanceOfUnderlying;\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n  }\n\n  function cTokenBalances(CToken cToken, address account) public returns (CTokenBalances memory) {\n    uint256 balanceOf = cToken.balanceOf(account);\n    uint256 borrowBalanceCurrent = cToken.borrowBalanceCurrent(account);\n    uint256 balanceOfUnderlying = cToken.balanceOfUnderlying(account);\n    uint256 tokenBalance;\n    uint256 tokenAllowance;\n\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\n      tokenBalance = account.balance;\n      tokenAllowance = account.balance;\n    } else {\n      CErc20 cErc20 = CErc20(address(cToken));\n      EIP20Interface underlying = EIP20Interface(cErc20.underlying());\n      tokenBalance = underlying.balanceOf(account);\n      tokenAllowance = underlying.allowance(account, address(cToken));\n    }\n\n    return\n      CTokenBalances({\n        cToken: address(cToken),\n        balanceOf: balanceOf,\n        borrowBalanceCurrent: borrowBalanceCurrent,\n        balanceOfUnderlying: balanceOfUnderlying,\n        tokenBalance: tokenBalance,\n        tokenAllowance: tokenAllowance\n      });\n  }\n\n  function cTokenBalancesAll(CToken[] calldata cTokens, address account) external returns (CTokenBalances[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenBalances[] memory res = new CTokenBalances[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenBalances(cTokens[i], account);\n    }\n    return res;\n  }\n\n  struct CTokenUnderlyingPrice {\n    address cToken;\n    uint256 underlyingPrice;\n  }\n\n  function cTokenUnderlyingPrice(CToken cToken) public returns (CTokenUnderlyingPrice memory) {\n    Comptroller comptroller = Comptroller(address(cToken.comptroller()));\n    PriceOracle priceOracle = comptroller.oracle();\n\n    return CTokenUnderlyingPrice({ cToken: address(cToken), underlyingPrice: priceOracle.getUnderlyingPrice(cToken) });\n  }\n\n  function cTokenUnderlyingPriceAll(CToken[] calldata cTokens) external returns (CTokenUnderlyingPrice[] memory) {\n    uint256 cTokenCount = cTokens.length;\n    CTokenUnderlyingPrice[] memory res = new CTokenUnderlyingPrice[](cTokenCount);\n    for (uint256 i = 0; i < cTokenCount; i++) {\n      res[i] = cTokenUnderlyingPrice(cTokens[i]);\n    }\n    return res;\n  }\n\n  struct AccountLimits {\n    CToken[] markets;\n    uint256 liquidity;\n    uint256 shortfall;\n  }\n\n  function getAccountLimits(Comptroller comptroller, address account) public returns (AccountLimits memory) {\n    (uint256 errorCode, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(account);\n    require(errorCode == 0);\n\n    return AccountLimits({ markets: comptroller.getAssetsIn(account), liquidity: liquidity, shortfall: shortfall });\n  }\n\n  struct GovReceipt {\n    uint256 proposalId;\n    bool hasVoted;\n    bool support;\n    uint96 votes;\n  }\n\n  function getGovReceipts(\n    GovernorAlpha governor,\n    address voter,\n    uint256[] memory proposalIds\n  ) public view returns (GovReceipt[] memory) {\n    uint256 proposalCount = proposalIds.length;\n    GovReceipt[] memory res = new GovReceipt[](proposalCount);\n    for (uint256 i = 0; i < proposalCount; i++) {\n      GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n      res[i] = GovReceipt({\n        proposalId: proposalIds[i],\n        hasVoted: receipt.hasVoted,\n        support: receipt.support,\n        votes: receipt.votes\n      });\n    }\n    return res;\n  }\n\n  struct GovProposal {\n    uint256 proposalId;\n    address proposer;\n    uint256 eta;\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    uint256 startBlock;\n    uint256 endBlock;\n    uint256 forVotes;\n    uint256 againstVotes;\n    bool canceled;\n    bool executed;\n  }\n\n  function setProposal(\n    GovProposal memory res,\n    GovernorAlpha governor,\n    uint256 proposalId\n  ) internal view {\n    (\n      ,\n      address proposer,\n      uint256 eta,\n      uint256 startBlock,\n      uint256 endBlock,\n      uint256 forVotes,\n      uint256 againstVotes,\n      bool canceled,\n      bool executed\n    ) = governor.proposals(proposalId);\n    res.proposalId = proposalId;\n    res.proposer = proposer;\n    res.eta = eta;\n    res.startBlock = startBlock;\n    res.endBlock = endBlock;\n    res.forVotes = forVotes;\n    res.againstVotes = againstVotes;\n    res.canceled = canceled;\n    res.executed = executed;\n  }\n\n  function getGovProposals(GovernorAlpha governor, uint256[] calldata proposalIds)\n    external\n    view\n    returns (GovProposal[] memory)\n  {\n    GovProposal[] memory res = new GovProposal[](proposalIds.length);\n    for (uint256 i = 0; i < proposalIds.length; i++) {\n      (\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n      ) = governor.getActions(proposalIds[i]);\n      res[i] = GovProposal({\n        proposalId: 0,\n        proposer: address(0),\n        eta: 0,\n        targets: targets,\n        values: values,\n        signatures: signatures,\n        calldatas: calldatas,\n        startBlock: 0,\n        endBlock: 0,\n        forVotes: 0,\n        againstVotes: 0,\n        canceled: false,\n        executed: false\n      });\n      setProposal(res[i], governor, proposalIds[i]);\n    }\n    return res;\n  }\n\n  struct CompBalanceMetadata {\n    uint256 balance;\n    uint256 votes;\n    address delegate;\n  }\n\n  function getCompBalanceMetadata(Comp comp, address account) external view returns (CompBalanceMetadata memory) {\n    return\n      CompBalanceMetadata({\n        balance: comp.balanceOf(account),\n        votes: uint256(comp.getCurrentVotes(account)),\n        delegate: comp.delegates(account)\n      });\n  }\n\n  struct CompVotes {\n    uint256 blockNumber;\n    uint256 votes;\n  }\n\n  function getCompVotes(\n    Comp comp,\n    address account,\n    uint32[] calldata blockNumbers\n  ) external view returns (CompVotes[] memory) {\n    CompVotes[] memory res = new CompVotes[](blockNumbers.length);\n    for (uint256 i = 0; i < blockNumbers.length; i++) {\n      res[i] = CompVotes({\n        blockNumber: uint256(blockNumbers[i]),\n        votes: uint256(comp.getPriorVotes(account, blockNumbers[i]))\n      });\n    }\n    return res;\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/compound/Governance/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract GovernorAlpha {\n  /// @notice The name of this contract\n  string public constant name = \"Compound Governor Alpha\";\n\n  /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  function quorumVotes() public pure returns (uint256) {\n    return 400000e18;\n  } // 400,000 = 4% of Comp\n\n  /// @notice The number of votes required in order for a voter to become a proposer\n  function proposalThreshold() public pure returns (uint256) {\n    return 100000e18;\n  } // 100,000 = 1% of Comp\n\n  /// @notice The maximum number of actions that can be included in a proposal\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  } // 10 actions\n\n  /// @notice The delay before voting on a proposal may take place, once proposed\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  } // 1 block\n\n  /// @notice The duration of voting on a proposal, in blocks\n  function votingPeriod() public pure returns (uint256) {\n    return 17280;\n  } // ~3 days in blocks (assuming 15s blocks)\n\n  /// @notice The address of the Compound Protocol Timelock\n  TimelockInterface public timelock;\n\n  /// @notice The address of the Compound governance token\n  CompInterface public comp;\n\n  /// @notice The address of the Governor Guardian\n  address public guardian;\n\n  /// @notice The total number of proposals\n  uint256 public proposalCount;\n\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The block at which voting begins: holders must delegate their votes prior to this block\n    uint256 startBlock;\n    // The block at which voting ends: votes must be cast prior to this block\n    uint256 endBlock;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    // Whether or not a vote has been cast\n    bool hasVoted;\n    // Whether or not the voter supports the proposal\n    bool support;\n    // The number of votes the voter had, which were cast\n    uint96 votes;\n  }\n\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState {\n    Pending,\n    Active,\n    Canceled,\n    Defeated,\n    Succeeded,\n    Queued,\n    Expired,\n    Executed\n  }\n\n  /// @notice The official record of all proposals ever proposed\n  mapping(uint256 => Proposal) public proposals;\n\n  /// @notice The latest proposal for each proposer\n  mapping(address => uint256) public latestProposalIds;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the ballot struct used by the contract\n  bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  constructor(\n    address timelock_,\n    address comp_,\n    address guardian_\n  ) {\n    timelock = TimelockInterface(timelock_);\n    comp = CompInterface(comp_);\n    guardian = guardian_;\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(\n      comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\"\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    Proposal storage newProposal = proposals[proposalCount];\n    newProposal.id = proposalCount;\n    newProposal.proposer = msg.sender;\n    newProposal.eta = 0;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.startBlock = startBlock;\n    newProposal.endBlock = endBlock;\n    newProposal.forVotes = 0;\n    newProposal.againstVotes = 0;\n    newProposal.canceled = false;\n    newProposal.executed = false;\n\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, timelock.delay());\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n      \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\"\n    );\n    timelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \"GovernorAlpha::execute: proposal can only be executed if it is queued\"\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.executeTransaction{ value: proposal.values[i] }(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(),\n      \"GovernorAlpha::cancel: proposer above threshold\"\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i < proposal.targets.length; i++) {\n      timelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number <= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number <= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function castVoteBySig(\n    uint256 proposalId,\n    bool support,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n    );\n    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n    return _castVote(signatory, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function __acceptAdmin() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n    timelock.acceptAdmin();\n  }\n\n  function __abdicate() public {\n    require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n    guardian = address(0);\n  }\n\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n    timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n  }\n\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n    timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"addition overflow\");\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"subtraction underflow\");\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n\ninterface TimelockInterface {\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n\ninterface CompInterface {\n  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/compound/Governance/Comp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract Comp {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Compound\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"COMP\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint256 public constant totalSupply = 10000000e18; // 10 million Comp\n\n  // Allowance amounts on behalf of others\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  // Official record of token balances for each account\n  mapping(address => uint96) internal balances;\n\n  /// @notice A record of each accounts delegate\n  mapping(address => address) public delegates;\n\n  /// @notice A checkpoint for marking number of votes from a given block\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  /// @notice A record of votes checkpoints for each account, by index\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  /// @notice The number of checkpoints for each account\n  mapping(address => uint32) public numCheckpoints;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the delegation struct used by the contract\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  /// @notice A record of states for signing / validating signatures\n  mapping(address => uint256) public nonces;\n\n  /// @notice An event thats emitted when an account changes its delegate\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n  /// @notice An event thats emitted when a delegate account's vote balance changes\n  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n  /// @notice The standard EIP-20 transfer event\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /// @notice The standard EIP-20 approval event\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Construct a new Comp token\n   * @param account The initial account to grant all the tokens\n   */\n  constructor(address account) {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  /**\n   * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n   * @param account The address of the account holding the funds\n   * @param spender The address of the account spending the funds\n   * @return The number of tokens approved\n   */\n  function allowance(address account, address spender) external view returns (uint256) {\n    return allowances[account][spender];\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n   * @dev This will overwrite the approval amount for `spender`\n   *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n   * @param spender The address of the account which may transfer tokens\n   * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n   * @return Whether or not the approval succeeded\n   */\n  function approve(address spender, uint256 rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == type(uint256).max) {\n      amount = type(uint96).max;\n    } else {\n      amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the number of tokens held by the `account`\n   * @param account The address of the account to get the balance of\n   * @return The number of tokens held\n   */\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transfer(address dst, uint256 rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n   * @param src The address of the source account\n   * @param dst The address of the destination account\n   * @param rawAmount The number of tokens to transfer\n   * @return Whether or not the transfer succeeded\n   */\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 rawAmount\n  ) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != type(uint96).max) {\n      uint96 newAllowance = sub96(\n        spenderAllowance,\n        amount,\n        \"Comp::transferFrom: transfer amount exceeds spender allowance\"\n      );\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Delegate votes from `msg.sender` to `delegatee`\n   * @param delegatee The address to delegate votes to\n   */\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  /**\n   * @notice Delegates votes from signatory to `delegatee`\n   * @param delegatee The address to delegate votes to\n   * @param nonce The contract state required to match the signature\n   * @param expiry The time at which to expire the signature\n   * @param v The recovery byte of the signature\n   * @param r Half of the ECDSA signature pair\n   * @param s Half of the ECDSA signature pair\n   */\n  function delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    bytes32 domainSeparator = keccak256(\n      abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this))\n    );\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n    require(block.timestamp <= expiry, \"Comp::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  /**\n   * @notice Gets the current votes balance for `account`\n   * @param account The address to get votes balance\n   * @return The number of current votes for `account`\n   */\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  /**\n   * @notice Determine the prior number of votes for an account as of a block number\n   * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n   * @param account The address of the account to check\n   * @param blockNumber The block number to get the vote balance at\n   * @return The number of votes the account had as of the given block\n   */\n  function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n    require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(\n    address src,\n    address dst,\n    uint96 amount\n  ) internal {\n    require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n    require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n    balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n    balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n    require(n < 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint256) {\n    uint256 chainId;\n    assembly {\n      chainId := chainid()\n    }\n    return chainId;\n  }\n}\n"
    },
    "contracts/compound/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title Reservoir Contract\n * @notice Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n  /// @notice The block number when the Reservoir started (immutable)\n  uint256 public dripStart;\n\n  /// @notice Tokens per block that to drip to target (immutable)\n  uint256 public dripRate;\n\n  /// @notice Reference to token to drip (immutable)\n  EIP20Interface public token;\n\n  /// @notice Target to receive dripped tokens (immutable)\n  address public target;\n\n  /// @notice Amount that has already been dripped\n  uint256 public dripped;\n\n  /**\n   * @notice Constructs a Reservoir\n   * @param dripRate_ Numer of tokens per block to drip\n   * @param token_ The token to drip\n   * @param target_ The recipient of dripped tokens\n   */\n  constructor(\n    uint256 dripRate_,\n    EIP20Interface token_,\n    address target_\n  ) {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n   * @notice Drips the maximum amount of tokens to match the drip rate since inception\n   * @dev Note: this will only drip up to the amount of tokens available.\n   * @return The amount of tokens dripped in this call\n   */\n  function drip() public returns (uint256) {\n    // First, read storage into memory\n    EIP20Interface token_ = token;\n    uint256 reservoirBalance_ = token_.balanceOf(address(this)); // TODO: Verify this is a static call\n    uint256 dripRate_ = dripRate;\n    uint256 dripStart_ = dripStart;\n    uint256 dripped_ = dripped;\n    address target_ = target;\n    uint256 blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint256 dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint256 deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint256 toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint256 drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.transfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n    return c;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n\nimport \"./EIP20Interface.sol\";\n"
    },
    "contracts/compound/IERC4626.sol": {
      "content": "pragma solidity >=0.8.0;\npragma experimental ABIEncoderV2;\n\nimport { EIP20Interface } from \"./EIP20Interface.sol\";\n\ninterface IERC4626 is EIP20Interface {\n  /*///////////////////////////////////////////////////////////////\n                                Events\n    //////////////////////////////////////////////////////////////*/\n\n  event Deposit(address indexed from, address indexed to, uint256 value);\n\n  event Withdraw(address indexed from, address indexed to, uint256 value);\n\n  /*///////////////////////////////////////////////////////////////\n                            Mutable Functions\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n      @notice Deposit a specific amount of underlying tokens.\n      @param to The address to receive shares corresponding to the deposit\n      @param underlyingAmount The amount of the underlying token to deposit.\n      @return shares The shares in the vault credited to `to`\n    */\n  function deposit(address to, uint256 underlyingAmount) external returns (uint256 shares);\n\n  /**\n      @notice Mint an exact amount of shares for a variable amount of underlying tokens.\n      @param to The address to receive shares corresponding to the mint.\n      @param shareAmount The amount of vault shares to mint.\n      @return underlyingAmount The amount of the underlying tokens deposited from the mint call.\n    */\n  function mint(address to, uint256 shareAmount) external returns (uint256 underlyingAmount);\n\n  /**\n      @notice Withdraw a specific amount of underlying tokens.\n      @param from The address to burn shares from corresponding to the withdrawal.\n      @param to The address to receive underlying corresponding to the withdrawal.\n      @param underlyingAmount The amount of the underlying token to withdraw.\n      @return shares The shares in the vault burned from sender\n    */\n  function withdraw(\n    address from,\n    address to,\n    uint256 underlyingAmount\n  ) external returns (uint256 shares);\n\n  /**\n      @notice Redeem a specific amount of shares for underlying tokens.\n      @param from The address to burn shares from corresponding to the redemption.\n      @param to The address to receive underlying corresponding to the redemption.\n      @param shareAmount The amount of shares to redeem.\n      @return value The underlying amount transferred to `to`.\n    */\n  function redeem(\n    address from,\n    address to,\n    uint256 shareAmount\n  ) external returns (uint256 value);\n\n  /*///////////////////////////////////////////////////////////////\n                            View Functions\n    //////////////////////////////////////////////////////////////*/\n\n  /** \n      @notice The underlying token the Vault accepts.\n      @return the ERC20 underlying implementation address.\n    */\n  function underlying() external view returns (EIP20Interface);\n\n  /** \n      @notice Returns a user's Vault balance in underlying tokens.\n      @param user The user to get the underlying balance of.\n      @return balance The user's Vault balance in underlying tokens.\n    */\n  function balanceOfUnderlying(address user) external view returns (uint256 balance);\n\n  /** \n      @notice Calculates the total amount of underlying tokens the Vault manages.\n      @return The total amount of underlying tokens the Vault manages.\n    */\n  function totalUnderlying() external view returns (uint256);\n\n  /** \n      @notice Returns the value in underlying terms of one vault token. \n     */\n  function exchangeRate() external view returns (uint256);\n\n  /**\n      @notice Returns the amount of vault tokens that would be obtained if depositing a given amount of underlying tokens in a `deposit` call.\n      @param underlyingAmount the input amount of underlying tokens\n      @return shareAmount the corresponding amount of shares out from a deposit call with `underlyingAmount` in\n     */\n  function previewDeposit(uint256 underlyingAmount) external view returns (uint256 shareAmount);\n\n  /**\n      @notice Returns the amount of underlying tokens that would be deposited if minting a given amount of shares in a `mint` call.\n      @param shareAmount the amount of shares from a mint call.\n      @return underlyingAmount the amount of underlying tokens corresponding to the mint call\n     */\n  function previewMint(uint256 shareAmount) external view returns (uint256 underlyingAmount);\n\n  /**\n      @notice Returns the amount of vault tokens that would be burned if withdrawing a given amount of underlying tokens in a `withdraw` call.\n      @param underlyingAmount the input amount of underlying tokens\n      @return shareAmount the corresponding amount of shares out from a withdraw call with `underlyingAmount` in\n     */\n  function previewWithdraw(uint256 underlyingAmount) external view returns (uint256 shareAmount);\n\n  /**\n      @notice Returns the amount of underlying tokens that would be obtained if redeeming a given amount of shares in a `redeem` call.\n      @param shareAmount the amount of shares from a redeem call.\n      @return underlyingAmount the amount of underlying tokens corresponding to the redeem call\n     */\n  function previewRedeem(uint256 shareAmount) external view returns (uint256 underlyingAmount);\n}\n"
    },
    "contracts/compound/CErc20PluginDelegate.sol": {
      "content": "pragma solidity >=0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CErc20Delegate.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./IERC4626.sol\";\n\n/**\n * @title Rari's CErc20Plugin's Contract\n * @notice CToken which outsources token logic to a plugin\n * @author Joey Santoro\n *\n * CErc20PluginDelegate deposits and withdraws from a plugin conract\n * It is also capable of delegating reward functionality to a PluginRewardsDistributor\n */\ncontract CErc20PluginDelegate is CErc20Delegate {\n  /**\n   * @notice Plugin address\n   */\n  IERC4626 public plugin;\n\n  uint256 public constant PRECISION = 1e18;\n\n  /**\n   * @notice Delegate interface to become the implementation\n   * @param data The encoded arguments for becoming\n   */\n  function _becomeImplementation(bytes calldata data) external virtual override {\n    require(msg.sender == address(this) || hasAdminRights());\n\n    address _plugin = abi.decode(data, (address));\n\n    require(_plugin != address(0), \"0 addr\");\n\n    if (address(plugin) != address(0)) {\n      plugin.redeem(address(this), address(this), plugin.balanceOf(address(this)));\n    }\n\n    plugin = IERC4626(_plugin);\n\n    uint256 amount = EIP20Interface(underlying).balanceOf(address(this));\n    if (amount != 0) {\n      deposit(amount);\n    }\n  }\n\n  /*** CToken Overrides ***/\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of the plugin in terms of the underlying\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view override returns (uint256) {\n    return plugin.balanceOfUnderlying(address(this));\n  }\n\n  /**\n   * @notice Transfer the underlying to the cToken and trigger a deposit\n   * @param from Address to transfer funds from\n   * @param amount Amount of underlying to transfer\n   * @return The actual amount that is transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Perform the EIP-20 transfer in\n    require(EIP20Interface(underlying).transferFrom(from, address(this), amount), \"send fail\");\n\n    deposit(amount);\n    return amount;\n  }\n\n  /**\n   * @notice Deposit the underlying in the plugin\n   * @param amount Amount of underlying to deposit\n   */\n  function deposit(uint256 amount) internal {\n    EIP20Interface(underlying).approve(address(plugin), amount);\n\n    plugin.deposit(address(this), amount);\n  }\n\n  /**\n   * @notice Transfer the underlying from plugin to destination\n   * @param to Address to transfer funds to\n   * @param amount Amount of underlying to transfer\n   */\n  function doTransferOut(address payable to, uint256 amount) internal {\n    plugin.withdraw(address(this), to, amount);\n  }\n}\n"
    },
    "contracts/compound/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CErc20.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CDelegateInterface, CErc20 {\n  /**\n   * @notice Construct an empty delegate\n   */\n  constructor() {}\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes calldata data) external virtual override {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n    // Make sure admin storage is set up correctly\n    __admin = payable(0);\n    __adminHasRights = false;\n    __fuseAdminHasRights = false;\n  }\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() internal virtual {\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n  }\n\n  /**\n   * @dev Internal function to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationInternal(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) internal {\n    // Check whitelist\n    require(fuseAdmin.cErc20DelegateWhitelist(implementation, implementation_, allowResign), \"!impl\");\n\n    // Call _resignImplementation internally (this delegate's code)\n    if (allowResign) _resignImplementation();\n\n    // Get old implementation\n    address oldImplementation = implementation;\n\n    // Store new implementation\n    implementation = implementation_;\n\n    // Call _becomeImplementation externally (delegating to new delegate's code)\n    _functionCall(\n      address(this),\n      abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData),\n      \"!become\"\n    );\n\n    // Emit event\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(\n    address implementation_,\n    bool allowResign,\n    bytes calldata becomeImplementationData\n  ) external override {\n    // Check admin rights\n    require(hasAdminRights(), \"!admin\");\n\n    // Set implementation\n    _setImplementationInternal(implementation_, allowResign, becomeImplementationData);\n  }\n\n  /**\n   * @notice Function called before all delegator functions\n   * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n   */\n  function _prepare() external payable override {\n    if (msg.sender != address(this) && ComptrollerV3Storage(address(comptroller)).autoImplementation()) {\n      (address latestCErc20Delegate, bool allowResign, bytes memory becomeImplementationData) = fuseAdmin\n        .latestCErc20Delegate(implementation);\n      if (implementation != latestCErc20Delegate)\n        _setImplementationInternal(latestCErc20Delegate, allowResign, becomeImplementationData);\n    }\n  }\n}\n"
    },
    "contracts/compound/CDelegateInterface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ncontract CDelegationStorage {\n  /**\n   * @notice Implementation address for this contract\n   */\n  address public implementation;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n  /**\n   * @notice Emitted when implementation is changed\n   */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(\n    address implementation_,\n    bool allowResign,\n    bytes calldata becomeImplementationData\n  ) external virtual;\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @dev Should revert if any issues arise which make it unfit for delegation\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes calldata data) external virtual;\n\n  /**\n   * @notice Function called before all delegator functions\n   * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n   */\n  function _prepare() external payable virtual;\n}\n"
    },
    "contracts/compound/CErc20PluginRewardsDelegate.sol": {
      "content": "pragma solidity >=0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CErc20PluginDelegate.sol\";\n\ncontract CErc20PluginRewardsDelegate is CErc20PluginDelegate {\n  /**\n   * @notice Delegate interface to become the implementation\n   * @param data The encoded arguments for becoming\n   */\n  function _becomeImplementation(bytes calldata data) external override {\n    require(msg.sender == address(this) || hasAdminRights());\n\n    (address _plugin, address _rewardsDistributor, address _rewardToken) = abi.decode(\n      data,\n      (address, address, address)\n    );\n\n    require(address(plugin) == address(0), \"plugin\");\n    plugin = IERC4626(_plugin);\n\n    EIP20Interface(_rewardToken).approve(_rewardsDistributor, type(uint256).max);\n  }\n\n  /// @notice A reward token claim function\n  /// to be overriden for use cases where rewardToken needs to be pulled in\n  function claim() external {}\n}\n"
    },
    "contracts/compound/CEtherDelegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CEtherDelegator Contract\n * @notice CTokens which wrap Ether and delegate to an implementation\n * @author Compound\n */\ncontract CEtherDelegator is CDelegationStorage {\n  /**\n   * @notice Construct a new CEther money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param implementation_ The address of the implementation the contract delegates to\n   * @param becomeImplementationData The encoded args for becomeImplementation\n   */\n  constructor(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    address implementation_,\n    bytes memory becomeImplementationData,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) {\n    // First delegate gets to initialize the delegator (i.e. storage contract)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"initialize(address,address,string,string,uint256,uint256)\",\n        comptroller_,\n        interestRateModel_,\n        name_,\n        symbol_,\n        reserveFactorMantissa_,\n        adminFeeMantissa_\n      )\n    );\n\n    // New implementations always get set via the settor (post-initialize)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"_setImplementationSafe(address,bool,bytes)\",\n        implementation_,\n        false,\n        becomeImplementationData\n      )\n    );\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param callee The contract to delegatecall\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return returnData;\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   */\n  receive() external payable {}\n\n  fallback() external payable {\n    // Check for automatic implementation\n    delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n    // delegate all other functions to current implementation\n    (bool success, ) = implementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/FuseFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\";\nimport \"./compound/CEtherDelegator.sol\";\nimport \"./compound/CErc20Delegator.sol\";\n\n/**\n * @title FuseFeeDistributor\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseFeeDistributor controls and receives protocol fees from Fuse pools and relays admin actions to Fuse pools.\n */\ncontract FuseFeeDistributor is Initializable, OwnableUpgradeable {\n  using AddressUpgradeable for address;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Initializer that sets initial values of state variables.\n   * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function initialize(uint256 _defaultInterestFeeRate) public initializer {\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    __Ownable_init();\n    defaultInterestFeeRate = _defaultInterestFeeRate;\n    maxSupplyEth = type(uint256).max;\n    maxUtilizationRate = type(uint256).max;\n  }\n\n  /**\n   * @notice The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  uint256 public defaultInterestFeeRate;\n\n  /**\n   * @dev Sets the default proportion of Fuse pool interest taken as a protocol fee.\n   * @param _defaultInterestFeeRate The default proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function _setDefaultInterestFeeRate(uint256 _defaultInterestFeeRate) external onlyOwner {\n    require(_defaultInterestFeeRate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    defaultInterestFeeRate = _defaultInterestFeeRate;\n  }\n\n  /**\n   * @dev Withdraws accrued fees on interest.\n   * @param erc20Contract The ERC20 token address to withdraw. Set to the zero address to withdraw ETH.\n   */\n  function _withdrawAssets(address erc20Contract) external {\n    if (erc20Contract == address(0)) {\n      uint256 balance = address(this).balance;\n      require(balance > 0, \"No balance available to withdraw.\");\n      (bool success, ) = owner().call{ value: balance }(\"\");\n      require(success, \"Failed to transfer ETH balance to msg.sender.\");\n    } else {\n      IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n      uint256 balance = token.balanceOf(address(this));\n      require(balance > 0, \"No token balance available to withdraw.\");\n      token.safeTransfer(owner(), balance);\n    }\n  }\n\n  /**\n   * @dev Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n   */\n  uint256 public minBorrowEth;\n\n  /**\n   * @dev Maximum supply balance (in ETH) per user per Fuse pool asset.\n   * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n   */\n  uint256 public maxSupplyEth;\n\n  /**\n   * @dev Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n   * No longer used as of `Rari-Capital/compound-protocol` version `fuse-v1.1.0`.\n   */\n  uint256 public maxUtilizationRate;\n\n  /**\n   * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n   * @param _minBorrowEth Minimum borrow balance (in ETH) per user per Fuse pool asset (only checked on new borrows, not redemptions).\n   * @param _maxSupplyEth Maximum supply balance (in ETH) per user per Fuse pool asset.\n   * @param _maxUtilizationRate Maximum utilization rate (scaled by 1e18) for Fuse pool assets (only checked on new borrows, not redemptions).\n   */\n  function _setPoolLimits(\n    uint256 _minBorrowEth,\n    uint256 _maxSupplyEth,\n    uint256 _maxUtilizationRate\n  ) external onlyOwner {\n    minBorrowEth = _minBorrowEth;\n    maxSupplyEth = _maxSupplyEth;\n    maxUtilizationRate = _maxUtilizationRate;\n  }\n\n  /**\n   * @dev Receives ETH fees.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Sends data to a contract.\n   * @param targets The contracts to which `data` will be sent.\n   * @param data The data to be sent to each of `targets`.\n   */\n  function _callPool(address[] calldata targets, bytes[] calldata data) external onlyOwner {\n    require(targets.length > 0 && targets.length == data.length, \"Array lengths must be equal and greater than 0.\");\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data[i]);\n  }\n\n  /**\n   * @dev Sends data to a contract.\n   * @param targets The contracts to which `data` will be sent.\n   * @param data The data to be sent to each of `targets`.\n   */\n  function _callPool(address[] calldata targets, bytes calldata data) external onlyOwner {\n    require(targets.length > 0, \"No target addresses specified.\");\n    for (uint256 i = 0; i < targets.length; i++) targets[i].functionCall(data);\n  }\n\n  function deployCEther(bytes calldata constructorData) external returns (address) {\n    // Make sure comptroller == msg.sender\n    address comptroller = abi.decode(constructorData[0:32], (address));\n    require(comptroller == msg.sender, \"Comptroller is not sender.\");\n    // Deploy CEtherDelegator using msg.sender, underlying, and block.number as a salt\n    bytes32 salt = keccak256(abi.encodePacked(msg.sender, address(0), block.number));\n\n    bytes memory cEtherDelegatorCreationCode = abi.encodePacked(type(CEtherDelegator).creationCode, constructorData);\n    address proxy = Create2Upgradeable.deploy(0, salt, cEtherDelegatorCreationCode);\n    return proxy;\n  }\n\n  function deployCErc20(bytes calldata constructorData) external returns (address) {\n    // Make sure comptroller == msg.sender\n    (address underlying, address comptroller) = abi.decode(constructorData[0:64], (address, address));\n    require(comptroller == msg.sender, \"Comptroller is not sender.\");\n\n    // Deploy CErc20Delegator using msg.sender, underlying, and block.number as a salt\n    bytes32 salt = keccak256(abi.encodePacked(msg.sender, underlying, block.number));\n\n    bytes memory cErc20DelegatorCreationCode = abi.encodePacked(type(CErc20Delegator).creationCode, constructorData);\n    address proxy = Create2Upgradeable.deploy(0, salt, cErc20DelegatorCreationCode);\n\n    return proxy;\n  }\n\n  /**\n   * @dev Whitelisted Comptroller implementation contract addresses for each existing implementation.\n   */\n  mapping(address => mapping(address => bool)) public comptrollerImplementationWhitelist;\n\n  /**\n   * @dev Adds/removes Comptroller implementations to the whitelist.\n   * @param oldImplementations The old `Comptroller` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n   * @param newImplementations Array of `Comptroller` implementations to be whitelisted/unwhitelisted.\n   * @param statuses Array of whitelist statuses corresponding to `implementations`.\n   */\n  function _editComptrollerImplementationWhitelist(\n    address[] calldata oldImplementations,\n    address[] calldata newImplementations,\n    bool[] calldata statuses\n  ) external onlyOwner {\n    require(\n      newImplementations.length > 0 &&\n        newImplementations.length == oldImplementations.length &&\n        newImplementations.length == statuses.length,\n      \"No Comptroller implementations supplied or array lengths not equal.\"\n    );\n    for (uint256 i = 0; i < newImplementations.length; i++)\n      comptrollerImplementationWhitelist[oldImplementations[i]][newImplementations[i]] = statuses[i];\n  }\n\n  /**\n   * @dev Whitelisted CErc20Delegate implementation contract addresses and `allowResign` values for each existing implementation.\n   */\n  mapping(address => mapping(address => mapping(bool => bool))) public cErc20DelegateWhitelist;\n\n  /**\n   * @dev Adds/removes CErc20Delegate implementations to the whitelist.\n   * @param oldImplementations The old `CErc20Delegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n   * @param newImplementations Array of `CErc20Delegate` implementations to be whitelisted/unwhitelisted.\n   * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n   * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n   */\n  function _editCErc20DelegateWhitelist(\n    address[] calldata oldImplementations,\n    address[] calldata newImplementations,\n    bool[] calldata allowResign,\n    bool[] calldata statuses\n  ) external onlyOwner {\n    require(\n      newImplementations.length > 0 &&\n        newImplementations.length == oldImplementations.length &&\n        newImplementations.length == allowResign.length &&\n        newImplementations.length == statuses.length,\n      \"No CErc20Delegate implementations supplied or array lengths not equal.\"\n    );\n    for (uint256 i = 0; i < newImplementations.length; i++)\n      cErc20DelegateWhitelist[oldImplementations[i]][newImplementations[i]][allowResign[i]] = statuses[i];\n  }\n\n  /**\n   * @dev Whitelisted CEtherDelegate implementation contract addresses and `allowResign` values for each existing implementation.\n   */\n  mapping(address => mapping(address => mapping(bool => bool))) public cEtherDelegateWhitelist;\n\n  /**\n   * @dev Adds/removes CEtherDelegate implementations to the whitelist.\n   * @param oldImplementations The old `CEtherDelegate` implementation addresses to upgrade from for each `newImplementations` to upgrade to.\n   * @param newImplementations Array of `CEtherDelegate` implementations to be whitelisted/unwhitelisted.\n   * @param allowResign Array of `allowResign` values corresponding to `newImplementations` to be whitelisted/unwhitelisted.\n   * @param statuses Array of whitelist statuses corresponding to `newImplementations`.\n   */\n  function _editCEtherDelegateWhitelist(\n    address[] calldata oldImplementations,\n    address[] calldata newImplementations,\n    bool[] calldata allowResign,\n    bool[] calldata statuses\n  ) external onlyOwner {\n    require(\n      newImplementations.length > 0 &&\n        newImplementations.length == oldImplementations.length &&\n        newImplementations.length == allowResign.length &&\n        newImplementations.length == statuses.length,\n      \"No CEtherDelegate implementations supplied or array lengths not equal.\"\n    );\n    for (uint256 i = 0; i < newImplementations.length; i++)\n      cEtherDelegateWhitelist[oldImplementations[i]][newImplementations[i]][allowResign[i]] = statuses[i];\n  }\n\n  /**\n   * @dev Latest Comptroller implementation for each existing implementation.\n   */\n  mapping(address => address) internal _latestComptrollerImplementation;\n\n  /**\n   * @dev Latest Comptroller implementation for each existing implementation.\n   */\n  function latestComptrollerImplementation(address oldImplementation) external view returns (address) {\n    return\n      _latestComptrollerImplementation[oldImplementation] != address(0)\n        ? _latestComptrollerImplementation[oldImplementation]\n        : oldImplementation;\n  }\n\n  /**\n   * @dev Sets the latest `Comptroller` upgrade implementation address.\n   * @param oldImplementation The old `Comptroller` implementation address to upgrade from.\n   * @param newImplementation Latest `Comptroller` implementation address.\n   */\n  function _setLatestComptrollerImplementation(address oldImplementation, address newImplementation)\n    external\n    onlyOwner\n  {\n    _latestComptrollerImplementation[oldImplementation] = newImplementation;\n  }\n\n  struct CDelegateUpgradeData {\n    address implementation;\n    bool allowResign;\n    bytes becomeImplementationData;\n  }\n\n  /**\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\n   */\n  mapping(address => CDelegateUpgradeData) public _latestCErc20Delegate;\n\n  /**\n   * @dev Latest CEtherDelegate implementation for each existing implementation.\n   */\n  mapping(address => CDelegateUpgradeData) public _latestCEtherDelegate;\n\n  /**\n   * @dev Latest CErc20Delegate implementation for each existing implementation.\n   */\n  function latestCErc20Delegate(address oldImplementation)\n    external\n    view\n    returns (\n      address,\n      bool,\n      bytes memory\n    )\n  {\n    CDelegateUpgradeData memory data = _latestCErc20Delegate[oldImplementation];\n    bytes memory emptyBytes;\n    return\n      data.implementation != address(0)\n        ? (data.implementation, data.allowResign, data.becomeImplementationData)\n        : (oldImplementation, false, emptyBytes);\n  }\n\n  /**\n   * @dev Latest CEtherDelegate implementation for each existing implementation.\n   */\n  function latestCEtherDelegate(address oldImplementation)\n    external\n    view\n    returns (\n      address,\n      bool,\n      bytes memory\n    )\n  {\n    CDelegateUpgradeData memory data = _latestCEtherDelegate[oldImplementation];\n    bytes memory emptyBytes;\n    return\n      data.implementation != address(0)\n        ? (data.implementation, data.allowResign, data.becomeImplementationData)\n        : (oldImplementation, false, emptyBytes);\n  }\n\n  /**\n   * @dev Sets the latest `CEtherDelegate` upgrade implementation address and data.\n   * @param oldImplementation The old `CEtherDelegate` implementation address to upgrade from.\n   * @param newImplementation Latest `CEtherDelegate` implementation address.\n   * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n   * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n   */\n  function _setLatestCEtherDelegate(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign,\n    bytes calldata becomeImplementationData\n  ) external onlyOwner {\n    _latestCEtherDelegate[oldImplementation] = CDelegateUpgradeData(\n      newImplementation,\n      allowResign,\n      becomeImplementationData\n    );\n  }\n\n  /**\n   * @dev Sets the latest `CErc20Delegate` upgrade implementation address and data.\n   * @param oldImplementation The old `CErc20Delegate` implementation address to upgrade from.\n   * @param newImplementation Latest `CErc20Delegate` implementation address.\n   * @param allowResign Whether or not `resignImplementation` should be called on the old implementation before upgrade.\n   * @param becomeImplementationData Data passed to the new implementation via `becomeImplementation` after upgrade.\n   */\n  function _setLatestCErc20Delegate(\n    address oldImplementation,\n    address newImplementation,\n    bool allowResign,\n    bytes calldata becomeImplementationData\n  ) external onlyOwner {\n    _latestCErc20Delegate[oldImplementation] = CDelegateUpgradeData(\n      newImplementation,\n      allowResign,\n      becomeImplementationData\n    );\n  }\n\n  /**\n   * @notice Maps Unitroller (Comptroller proxy) addresses to the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   * @dev A value of 0 means unset whereas a negative value means 0.\n   */\n  mapping(address => int256) public customInterestFeeRates;\n\n  /**\n   * @notice Returns the proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function interestFeeRate() external view returns (uint256) {\n    (bool success, bytes memory data) = msg.sender.staticcall(abi.encodeWithSignature(\"comptroller()\"));\n\n    if (success && data.length == 32) {\n      address comptroller = abi.decode(data, (address));\n      int256 customRate = customInterestFeeRates[comptroller];\n      if (customRate > 0) return uint256(customRate);\n      if (customRate < 0) return 0;\n    }\n\n    return defaultInterestFeeRate;\n  }\n\n  /**\n   * @dev Sets the proportion of Fuse pool interest taken as a protocol fee.\n   * @param comptroller The Unitroller (Comptroller proxy) address.\n   * @param rate The proportion of Fuse pool interest taken as a protocol fee (scaled by 1e18).\n   */\n  function _setCustomInterestFeeRate(address comptroller, int256 rate) external onlyOwner {\n    require(rate <= 1e18, \"Interest fee rate cannot be more than 100%.\");\n    customInterestFeeRates[comptroller] = rate;\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2Upgradeable {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address) {\n        address addr;\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n        return addr;\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\n        return address(uint160(uint256(_data)));\n    }\n}\n"
    },
    "contracts/compound/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CDelegationStorage {\n  /**\n   * @notice Construct a new money market\n   * @param underlying_ The address of the underlying asset\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   * @param implementation_ The address of the implementation the contract delegates to\n   * @param becomeImplementationData The encoded args for becomeImplementation\n   */\n  constructor(\n    address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    address implementation_,\n    bytes memory becomeImplementationData,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    // First delegate gets to initialize the delegator (i.e. storage contract)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"initialize(address,address,address,string,string,uint256,uint256)\",\n        underlying_,\n        comptroller_,\n        interestRateModel_,\n        name_,\n        symbol_,\n        reserveFactorMantissa_,\n        adminFeeMantissa_\n      )\n    );\n\n    // New implementations always get set via the settor (post-initialize)\n    delegateTo(\n      implementation_,\n      abi.encodeWithSignature(\n        \"_setImplementationSafe(address,bool,bytes)\",\n        implementation_,\n        false,\n        becomeImplementationData\n      )\n    );\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   * @param callee The contract to delegatecall\n   * @param data The raw data to delegatecall\n   * @return The returned bytes from the delegatecall\n   */\n  function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return returnData;\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n   * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n   */\n  receive() external payable {}\n\n  fallback() external payable {\n    // Cannot send value to CErc20Delegator\n    require(msg.value == 0, \"CErc20Delegator:fallback: cannot send value to fallback\");\n\n    // Check for automatic implementation\n    delegateTo(implementation, abi.encodeWithSignature(\"_prepare()\"));\n\n    // delegate all other functions to current implementation\n    (bool success, ) = implementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {\n        revert(free_mem_ptr, returndatasize())\n      }\n      default {\n        return(free_mem_ptr, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/compound/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's WhitePaperInterestRateModel Contract\n * @author Compound\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n  using SafeMath for uint256;\n\n  event NewInterestParams(uint256 baseRatePerBlock, uint256 multiplierPerBlock);\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public blocksPerYear;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   */\n  constructor(\n    uint256 _blocksPerYear,\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear\n  ) {\n    blocksPerYear = _blocksPerYear;\n    baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 ur = utilizationRate(cash, borrows, reserves);\n    return ur.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view override returns (uint256) {\n    uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n  }\n}\n"
    },
    "contracts/compound/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot underflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction underflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot underflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n   * Reverts on division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n   * Reverts with custom message on division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "contracts/compound/Timelock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock {\n  using SafeMath for uint256;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  uint256 public constant GRACE_PERIOD = 14 days;\n  uint256 public constant MINIMUM_DELAY = 2 days;\n  uint256 public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint256 public delay;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n  constructor(address admin_, uint256 delay_) {\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  receive() external payable {}\n\n  function setDelay(uint256 delay_) public {\n    require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint256) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/compound/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./InterestRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's JumpRateModel Contract\n * @author Compound\n */\ncontract JumpRateModel is InterestRateModel {\n  using SafeMath for uint256;\n\n  event NewInterestParams(\n    uint256 baseRatePerBlock,\n    uint256 multiplierPerBlock,\n    uint256 jumpMultiplierPerBlock,\n    uint256 kink\n  );\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n   */\n  uint256 public blocksPerYear;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n   */\n  uint256 public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n   */\n  uint256 public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n   */\n  uint256 public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n   */\n  uint256 public kink;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param _blocksPerYear The approximate number of blocks per year\n   * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by 1e18)\n   * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by 1e18)\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   */\n  constructor(\n    uint256 _blocksPerYear,\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) {\n    blocksPerYear = _blocksPerYear;\n    baseRatePerBlock = baseRatePerYear.div(blocksPerYear);\n    multiplierPerBlock = multiplierPerYear.div(blocksPerYear);\n    jumpMultiplierPerBlock = jumpMultiplierPerYear.div(blocksPerYear);\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market (currently unused)\n   * @return The utilization rate as a mantissa between [0, 1e18]\n   */\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public pure returns (uint256) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows.mul(1e18).div(cash.add(borrows).sub(reserves));\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) public view override returns (uint256) {\n    uint256 util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return util.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n    } else {\n      uint256 normalRate = kink.mul(multiplierPerBlock).div(1e18).add(baseRatePerBlock);\n      uint256 excessUtil = util.sub(kink);\n      return excessUtil.mul(jumpMultiplierPerBlock).div(1e18).add(normalRate);\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n   * @param cash The amount of cash in the market\n   * @param borrows The amount of borrows in the market\n   * @param reserves The amount of reserves in the market\n   * @param reserveFactorMantissa The current reserve factor for the market\n   * @return The supply rate percentage per block as a mantissa (scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view virtual override returns (uint256) {\n    uint256 oneMinusReserveFactor = uint256(1e18).sub(reserveFactorMantissa);\n    uint256 borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint256 rateToPool = borrowRate.mul(oneMinusReserveFactor).div(1e18);\n    return utilizationRate(cash, borrows, reserves).mul(rateToPool).div(1e18);\n  }\n}\n"
    },
    "contracts/compound/DAIInterestRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./JumpRateModel.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @title Compound's DAIInterestRateModel Contract (version 2)\n * @author Compound (modified by Dharma Labs)\n * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\n * Version 2 modifies the original interest rate model by increasing the \"gap\" or slope of the model prior\n * to the \"kink\" from 0.05% to 2% with the goal of \"smoothing out\" interest rate changes as the utilization\n * rate increases.\n */\ncontract DAIInterestRateModelV2 is JumpRateModel {\n  using SafeMath for uint256;\n\n  /**\n   * @notice The additional margin per block separating the base borrow rate from the roof (2% / block).\n   * Note that this value has been increased from the original value of 0.05% per block.\n   */\n  uint256 public gapPerBlock = 2e16 / blocksPerYear;\n\n  /**\n   * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\n   */\n  uint256 public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n  PotLike pot;\n  JugLike jug;\n\n  /**\n   * @notice Construct an interest rate model\n   * @param _blocksPerYear The approximate number of blocks per year\n   * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n   * @param kink_ The utilization point at which the jump multiplier is applied\n   * @param pot_ The address of the Dai pot (where DSR is earned)\n   * @param jug_ The address of the Dai jug (where SF is kept)\n   */\n  constructor(\n    uint256 _blocksPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_,\n    address pot_,\n    address jug_\n  ) JumpRateModel(_blocksPerYear, 0, 0, jumpMultiplierPerYear, kink_) {\n    blocksPerYear = _blocksPerYear;\n    pot = PotLike(pot_);\n    jug = JugLike(jug_);\n    poke();\n  }\n\n  /**\n   * @notice Calculates the current supply interest rate per block including the Dai savings rate\n   * @param cash The total amount of cash the market has\n   * @param borrows The total amount of borrows the market has outstanding\n   * @param reserves The total amnount of reserves the market has\n   * @param reserveFactorMantissa The current reserve factor the market has\n   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n   */\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) public view override returns (uint256) {\n    uint256 protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\n\n    uint256 underlying = cash.add(borrows).sub(reserves);\n    if (underlying == 0) {\n      return protocolRate;\n    } else {\n      uint256 cashRate = cash.mul(dsrPerBlock()).div(underlying);\n      return cashRate.add(protocolRate);\n    }\n  }\n\n  /**\n   * @notice Calculates the Dai savings rate per block\n   * @return The Dai savings rate per block (as a percentage, and scaled by 1e18)\n   */\n  function dsrPerBlock() public view returns (uint256) {\n    return pot.dsr().sub(1e27).div(1e9).mul(15); // scaled 1e27 aka RAY, and includes an extra \"ONE\" before subraction // descale to 1e18 // 15 seconds per block\n  }\n\n  /**\n   * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\n   */\n  function poke() public {\n    (uint256 duty, ) = jug.ilks(\"ETH-A\");\n    uint256 stabilityFeePerBlock = duty.add(jug.base()).sub(1e27).mul(1e18).div(1e27).mul(15);\n\n    // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n    baseRatePerBlock = dsrPerBlock().mul(1e18).div(assumedOneMinusReserveFactorMantissa);\n\n    // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n    if (baseRatePerBlock < stabilityFeePerBlock) {\n      multiplierPerBlock = stabilityFeePerBlock.sub(baseRatePerBlock).add(gapPerBlock).mul(1e18).div(kink);\n    } else {\n      multiplierPerBlock = gapPerBlock.mul(1e18).div(kink);\n    }\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n}\n\n/*** Maker Interfaces ***/\n\nabstract contract PotLike {\n  function chi() external view virtual returns (uint256);\n\n  function dsr() external view virtual returns (uint256);\n\n  function rho() external view virtual returns (uint256);\n\n  function pie(address) external view virtual returns (uint256);\n\n  function drip() external virtual returns (uint256);\n\n  function join(uint256) external virtual;\n\n  function exit(uint256) external virtual;\n}\n\ncontract JugLike {\n  // --- Data ---\n  struct Ilk {\n    uint256 duty;\n    uint256 rho;\n  }\n\n  mapping(bytes32 => Ilk) public ilks;\n  uint256 public base;\n}\n"
    },
    "contracts/FuseSafeLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./liquidators/IRedemptionStrategy.sol\";\n\nimport \"./external/compound/ICToken.sol\";\nimport \"./oracles/default/KeydonixUniswapTwapPriceOracle.sol\";\nimport \"./oracles/keydonix/UniswapOracle.sol\";\n\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/ICEther.sol\";\n\nimport \"./external/aave/IW_NATIVE.sol\";\n\nimport \"./external/uniswap/IUniswapV2Router02.sol\";\nimport \"./external/uniswap/IUniswapV2Callee.sol\";\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\nimport \"./external/uniswap/IUniswapV2Factory.sol\";\nimport \"./external/uniswap/UniswapV2Library.sol\";\nimport \"./external/pcs/PancakeLibrary.sol\";\nimport \"./external/pcs/IPancakePair.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * @title FuseSafeLiquidator\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FuseSafeLiquidator safely liquidates unhealthy borrowers (with flashloan support).\n * @dev Do not transfer NATIVE or tokens directly to this address. Only send NATIVE here when using a method, and only approve tokens for transfer to here when using a method. Direct NATIVE transfers will be rejected and direct token transfers will be lost.\n */\ncontract FuseSafeLiquidator is Initializable, IUniswapV2Callee {\n  using AddressUpgradeable for address payable;\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev W_NATIVE contract address.\n   */\n  address public W_NATIVE_ADDRESS;\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE public W_NATIVE;\n\n  /**\n   * @dev UniswapV2Router02 contract address.\n   */\n  address public UNISWAP_V2_ROUTER_02_ADDRESS;\n\n  /**\n   * @dev Stable token to use for flash loans\n   */\n  address public STABLE_TOKEN;\n\n  /**\n   * @dev Wrapped BTC token to use for flash loans\n   */\n  address public BTC_TOKEN;\n\n  /**\n   * @dev Wrapped BTC token to use for flash loans\n   */\n  bytes PAIR_INIT_HASH_CODE;\n\n  /**\n   * @dev UniswapV2Router02 contract object.\n   */\n  IUniswapV2Router02 public UNISWAP_V2_ROUTER_02;\n\n  /**\n   * @dev Cached liquidator profit exchange source.\n   * ERC20 token address or the zero address for NATIVE.\n   * For use in `safeLiquidateToTokensWithFlashLoan`/`safeLiquidateToEthWithFlashLoan` after it is set by `postFlashLoanTokens`/`postFlashLoanWeth`.\n   */\n  address private _liquidatorProfitExchangeSource;\n\n  function initialize(\n    address _wtoken,\n    address _uniswapV2router,\n    address _stableToken,\n    address _btcToken,\n    bytes memory _uniswapPairInitHashCode\n  ) external initializer {\n    require(_uniswapV2router != address(0), \"UniswapV2Factory not defined.\");\n    W_NATIVE_ADDRESS = _wtoken;\n    UNISWAP_V2_ROUTER_02_ADDRESS = _uniswapV2router;\n    STABLE_TOKEN = _stableToken;\n    BTC_TOKEN = _btcToken;\n    W_NATIVE = IW_NATIVE(W_NATIVE_ADDRESS);\n    UNISWAP_V2_ROUTER_02 = IUniswapV2Router02(UNISWAP_V2_ROUTER_02_ADDRESS);\n    PAIR_INIT_HASH_CODE = _uniswapPairInitHashCode;\n  }\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n   * @param from The input ERC20 token address (or the zero address if NATIVE) to exchange from.\n   * @param to The output ERC20 token address (or the zero address if NATIVE) to exchange to.\n   * @param minOutputAmount The minimum output amount of `to` necessary to complete the exchange without reversion.\n   * @param uniswapV2Router The UniswapV2Router02 to use.\n   */\n  function exchangeAllEthOrTokens(\n    address from,\n    address to,\n    uint256 minOutputAmount,\n    IUniswapV2Router02 uniswapV2Router\n  ) private {\n    if (to == from) return;\n\n    // From NATIVE, W_NATIVE, or something else?\n    if (from == address(0)) {\n      if (to == W_NATIVE_ADDRESS) {\n        // Deposit all NATIVE to W_NATIVE\n        W_NATIVE.deposit{ value: address(this).balance }();\n      } else {\n        // Exchange from NATIVE to tokens\n        uniswapV2Router.swapExactETHForTokens{ value: address(this).balance }(\n          minOutputAmount,\n          array(W_NATIVE_ADDRESS, to),\n          address(this),\n          block.timestamp\n        );\n      }\n    } else if (from == W_NATIVE_ADDRESS && to == address(0)) {\n      // Withdraw all W_NATIVE to NATIVE\n      W_NATIVE.withdraw(IERC20Upgradeable(W_NATIVE_ADDRESS).balanceOf(address(this)));\n    } else {\n      // Approve input tokens\n      IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n      uint256 inputBalance = fromToken.balanceOf(address(this));\n      safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n      // Exchange from tokens to NATIVE or tokens\n      if (to == address(0))\n        uniswapV2Router.swapExactTokensForETH(\n          inputBalance,\n          minOutputAmount,\n          array(from, W_NATIVE_ADDRESS),\n          address(this),\n          block.timestamp\n        );\n      else\n        uniswapV2Router.swapExactTokensForTokens(\n          inputBalance,\n          minOutputAmount,\n          from == W_NATIVE_ADDRESS || to == W_NATIVE_ADDRESS ? array(from, to) : array(from, W_NATIVE_ADDRESS, to),\n          address(this),\n          block.timestamp\n        ); // Put W_NATIVE in the middle of the path if not already a part of the path\n    }\n  }\n\n  /**\n   * @dev Internal function to exchange the entire balance of `from` to at least `minOutputAmount` of `to`.\n   * @param from The input ERC20 token address (or the zero address if NATIVE) to exchange from.\n   * @param outputAmount The output amount of NATIVE.\n   * @param uniswapV2Router The UniswapV2Router02 to use.\n   */\n  function exchangeToExactEth(\n    address from,\n    uint256 outputAmount,\n    IUniswapV2Router02 uniswapV2Router\n  ) private {\n    if (from == address(0)) return;\n\n    // From W_NATIVE something else?\n    if (from == W_NATIVE_ADDRESS) {\n      // Withdraw W_NATIVE to NATIVE\n      W_NATIVE.withdraw(outputAmount);\n    } else {\n      // Approve input tokens\n      IERC20Upgradeable fromToken = IERC20Upgradeable(from);\n      uint256 inputBalance = fromToken.balanceOf(address(this));\n      safeApprove(fromToken, address(uniswapV2Router), inputBalance);\n\n      // Exchange from tokens to NATIVE\n      uniswapV2Router.swapTokensForExactETH(\n        outputAmount,\n        inputBalance,\n        array(from, W_NATIVE_ADDRESS),\n        address(this),\n        block.timestamp\n      );\n    }\n  }\n\n  function safeLiquidateWithPriceProof(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICToken cTokenCollateral,\n    uint256 minOutputAmount,\n    address exchangeSeizedTo,\n    IUniswapV2Router02 uniswapV2Router,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    UniswapOracle.ProofData calldata repaidProofData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external returns (uint256) {\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(cErc20, repaidProofData);\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(cTokenCollateral, collateralProofData);\n\n    return\n      safeLiquidate(\n        borrower,\n        repayAmount,\n        cErc20,\n        cTokenCollateral,\n        minOutputAmount,\n        exchangeSeizedTo,\n        uniswapV2Router,\n        redemptionStrategies,\n        strategyData\n      );\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n   * @param borrower The borrower's Ethereum address.\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n   * @param cErc20 The borrowed cErc20 to repay.\n   * @param cTokenCollateral The cToken collateral to be liquidated.\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n   * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for NATIVE).\n   * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n   * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n   */\n  function safeLiquidate(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICToken cTokenCollateral,\n    uint256 minOutputAmount,\n    address exchangeSeizedTo,\n    IUniswapV2Router02 uniswapV2Router,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) public returns (uint256) {\n    // Transfer tokens in, approve to cErc20, and liquidate borrow\n    require(repayAmount > 0, \"Repay amount (transaction value) must be greater than 0.\");\n    IERC20Upgradeable underlying = IERC20Upgradeable(cErc20.underlying());\n    underlying.safeTransferFrom(msg.sender, address(this), repayAmount);\n    safeApprove(underlying, address(cErc20), repayAmount);\n    require(cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) == 0, \"Liquidation failed.\");\n\n    // Redeem seized cToken collateral if necessary\n    if (exchangeSeizedTo != address(cTokenCollateral)) {\n      uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n\n      if (seizedCTokenAmount > 0) {\n        uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n        // If cTokenCollateral is CEther\n        if (cTokenCollateral.isCEther()) {\n          // Exchange redeemed NATIVE collateral if necessary\n          exchangeAllEthOrTokens(address(0), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n        } else {\n          // Redeem custom collateral if liquidation strategy is set\n          IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n\n          if (redemptionStrategies.length > 0) {\n            require(\n              redemptionStrategies.length == strategyData.length,\n              \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n            );\n            uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n            for (uint256 i = 0; i < redemptionStrategies.length; i++)\n              (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\n                underlyingCollateral,\n                underlyingCollateralSeized,\n                redemptionStrategies[i],\n                strategyData[i]\n              );\n          }\n\n          // Exchange redeemed token collateral if necessary\n          exchangeAllEthOrTokens(address(underlyingCollateral), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n        }\n      }\n    }\n\n    // Transfer seized amount to sender\n    return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n  }\n\n  function safeLiquidateWithPriceProof(\n    address borrower,\n    ICEther cEther,\n    ICErc20 cErc20Collateral,\n    uint256 minOutputAmount,\n    address exchangeSeizedTo,\n    IUniswapV2Router02 uniswapV2Router,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external returns (uint256) {\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(cErc20Collateral, collateralProofData);\n\n    return\n      safeLiquidate(\n        borrower,\n        cEther,\n        cErc20Collateral,\n        minOutputAmount,\n        exchangeSeizedTo,\n        uniswapV2Router,\n        redemptionStrategies,\n        strategyData\n      );\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan (using capital from the sender), confirming that at least `minOutputAmount` in collateral is seized (or outputted by exchange if applicable).\n   * @param borrower The borrower's Ethereum address.\n   * @param cEther The borrowed cEther contract to repay.\n   * @param cErc20Collateral The cErc20 collateral contract to be liquidated.\n   * @param minOutputAmount The minimum amount of collateral to seize (or the minimum exchange output if applicable) required for execution. Reverts if this condition is not met.\n   * @param exchangeSeizedTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for NATIVE).\n   * @param uniswapV2Router The UniswapV2Router to use to convert the seized underlying collateral.\n   * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n   */\n  function safeLiquidate(\n    address borrower,\n    ICEther cEther,\n    ICErc20 cErc20Collateral,\n    uint256 minOutputAmount,\n    address exchangeSeizedTo,\n    IUniswapV2Router02 uniswapV2Router,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) public payable returns (uint256) {\n    // Liquidate NATIVE borrow\n    require(msg.value > 0, \"Repay amount (transaction value) must be greater than 0.\");\n    cEther.liquidateBorrow{ value: msg.value }(borrower, ICToken(cErc20Collateral));\n\n    // Redeem seized cToken collateral if necessary\n    if (exchangeSeizedTo != address(cErc20Collateral)) {\n      uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(address(this));\n\n      if (seizedCTokenAmount > 0) {\n        uint256 redeemResult = cErc20Collateral.redeem(seizedCTokenAmount);\n        require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n        // Redeem custom collateral if liquidation strategy is set\n        IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cErc20Collateral.underlying());\n\n        if (redemptionStrategies.length > 0) {\n          require(\n            redemptionStrategies.length == strategyData.length,\n            \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n          );\n          uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n          for (uint256 i = 0; i < redemptionStrategies.length; i++)\n            (underlyingCollateral, underlyingCollateralSeized) = this.redeemCustomCollateral(\n              underlyingCollateral,\n              underlyingCollateralSeized,\n              redemptionStrategies[i],\n              strategyData[i]\n            ); // redeemCustomCollateral called externally because this safeLiquidate function is payable (for some reason delegatecall fails when called with msg.value > 0)\n        }\n\n        // Exchange redeemed collateral if necessary\n        exchangeAllEthOrTokens(address(underlyingCollateral), exchangeSeizedTo, minOutputAmount, uniswapV2Router);\n      }\n    }\n\n    // Transfer seized amount to sender\n    return transferSeizedFunds(exchangeSeizedTo, minOutputAmount);\n  }\n\n  /**\n   * @dev Transfers seized funds to the sender.\n   * @param erc20Contract The address of the token to transfer.\n   * @param minOutputAmount The minimum amount to transfer.\n   */\n  function transferSeizedFunds(address erc20Contract, uint256 minOutputAmount) internal returns (uint256) {\n    uint256 seizedOutputAmount;\n\n    if (erc20Contract == address(0)) {\n      seizedOutputAmount = address(this).balance;\n      require(seizedOutputAmount >= minOutputAmount, \"Minimum NATIVE output amount not satisfied.\");\n\n      if (seizedOutputAmount > 0) {\n        (bool success, ) = msg.sender.call{ value: seizedOutputAmount }(\"\");\n        require(success, \"Failed to transfer output NATIVE to msg.sender.\");\n      }\n    } else {\n      IERC20Upgradeable token = IERC20Upgradeable(erc20Contract);\n      seizedOutputAmount = token.balanceOf(address(this));\n      require(seizedOutputAmount >= minOutputAmount, \"Minimum token output amount not satified.\");\n      if (seizedOutputAmount > 0) token.safeTransfer(msg.sender, seizedOutputAmount);\n    }\n\n    return seizedOutputAmount;\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in NATIVE profit is seized.\n   * @param borrower The borrower's Ethereum address.\n   * @param repayAmount The amount to repay to liquidate the unhealthy loan.\n   * @param cErc20 The borrowed CErc20 contract to repay.\n   * @param cTokenCollateral The cToken collateral contract to be liquidated.\n   * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n   * @param exchangeProfitTo If set to an address other than `cTokenCollateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for NATIVE).\n   * @param uniswapV2RouterForBorrow The UniswapV2Router to use to convert the NATIVE to the underlying borrow (and flashloan the underlying borrow for NATIVE).\n   * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to NATIVE.\n   * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n   */\n  function safeLiquidateToTokensWithFlashLoan(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICToken cTokenCollateral,\n    uint256 minProfitAmount,\n    address exchangeProfitTo,\n    IUniswapV2Router02 uniswapV2RouterForBorrow,\n    IUniswapV2Router02 uniswapV2RouterForCollateral,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    uint256 ethToCoinbase\n  ) external returns (uint256) {\n    // Input validation\n    require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n    // Flashloan via Uniswap (scoping `underlyingBorrow` variable to avoid \"stack too deep\" compiler error)\n    IUniswapV2Pair pair;\n    bool token0IsUnderlyingBorrow;\n    {\n      address underlyingBorrow = cErc20.underlying();\n      pair = IUniswapV2Pair(\n        IUniswapV2Factory(uniswapV2RouterForBorrow.factory()).getPair(underlyingBorrow, W_NATIVE_ADDRESS)\n      );\n      token0IsUnderlyingBorrow = pair.token0() == underlyingBorrow;\n    }\n    pair.swap(\n      token0IsUnderlyingBorrow ? repayAmount : 0,\n      !token0IsUnderlyingBorrow ? repayAmount : 0,\n      address(this),\n      msg.data\n    );\n\n    // Exchange profit, send NATIVE to coinbase if necessary, and transfer seized funds\n    return distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n  }\n\n  /**\n   * @notice Safely liquidate an unhealthy loan, confirming that at least `minProfitAmount` in NATIVE profit is seized.\n   * @param borrower The borrower's Ethereum address.\n   * @param repayAmount The NATIVE amount to repay to liquidate the unhealthy loan.\n   * @param cEther The borrowed CEther contract to repay.\n   * @param cErc20Collateral The CErc20 collateral contract to be liquidated.\n   * @param minProfitAmount The minimum amount of profit required for execution (in terms of `exchangeProfitTo`). Reverts if this condition is not met.\n   * @param exchangeProfitTo If set to an address other than `cErc20Collateral`, exchange seized collateral to this ERC20 token contract address (or the zero address for NATIVE).\n   * @param uniswapV2RouterForCollateral The UniswapV2Router to use to convert the underlying collateral to NATIVE.\n   * @param redemptionStrategies The IRedemptionStrategy contracts to use, if any, to redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * @param strategyData The data for the chosen IRedemptionStrategy contracts, if any.\n   */\n  function safeLiquidateToEthWithFlashLoan(\n    address borrower,\n    uint256 repayAmount,\n    ICEther cEther,\n    ICErc20 cErc20Collateral,\n    uint256 minProfitAmount,\n    address exchangeProfitTo,\n    IUniswapV2Router02 uniswapV2RouterForCollateral,\n    IRedemptionStrategy[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    uint256 ethToCoinbase\n  ) external returns (uint256) {\n    // Input validation\n    require(repayAmount > 0, \"Repay amount must be greater than 0.\");\n\n    // Flashloan via Uniswap\n    // Use STABLE_TOKEN unless collateral is STABLE_TOKEN, in which case we use WBTC to avoid a reentrancy error\n    // when exchanging the collateral to repay the borrow\n\n    IPancakePair pair = IPancakePair(\n      PancakeLibrary.pairFor(\n        UNISWAP_V2_ROUTER_02.factory(),\n        address(uniswapV2RouterForCollateral) == UNISWAP_V2_ROUTER_02_ADDRESS &&\n          cErc20Collateral.underlying() == STABLE_TOKEN\n          ? BTC_TOKEN\n          : STABLE_TOKEN,\n        W_NATIVE_ADDRESS,\n        PAIR_INIT_HASH_CODE\n      )\n    );\n\n    pair.swap(repayAmount * 1e6, 0, address(this), \"\");\n\n    // Exchange profit, send NATIVE to coinbase if necessary, and transfer seized funds\n    return distributeProfit(exchangeProfitTo, minProfitAmount, ethToCoinbase);\n  }\n\n  /**\n   * Exchange profit, send NATIVE to coinbase if necessary, and transfer seized funds to sender.\n   */\n  function distributeProfit(\n    address exchangeProfitTo,\n    uint256 minProfitAmount,\n    uint256 ethToCoinbase\n  ) private returns (uint256) {\n    if (exchangeProfitTo == address(0)) {\n      // Exchange profit if necessary\n      exchangeAllEthOrTokens(\n        _liquidatorProfitExchangeSource,\n        exchangeProfitTo,\n        minProfitAmount + ethToCoinbase,\n        UNISWAP_V2_ROUTER_02\n      );\n\n      // Transfer NATIVE to block.coinbase if requested\n      if (ethToCoinbase > 0) block.coinbase.call{ value: ethToCoinbase }(\"\");\n\n      // Transfer profit to msg.sender\n      return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n    } else {\n      // Transfer NATIVE to block.coinbase if requested\n      if (ethToCoinbase > 0) {\n        exchangeToExactEth(_liquidatorProfitExchangeSource, ethToCoinbase, UNISWAP_V2_ROUTER_02);\n        block.coinbase.call{ value: ethToCoinbase }(\"\");\n      }\n\n      // Exchange profit if necessary\n      exchangeAllEthOrTokens(\n        _liquidatorProfitExchangeSource,\n        exchangeProfitTo,\n        minProfitAmount + ethToCoinbase,\n        UNISWAP_V2_ROUTER_02\n      );\n\n      // Transfer profit to msg.sender\n      return transferSeizedFunds(exchangeProfitTo, minProfitAmount);\n    }\n  }\n\n  /**\n   * @dev Receives NATIVE from liquidations and flashloans.\n   * Requires that `msg.sender` is W_NATIVE, a CToken, or a Uniswap V2 Router, or another contract.\n   */\n  receive() external payable {\n    require(payable(msg.sender).isContract(), \"Sender is not a contract.\");\n  }\n\n  /**\n   * @dev Callback function for Uniswap flashloans.\n   */\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external override {\n    address cToken = abi.decode(data[68:100], (address));\n\n    // Liquidate unhealthy borrow, exchange seized collateral, return flashloaned funds, and exchange profit\n    if (ICToken(cToken).isCEther()) {\n      // Decode params\n      (\n        address borrower,\n        uint256 repayAmount,\n        ,\n        address cTokenCollateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        IUniswapV2Router02 uniswapV2Router,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData\n      ) = abi.decode(\n          data[4:],\n          (address, uint256, address, address, uint256, address, IUniswapV2Router02, address[], bytes[])\n        );\n\n      // Calculate flashloan return amount\n      uint256 flashLoanReturnAmount = (repayAmount * 1000) / 997;\n      if ((repayAmount * 1000) % 997 > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n      // Post W_NATIVE flashloan\n      // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\n      _liquidatorProfitExchangeSource = postFlashLoanWeth(\n        borrower,\n        repayAmount,\n        ICEther(cToken),\n        ICErc20(cTokenCollateral),\n        minProfitAmount,\n        exchangeProfitTo,\n        flashLoanReturnAmount,\n        uniswapV2Router,\n        redemptionStrategies,\n        strategyData\n      );\n    } else {\n      // Decode params\n      (\n        address borrower,\n        uint256 repayAmount,\n        ,\n        address cTokenCollateral,\n        uint256 minProfitAmount,\n        address exchangeProfitTo,\n        IUniswapV2Router02 uniswapV2RouterForBorrow,\n        IUniswapV2Router02 uniswapV2RouterForCollateral,\n        address[] memory redemptionStrategies,\n        bytes[] memory strategyData\n      ) = abi.decode(\n          data[4:],\n          (\n            address,\n            uint256,\n            address,\n            address,\n            uint256,\n            address,\n            IUniswapV2Router02,\n            IUniswapV2Router02,\n            address[],\n            bytes[]\n          )\n        );\n\n      // Calculate flashloan return amount\n      uint256 flashLoanReturnAmount = (repayAmount * 1000) / 997;\n      if ((repayAmount * 1000) % 997 > 0) flashLoanReturnAmount++; // Round up if division resulted in a remainder\n\n      // Post token flashloan\n      // Cache liquidation profit token (or the zero address for NATIVE) for use as source for exchange later\n      _liquidatorProfitExchangeSource = postFlashLoanTokens(\n        borrower,\n        repayAmount,\n        ICErc20(cToken),\n        ICToken(cTokenCollateral),\n        minProfitAmount,\n        exchangeProfitTo,\n        flashLoanReturnAmount,\n        uniswapV2RouterForBorrow,\n        uniswapV2RouterForCollateral,\n        redemptionStrategies,\n        strategyData\n      );\n    }\n  }\n\n  /**\n   * @dev Fetches and sorts the reserves for a pair.\n   * Original code from PancakeLibrary.\n   */\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) private view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = PancakeLibrary.sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(tokenA, tokenB))\n      .getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  /**\n   * @dev Performs chained getAmountIn calculations on any number of pairs.\n   * Original code from PancakeLibrary.\n   */\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) private view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"PancakeLibrary: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = PancakeLibrary.getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  /**\n   * @dev Liquidate unhealthy NATIVE borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n   */\n  function postFlashLoanWeth(\n    address borrower,\n    uint256 repayAmount,\n    ICEther cEther,\n    ICErc20 cErc20Collateral,\n    uint256 minProfitAmount,\n    address exchangeProfitTo,\n    uint256 flashLoanReturnAmount,\n    IUniswapV2Router02 uniswapV2Router,\n    address[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) private returns (address) {\n    // Unwrap W_NATIVE\n    W_NATIVE.withdraw(repayAmount);\n\n    // Liquidate NATIVE borrow using flashloaned NATIVE\n    cEther.liquidateBorrow{ value: repayAmount }(borrower, ICToken(cErc20Collateral));\n\n    // Redeem seized cTokens for underlying asset\n    uint256 seizedCTokenAmount = cErc20Collateral.balanceOf(address(this));\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n    uint256 redeemResult = cErc20Collateral.redeem(seizedCTokenAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n    // Repay flashloan\n    return\n      repayWethFlashLoan(\n        repayAmount,\n        cErc20Collateral,\n        exchangeProfitTo,\n        flashLoanReturnAmount,\n        uniswapV2Router,\n        redemptionStrategies,\n        strategyData\n      );\n  }\n\n  /**\n   * @dev Repays W_NATIVE flashloans.\n   */\n  function repayWethFlashLoan(\n    uint256 repayAmount,\n    ICErc20 cErc20Collateral,\n    address exchangeProfitTo,\n    uint256 flashLoanReturnAmount,\n    IUniswapV2Router02 uniswapV2Router,\n    address[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) private returns (address) {\n    // Check underlying collateral seized\n    IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(cErc20Collateral.underlying());\n    uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n    // Redeem custom collateral if liquidation strategy is set\n    if (redemptionStrategies.length > 0) {\n      require(\n        redemptionStrategies.length == strategyData.length,\n        \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n      );\n      for (uint256 i = 0; i < redemptionStrategies.length; i++)\n        (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\n          underlyingCollateral,\n          underlyingCollateralSeized,\n          IRedemptionStrategy(redemptionStrategies[i]),\n          strategyData[i]\n        );\n    }\n\n    // Check side of the flashloan to repay: if input token (underlying collateral) is part of flashloan, repay it (to avoid reentracy error); otherwise, convert to W_NATIVE and repay W_NATIVE\n    if (\n      address(uniswapV2Router) == UNISWAP_V2_ROUTER_02_ADDRESS &&\n      address(underlyingCollateral) ==\n      (\n        cErc20Collateral.underlying() == 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n          ? 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n          : 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n      )\n    ) {\n      // Get tokens required to repay flashloan and repay flashloan in non-W_NATIVE tokens\n      uint256 tokensRequired = getAmountsIn(\n        uniswapV2Router.factory(),\n        repayAmount,\n        array(address(underlyingCollateral), W_NATIVE_ADDRESS)\n      )[0];\n      require(tokensRequired <= underlyingCollateralSeized, \"Flashloan return amount greater than seized collateral.\");\n      require(\n        underlyingCollateral.transfer(msg.sender, tokensRequired),\n        \"Failed to transfer non-W_NATIVE tokens back to flashlender.\"\n      );\n    } else {\n      // If underlying collateral is not already W_NATIVE, convert it to W_NATIVE\n      if (address(underlyingCollateral) != W_NATIVE_ADDRESS) {\n        // If underlying collateral is NATIVE, deposit to W_NATIVE; if token, exchange to W_NATIVE\n        if (address(underlyingCollateral) == address(0)) {\n          // Deposit NATIVE to W_NATIVE to repay flashloan\n          W_NATIVE.deposit{ value: flashLoanReturnAmount }();\n        } else {\n          // Approve to Uniswap router\n          safeApprove(underlyingCollateral, address(uniswapV2Router), underlyingCollateralSeized);\n\n          // Swap collateral tokens for W_NATIVE via Uniswap router\n          if (exchangeProfitTo == address(underlyingCollateral))\n            uniswapV2Router.swapTokensForExactTokens(\n              flashLoanReturnAmount,\n              underlyingCollateralSeized,\n              array(address(underlyingCollateral), W_NATIVE_ADDRESS),\n              address(this),\n              block.timestamp\n            );\n          else {\n            uniswapV2Router.swapExactTokensForTokens(\n              underlyingCollateralSeized,\n              flashLoanReturnAmount,\n              array(address(underlyingCollateral), W_NATIVE_ADDRESS),\n              address(this),\n              block.timestamp\n            );\n            underlyingCollateral = IERC20Upgradeable(W_NATIVE_ADDRESS);\n          }\n        }\n      }\n\n      // Repay flashloan in W_NATIVE\n      require(\n        flashLoanReturnAmount <= IERC20Upgradeable(W_NATIVE_ADDRESS).balanceOf(address(this)),\n        \"Flashloan return amount greater than W_NATIVE exchanged from seized collateral.\"\n      );\n      require(W_NATIVE.transfer(msg.sender, flashLoanReturnAmount), \"Failed to transfer W_NATIVE back to flashlender.\");\n    }\n\n    // Return the profited token\n    return address(underlyingCollateral);\n  }\n\n  /**\n   * @dev Liquidate unhealthy token borrow, exchange seized collateral, return flashloaned funds, and exchange profit.\n   */\n  function postFlashLoanTokens(\n    address borrower,\n    uint256 repayAmount,\n    ICErc20 cErc20,\n    ICToken cTokenCollateral,\n    uint256 minProfitAmount,\n    address exchangeProfitTo,\n    uint256 flashLoanReturnAmount,\n    IUniswapV2Router02 uniswapV2RouterForBorrow,\n    IUniswapV2Router02 uniswapV2RouterForCollateral,\n    address[] memory redemptionStrategies,\n    bytes[] memory strategyData\n  ) private returns (address) {\n    // Approve repayAmount to cErc20\n    IERC20Upgradeable underlyingBorrow = IERC20Upgradeable(cErc20.underlying());\n    safeApprove(underlyingBorrow, address(cErc20), repayAmount);\n\n    // Liquidate NATIVE borrow using flashloaned NATIVE\n    require(cErc20.liquidateBorrow(borrower, repayAmount, cTokenCollateral) == 0, \"Liquidation failed.\");\n\n    // Redeem seized cTokens for underlying asset\n    uint256 seizedCTokenAmount = cTokenCollateral.balanceOf(address(this));\n    require(seizedCTokenAmount > 0, \"No cTokens seized.\");\n    uint256 redeemResult = cTokenCollateral.redeem(seizedCTokenAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cToken: error code not equal to 0\");\n\n    // Repay flashloan\n    return\n      repayTokenFlashLoan(\n        repayAmount,\n        cTokenCollateral,\n        exchangeProfitTo,\n        flashLoanReturnAmount,\n        uniswapV2RouterForBorrow,\n        uniswapV2RouterForCollateral,\n        redemptionStrategies,\n        strategyData,\n        underlyingBorrow\n      );\n  }\n\n  /**\n   * @dev Repays token flashloans.\n   */\n  function repayTokenFlashLoan(\n    uint256 repayAmount,\n    ICToken cTokenCollateral,\n    address exchangeProfitTo,\n    uint256 flashLoanReturnAmount,\n    IUniswapV2Router02 uniswapV2RouterForBorrow,\n    IUniswapV2Router02 uniswapV2RouterForCollateral,\n    address[] memory redemptionStrategies,\n    bytes[] memory strategyData,\n    IERC20Upgradeable underlyingBorrow\n  ) private returns (address) {\n    // Swap cTokenCollateral for cErc20 via Uniswap\n    if (cTokenCollateral.isCEther()) {\n      // Get flashloan repay amount in terms of W_NATIVE collateral via Uniswap router\n      // uniswapV2RouterForCollateral is ignored because it should be the same as uniswapV2RouterForBorrow\n      uint256 underlyingCollateralSeized = address(this).balance;\n      uint256 wethRequired = getAmountsIn(\n        uniswapV2RouterForBorrow.factory(),\n        repayAmount,\n        array(W_NATIVE_ADDRESS, address(underlyingBorrow))\n      )[0];\n\n      // Repay flashloan\n      require(wethRequired <= underlyingCollateralSeized, \"Seized NATIVE collateral not enough to repay flashloan.\");\n      W_NATIVE.deposit{ value: wethRequired }();\n      require(\n        W_NATIVE.transfer(msg.sender, wethRequired),\n        \"Failed to repay Uniswap flashloan with W_NATIVE exchanged from seized collateral.\"\n      );\n\n      // Return the profited token (NATIVE)\n      return address(0);\n    } else {\n      // Check underlying collateral seized\n      IERC20Upgradeable underlyingCollateral = IERC20Upgradeable(ICErc20(address(cTokenCollateral)).underlying());\n      uint256 underlyingCollateralSeized = underlyingCollateral.balanceOf(address(this));\n\n      // Redeem custom collateral if liquidation strategy is set\n      if (redemptionStrategies.length > 0) {\n        require(\n          redemptionStrategies.length == strategyData.length,\n          \"IRedemptionStrategy contract array and strategy data bytes array mnust the the same length.\"\n        );\n        for (uint256 i = 0; i < redemptionStrategies.length; i++)\n          (underlyingCollateral, underlyingCollateralSeized) = redeemCustomCollateral(\n            underlyingCollateral,\n            underlyingCollateralSeized,\n            IRedemptionStrategy(redemptionStrategies[i]),\n            strategyData[i]\n          );\n      }\n\n      // Check which side of the flashloan to repay\n      if (address(underlyingCollateral) == address(underlyingBorrow)) {\n        // Repay flashloan on borrow side with collateral\n        require(\n          flashLoanReturnAmount <= underlyingBorrow.balanceOf(address(this)),\n          \"Token flashloan return amount greater than tokens exchanged from seized collateral.\"\n        );\n        require(\n          underlyingBorrow.transfer(msg.sender, flashLoanReturnAmount),\n          \"Failed to repay token flashloan on borrow (non-W_NATIVE) side.\"\n        );\n\n        // Return the profited token (same as collateral and borrow)\n        return address(underlyingCollateral);\n      } else {\n        // Get W_NATIVE required to repay flashloan\n        uint256 wethRequired = getAmountsIn(\n          uniswapV2RouterForBorrow.factory(),\n          repayAmount,\n          array(W_NATIVE_ADDRESS, address(underlyingBorrow))\n        )[0];\n\n        if (address(underlyingCollateral) != W_NATIVE_ADDRESS) {\n          // Approve to Uniswap router\n          safeApprove(underlyingCollateral, address(uniswapV2RouterForCollateral), underlyingCollateralSeized);\n\n          // Swap collateral tokens for W_NATIVE to be repaid via Uniswap router\n          if (exchangeProfitTo == address(underlyingCollateral))\n            uniswapV2RouterForCollateral.swapTokensForExactTokens(\n              wethRequired,\n              underlyingCollateralSeized,\n              array(address(underlyingCollateral), W_NATIVE_ADDRESS),\n              address(this),\n              block.timestamp\n            );\n          else\n            uniswapV2RouterForCollateral.swapExactTokensForTokens(\n              underlyingCollateralSeized,\n              wethRequired,\n              array(address(underlyingCollateral), W_NATIVE_ADDRESS),\n              address(this),\n              block.timestamp\n            );\n        }\n\n        // Repay flashloan\n        require(\n          wethRequired <= IERC20Upgradeable(W_NATIVE_ADDRESS).balanceOf(address(this)),\n          \"Not enough W_NATIVE exchanged from seized collateral to repay flashloan.\"\n        );\n        require(\n          W_NATIVE.transfer(msg.sender, wethRequired),\n          \"Failed to repay Uniswap flashloan with W_NATIVE exchanged from seized collateral.\"\n        );\n\n        // Return the profited token (underlying collateral if same as exchangeProfitTo; otherwise, W_NATIVE)\n        return exchangeProfitTo == address(underlyingCollateral) ? address(underlyingCollateral) : W_NATIVE_ADDRESS;\n      }\n    }\n  }\n\n  /**\n   * @dev Redeem \"special\" collateral tokens (before swapping the output for borrowed tokens to be repaid via Uniswap).\n   * Public visibility because we have to call this function externally if called from a payable FuseSafeLiquidator function (for some reason delegatecall fails when called with msg.value > 0).\n   */\n  function redeemCustomCollateral(\n    IERC20Upgradeable underlyingCollateral,\n    uint256 underlyingCollateralSeized,\n    IRedemptionStrategy strategy,\n    bytes memory strategyData\n  ) public returns (IERC20Upgradeable, uint256) {\n    bytes memory returndata = _functionDelegateCall(\n      address(strategy),\n      abi.encodeWithSelector(strategy.redeem.selector, underlyingCollateral, underlyingCollateralSeized, strategyData)\n    );\n    return abi.decode(returndata, (IERC20Upgradeable, uint256));\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], but performing a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L37\n   */\n  function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n    require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return _verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Used by `_functionDelegateCall` to verify the result of a delegate call.\n   * Copied from https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/cb4774ace1cb84f2662fa47c573780aab937628b/contracts/utils/MulticallUpgradeable.sol#L45\n   */\n  function _verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) private pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n\n  /**\n   * @dev Returns an array containing the parameters supplied.\n   */\n  function array(uint256 a) private pure returns (uint256[] memory) {\n    uint256[] memory arr = new uint256[](1);\n    arr[0] = a;\n    return arr;\n  }\n\n  /**\n   * @dev Returns an array containing the parameters supplied.\n   */\n  function array(address a) private pure returns (address[] memory) {\n    address[] memory arr = new address[](1);\n    arr[0] = a;\n    return arr;\n  }\n\n  /**\n   * @dev Returns an array containing the parameters supplied.\n   */\n  function array(address a, address b) private pure returns (address[] memory) {\n    address[] memory arr = new address[](2);\n    arr[0] = a;\n    arr[1] = b;\n    return arr;\n  }\n\n  /**\n   * @dev Returns an array containing the parameters supplied.\n   */\n  function array(\n    address a,\n    address b,\n    address c\n  ) private pure returns (address[] memory) {\n    address[] memory arr = new address[](3);\n    arr[0] = a;\n    arr[1] = b;\n    arr[2] = c;\n    return arr;\n  }\n}\n"
    },
    "contracts/liquidators/IRedemptionStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/**\n * @title IRedemptionStrategy\n * @notice Redeems seized wrapped token collateral for an underlying token for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ninterface IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external returns (IERC20Upgradeable outputToken, uint256 outputAmount);\n}\n"
    },
    "contracts/external/compound/ICEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\nimport \"../../oracles/keydonix/UniswapOracle.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ninterface ICEther is ICToken {\n  function liquidateBorrow(address borrower, ICToken cTokenCollateral) external payable;\n\n  function liquidateBorrowWithPriceProof(\n    address borrower,\n    ICToken cTokenCollateral,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external payable;\n}\n"
    },
    "contracts/external/aave/IW_NATIVE.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity >=0.8.0;\n\ninterface IW_NATIVE {\n  function deposit() external payable;\n\n  function withdraw(uint256) external;\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(\n    address src,\n    address dst,\n    uint256 wad\n  ) external returns (bool);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Callee {\n  function uniswapV2Call(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/external/uniswap/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IUniswapV2Pair.sol\";\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint160(\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex\"ff\",\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n            )\n          )\n        )\n      )\n    );\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(reserveA > 0 && reserveB > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 amountInWithFee = amountIn * 997;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\");\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = numerator / denominator + 1;\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "contracts/external/pcs/PancakeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\nimport \"./IPancakePair.sol\";\n\nlibrary PancakeLibrary {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"PancakeLibrary: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"PancakeLibrary: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB,\n    bytes memory initHashCode\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint160(\n        uint256(\n          keccak256(abi.encodePacked(hex\"ff\", factory, keccak256(abi.encodePacked(token0, token1)), initHashCode))\n        )\n      )\n    );\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB,\n    bytes memory initHashCode\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    pairFor(factory, tokenA, tokenB, initHashCode);\n    (uint256 reserve0, uint256 reserve1, ) = IPancakePair(pairFor(factory, tokenA, tokenB, initHashCode)).getReserves();\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (uint256 amountB) {\n    require(amountA > 0, \"PancakeLibrary: INSUFFICIENT_AMOUNT\");\n    require(reserveA > 0 && reserveB > 0, \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\");\n    amountB = (amountA * reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountOut) {\n    require(amountIn > 0, \"PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\");\n    uint256 amountInWithFee = amountIn * 9975;\n    uint256 numerator = amountInWithFee * reserveOut;\n    uint256 denominator = reserveIn * 1000 + amountInWithFee;\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) internal pure returns (uint256 amountIn) {\n    require(amountOut > 0, \"PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(reserveIn > 0 && reserveOut > 0, \"PancakeLibrary: INSUFFICIENT_LIQUIDITY\");\n    uint256 numerator = reserveIn * amountOut * 1000;\n    uint256 denominator = (reserveOut - amountOut) * 997;\n    amountIn = numerator / denominator + 1;\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint256 amountIn,\n    address[] memory path,\n    bytes memory initHashCode\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"PancakeLibrary: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[0] = amountIn;\n    for (uint256 i; i < path.length - 1; i++) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1], initHashCode);\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint256 amountOut,\n    address[] memory path,\n    bytes memory initHashCode\n  ) internal view returns (uint256[] memory amounts) {\n    require(path.length >= 2, \"PancakeLibrary: INVALID_PATH\");\n    amounts = new uint256[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint256 i = path.length - 1; i > 0; i--) {\n      (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i], initHashCode);\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "contracts/external/pcs/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IPancakePair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/external/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 amountADesired,\n    uint256 amountBDesired,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    returns (\n      uint256 amountA,\n      uint256 amountB,\n      uint256 liquidity\n    );\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    );\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint256 liquidity,\n    uint256 amountAMin,\n    uint256 amountBMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountA, uint256 amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountToken, uint256 amountETH);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function quote(\n    uint256 amountA,\n    uint256 reserveA,\n    uint256 reserveB\n  ) external pure returns (uint256 amountB);\n\n  function getAmountOut(\n    uint256 amountIn,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountOut);\n\n  function getAmountIn(\n    uint256 amountOut,\n    uint256 reserveIn,\n    uint256 reserveOut\n  ) external pure returns (uint256 amountIn);\n\n  function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n  function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/oracles/mainnet/Keep3rV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/keep3r/Keep3rV2OracleFactory.sol\";\nimport \"../../external/keep3r/Keep3rV2Oracle.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title Keep3rV2PriceOracle\n * @notice Returns prices from `Keep3rV2Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rV2PriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n   */\n  constructor(address _keep3rV2OracleFactory, address _uniswapV2Factory) {\n    keep3rV2OracleFactory = Keep3rV2OracleFactory(_keep3rV2OracleFactory);\n    uniswapV2Factory = IUniswapV2Factory(_uniswapV2Factory);\n  }\n\n  /**\n   * @dev Keep3rV1Oracle token contract object.\n   */\n  Keep3rV2OracleFactory public immutable keep3rV2OracleFactory;\n\n  /**\n   * @dev UniswapV2Factory contract object.\n   */\n  IUniswapV2Factory public immutable uniswapV2Factory;\n\n  /**\n   * @dev WETH token contract address.\n   */\n  address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @dev Minimum TWAP interval.\n   */\n  uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n  /**\n   * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price0.\n   */\n  function price0TWAP(address pair) internal view returns (uint256) {\n    Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n    uint256 length = feed.length();\n    require(length > 0, \"no length-1 observation\");\n    (uint256 lastTime, uint256 lastPx0CumuCompressed, ) = feed.observations(length - 1);\n    if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"no length-2 observation\");\n      (lastTime, lastPx0CumuCompressed, ) = feed.observations(length - 2);\n    }\n    uint256 elapsedTime = block.timestamp - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME, \"no TWAP satisfying MIN_TWAP_TIME\");\n    uint256 lastPx0Cumu = (uint256(lastPx0CumuCompressed) * (2**112)) / 1e18;\n    uint256 currPx0Cumu = currentPx0Cumu(pair);\n    return (currPx0Cumu - lastPx0Cumu) / (block.timestamp - lastTime); // overflow is desired\n  }\n\n  /**\n   * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price1.\n   */\n  function price1TWAP(address pair) internal view returns (uint256) {\n    Keep3rV2Oracle feed = keep3rV2OracleFactory.feeds(pair);\n    uint256 length = feed.length();\n    require(length > 0, \"no length-1 observation\");\n    (uint256 lastTime, , uint112 lastPx1CumuCompressed) = feed.observations(length - 1);\n    if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"no length-2 observation\");\n      (lastTime, , lastPx1CumuCompressed) = feed.observations(length - 2);\n    }\n    uint256 elapsedTime = block.timestamp - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME, \"no TWAP satisfying MIN_TWAP_TIME\");\n    uint256 lastPx1Cumu = (uint256(lastPx1CumuCompressed) * (2**112)) / 1e18;\n    uint256 currPx1Cumu = currentPx1Cumu(pair);\n    return (currPx1Cumu - lastPx1Cumu) / (block.timestamp - lastTime); // overflow is desired\n  }\n\n  /**\n   * @dev Return the current price0 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price0 cumulative value.\n   */\n  function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != block.timestamp) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Return the current price1 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price1 cumulative value.\n   */\n  function currentPx1Cumu(address pair) internal view returns (uint256 px1Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying ERC20 token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price, format, and return\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (_price(underlying) * 1e18) / baseUnit;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == WETH_ADDRESS) return 1e18;\n\n    // Call Keep3r for ERC20/ETH price and return\n    address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (((underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair)) / 2**56) * baseUnit) / 2**56; // Scaled by 1e18, not 2 ** 112\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n}\n"
    },
    "contracts/external/keep3r/Keep3rV2OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./Keep3rV2Oracle.sol\";\n\ncontract Keep3rV2OracleFactory {\n  mapping(address => Keep3rV2Oracle) public feeds;\n}\n"
    },
    "contracts/external/keep3r/Keep3rV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ncontract Keep3rV2Oracle {\n  struct Observation {\n    uint32 timestamp;\n    uint112 price0Cumulative;\n    uint112 price1Cumulative;\n  }\n\n  Observation[65535] public observations;\n  uint16 public length;\n}\n"
    },
    "contracts/oracles/mainnet/YVaultV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/yearn/IVaultV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title YVaultV2PriceOracle\n * @notice Returns prices for V2 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV2PriceOracle is IPriceOracle {\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get price of token underlying yVault\n    IVaultV2 yVault = IVaultV2(ICErc20(address(cToken)).underlying());\n    address underlyingToken = yVault.token();\n    uint256 underlyingPrice = underlyingToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n      ? 1e18\n      : BasePriceOracle(msg.sender).price(underlyingToken);\n\n    // yVault/ETH = yVault/token * token/ETH\n    // Return value = yVault/ETH scaled by 1e(36 - yVault decimals)\n    // `pricePerShare` = yVault/token scaled by 1e(yVault decimals)\n    // `underlyingPrice` = token/ETH scaled by 1e18\n    // Return value = `pricePerShare` * `underlyingPrice` * 1e(18 - (yVault decimals * 2))\n    uint256 baseUnit = 10**uint256(yVault.decimals());\n    return (((yVault.pricePerShare() * underlyingPrice) / baseUnit) * 1e18) / baseUnit;\n  }\n}\n"
    },
    "contracts/external/yearn/IVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVaultV2 {\n  function pricePerShare() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function deposit(uint256 _amount) external returns (uint256);\n\n  function withdraw(uint256 maxShares) external returns (uint256);\n}\n"
    },
    "contracts/liquidators/YearnYVaultV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVaultV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV2Liquidator\n * @notice Exchanges seized Yearn yVault V2 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV2Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem yVault token for underlying token (and store output as new collateral)\n    IVaultV2 yVault = IVaultV2(address(inputToken));\n    outputAmount = yVault.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(yVault.token());\n  }\n}\n"
    },
    "contracts/liquidators/YearnYVaultV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/yearn/IVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title YearnYVaultV1Liquidator\n * @notice Exchanges seized Yearn yVault V1 token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YearnYVaultV1Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem yVault token for underlying token (and store output as new collateral)\n    IVault yVault = IVault(address(inputToken));\n    yVault.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(yVault.token());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/external/yearn/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVault {\n  function getPricePerFullShare() external view returns (uint256);\n\n  function token() external view returns (address);\n\n  function decimals() external view returns (uint8);\n\n  function deposit(uint256 _amount) external;\n\n  function withdraw(uint256 _shares) external;\n}\n"
    },
    "contracts/oracles/mainnet/YVaultV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/yearn/IVault.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title YVaultV1PriceOracle\n * @notice Returns prices for V1 yVaults (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract YVaultV1PriceOracle is IPriceOracle {\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get price of token underlying yVault\n    IVault yVault = IVault(ICErc20(address(cToken)).underlying());\n    address underlyingToken = yVault.token();\n    uint256 underlyingPrice = underlyingToken == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n      ? 1e18\n      : BasePriceOracle(msg.sender).price(underlyingToken);\n\n    // yVault/ETH = yVault/token * token/ETH\n    // Return value = yVault/ETH scaled by 1e(36 - yVault decimals)\n    // `getPricePerFullShare` = yVault/token scaled by 1e18\n    // `underlyingPrice` = token/ETH scaled by 1e18\n    // Return value = `pricePerShare` * `underlyingPrice` / 1e(yVault decimals)\n    uint256 baseUnit = 10**uint256(yVault.decimals());\n    return (yVault.getPricePerFullShare() * underlyingPrice) / baseUnit; // getPricePerFullShare is scaled by 1e18\n  }\n}\n"
    },
    "contracts/oracles/mainnet/WSTEthPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/lido/IWstETH.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title WSTEthPriceOracle\n * @notice Returns prices for wstETH.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    return IWstETH(token).stEthPerToken();\n  }\n}\n"
    },
    "contracts/external/lido/IWstETH.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n/**\n * @title StETH token wrapper with static balances.\n * @dev It's an ERC20 token that represents the account's share of the total\n * supply of stETH tokens. WstETH token's balance only changes on transfers,\n * unlike StETH that is also changed when oracles report staking rewards and\n * penalties. It's a \"power user\" token for DeFi protocols which don't\n * support rebasable tokens.\n *\n * The contract is also a trustless wrapper that accepts stETH tokens and mints\n * wstETH in return. Then the user unwraps, the contract burns user's wstETH\n * and sends user locked stETH in return.\n *\n * The contract provides the staking shortcut: user can send ETH with regular\n * transfer and get wstETH in return. The contract will send ETH to Lido submit\n * method, staking it and wrapping the received stETH.\n *\n */\ninterface IWstETH {\n  function stETH() external view returns (address);\n\n  /**\n   * @notice Get amount of wstETH for a one stETH\n   * @return Amount of stETH for 1 wstETH\n   */\n  function stEthPerToken() external view returns (uint256);\n\n  /**\n   * @notice Exchanges wstETH to stETH\n   * @param _wstETHAmount amount of wstETH to uwrap in exchange for stETH\n   * @dev Requirements:\n   *  - `_wstETHAmount` must be non-zero\n   *  - msg.sender must have at least `_wstETHAmount` wstETH.\n   * @return Amount of stETH user receives after unwrap\n   */\n  function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "contracts/liquidators/WSTEthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/lido/IWstETH.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title WSTEthLiquidator\n * @notice Redeems wstETH for underlying stETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract WSTEthLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unwrap wstETH (and store output stETH as new collateral)\n    IWstETH token = IWstETH(address(inputToken));\n    token.unwrap(inputAmount);\n    outputToken = IERC20Upgradeable(token.stETH());\n    outputAmount = inputAmount;\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV3Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/ISwapRouter.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV3Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V3 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV3Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap router, output token, and fee\n    (ISwapRouter swapRouter, address _outputToken, uint24 fee) = abi.decode(\n      strategyData,\n      (ISwapRouter, address, uint24)\n    );\n\n    // Swap underlying tokens\n    safeApprove(inputToken, address(swapRouter), inputAmount);\n    outputAmount = swapRouter.exactInputSingle(\n      ISwapRouter.ExactInputSingleParams(\n        address(inputToken),\n        _outputToken,\n        fee,\n        address(this),\n        block.timestamp,\n        inputAmount,\n        0,\n        0\n      )\n    );\n    outputToken = IERC20Upgradeable(_outputToken);\n  }\n}\n"
    },
    "contracts/external/uniswap/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n  struct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n  }\n\n  /// @notice Swaps `amountIn` of one token for as much as possible of another token\n  /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n  /// @return amountOut The amount of the received token\n  function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n}\n"
    },
    "contracts/liquidators/UniswapV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV2Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V2 router for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV2Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap router and path\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapPath) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[])\n    );\n    require(swapPath.length >= 2 && swapPath[0] == address(inputToken), \"Invalid UniswapLiquidator swap path.\");\n\n    // Swap underlying tokens\n    safeApprove(inputToken, address(uniswapV2Router), inputAmount);\n    uniswapV2Router.swapExactTokensForTokens(inputAmount, 0, swapPath, address(this), block.timestamp);\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapPath[swapPath.length - 1]);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/liquidators/UniswapLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapLpTokenLiquidator\n * @notice Exchanges seized Uniswap V2 LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapLpTokenLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit Uniswap pool\n    IUniswapV2Pair pair = IUniswapV2Pair(address(inputToken));\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n    pair.transfer(address(pair), inputAmount);\n    (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n\n    // Swap underlying tokens\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[], address[])\n    );\n    require(\n      (swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) ==\n        (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1),\n      \"Output of token0 swap path must equal output of token1 swap path.\"\n    );\n\n    if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n      safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n      uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n    }\n\n    if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n      safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n      uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n    }\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/liquidators/GelatoGUniLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\nimport \"../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../external/gelato/GUniPool.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title GelatoGUniLiquidator\n * @notice Exchanges seized GelatoGUni token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract GelatoGUniLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exit GUni pool\n    GUniPool pool = GUniPool(address(inputToken));\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n    (uint256 amount0, uint256 amount1, ) = pool.burn(inputAmount, address(this));\n\n    // Swap underlying tokens\n    (IUniswapV2Router02 uniswapV2Router, address[] memory swapToken0Path, address[] memory swapToken1Path) = abi.decode(\n      strategyData,\n      (IUniswapV2Router02, address[], address[])\n    );\n    require(\n      (swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0) ==\n        (swapToken1Path.length > 0 ? swapToken1Path[swapToken1Path.length - 1] : token1),\n      \"Output of token0 swap path must equal output of token1 swap path.\"\n    );\n\n    if (swapToken0Path.length > 0 && swapToken0Path[swapToken0Path.length - 1] != token0) {\n      safeApprove(IERC20Upgradeable(token0), address(uniswapV2Router), amount0);\n      uniswapV2Router.swapExactTokensForTokens(amount0, 0, swapToken0Path, address(this), block.timestamp);\n    }\n\n    if (swapToken1Path.length > 0 && swapToken1Path[swapToken1Path.length - 1] != token1) {\n      safeApprove(IERC20Upgradeable(token1), address(uniswapV2Router), amount1);\n      uniswapV2Router.swapExactTokensForTokens(amount1, 0, swapToken1Path, address(this), block.timestamp);\n    }\n\n    // Get new collateral\n    outputToken = IERC20Upgradeable(swapToken0Path.length > 0 ? swapToken0Path[swapToken0Path.length - 1] : token0);\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/external/gelato/GUniPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\ninterface GUniPool {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  /// @notice compute total underlying holdings of the G-UNI token supply\n  /// includes current liquidity invested in uniswap position, current fees earned\n  /// and any uninvested leftover (but does not include manager or gelato fees accrued)\n  /// @return amount0Current current total underlying balance of token0\n  /// @return amount1Current current total underlying balance of token1\n  function getUnderlyingBalancesAtPrice(uint160 sqrtRatioX96)\n    external\n    view\n    returns (uint256 amount0Current, uint256 amount1Current);\n\n  /// @notice burn G-UNI tokens (fractional shares of a Uniswap V3 position) and receive tokens\n  /// @param burnAmount The number of G-UNI tokens to burn\n  /// @param receiver The account to receive the underlying amounts of token0 and token1\n  /// @return amount0 amount of token0 transferred to receiver for burning `burnAmount`\n  /// @return amount1 amount of token1 transferred to receiver for burning `burnAmount`\n  /// @return liquidityBurned amount of liquidity removed from the underlying Uniswap V3 position\n  // solhint-disable-next-line function-max-lines\n  function burn(uint256 burnAmount, address receiver)\n    external\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint128 liquidityBurned\n    );\n}\n"
    },
    "contracts/oracles/mainnet/GelatoGUniPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/gelato/GUniPool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title GelatoGUniPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice GelatoGUniPriceOracle is a price oracle for Gelato G-UNI wrapped Uniswap V3 LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract GelatoGUniPriceOracle is IPriceOracle {\n  /**\n   * @dev WETH contract address.\n   */\n  address private constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  function _price(address token) internal view virtual returns (uint256) {\n    // Get G-UNI pool and underlying tokens\n    GUniPool pool = GUniPool(token);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    // Get underlying token prices\n    uint256 p0 = token0 == WETH_ADDRESS ? 1e18 : BasePriceOracle(msg.sender).price(token0);\n    require(p0 > 0, \"Failed to retrieve price for G-UNI underlying token0.\");\n    uint256 p1 = token1 == WETH_ADDRESS ? 1e18 : BasePriceOracle(msg.sender).price(token1);\n    require(p1 > 0, \"Failed to retrieve price for G-UNI underlying token1.\");\n\n    // Get conversion factors\n    uint256 dec0 = uint256(ERC20Upgradeable(token0).decimals());\n    require(dec0 <= 18, \"G-UNI underlying token0 decimals greater than 18.\");\n    uint256 to18Dec0 = 10**(18 - dec0);\n    uint256 dec1 = uint256(ERC20Upgradeable(token1).decimals());\n    require(dec1 <= 18, \"G-UNI underlying token1 decimals greater than 18.\");\n    uint256 to18Dec1 = 10**(18 - dec1);\n\n    // Get square root of underlying token prices\n    // token1/token0\n    // = (p0 / 10^dec0) / (p1 / 10^dec1)\n    // = (p0 * 10^dec1) / (p1 * 10^dec0)\n    // [From Uniswap's definition] sqrtPriceX96\n    // = sqrt(token1/token0) * 2^96\n    // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^96\n    // = sqrt((p0 * 10^dec1) / (p1 * 10^dec0)) * 2^48 * 2^48\n    // = sqrt((p0 * 10^dec1 * 2^96) / (p1 * 10^dec0)) * 2^48\n    uint160 sqrtPriceX96 = toUint160(sqrt((p0 * (10**dec1) * (1 << 96)) / (p1 * (10**dec0))) << 48);\n\n    // Get balances of the tokens in the pool given fair underlying token prices\n    (uint256 r0, uint256 r1) = pool.getUnderlyingBalancesAtPrice(sqrtPriceX96);\n    require(r0 > 0 || r1 > 0, \"G-UNI underlying token balances not both greater than 0.\");\n\n    // Add the total value of each token together and divide by the totalSupply to get the unit price\n    return (p0 * r0 * to18Dec0 + p1 * r1 * to18Dec1) / ERC20Upgradeable(token).totalSupply();\n  }\n\n  /**\n   * @dev Fast square root function.\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n   */\n  function sqrt(uint256 x) internal pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n\n  /**\n   * @dev Converts uint256 to uint160.\n   */\n  function toUint160(uint256 x) internal pure returns (uint160 z) {\n    require((z = uint160(x)) == x, \"Overflow when converting uint256 into uint160.\");\n  }\n}\n"
    },
    "contracts/oracles/mainnet/MStablePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/mstable/IMasset.sol\";\nimport \"../../external/mstable/ISavingsContractV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MStablePriceOracle\n * @notice Returns prices for the mStable imUSD ERC20 token.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital>\n */\ncontract MStablePriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev mStable mUSD ERC20 token contract object.\n   */\n  IMasset public constant MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n  /**\n   * @dev mStable imUSD ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n  /**\n   * @dev mStable mBTC ERC20 token contract object.\n   */\n  IMasset public constant MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n  /**\n   * @dev mStable imBTC ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    if (underlying == address(MUSD)) return getMAssetEthPrice(MUSD);\n    else if (underlying == address(IMUSD)) return (IMUSD.exchangeRate() * getMAssetEthPrice(MUSD)) / 1e18;\n    else if (underlying == address(MBTC)) return getMAssetEthPrice(MBTC);\n    else if (underlying == address(IMBTC)) return (IMBTC.exchangeRate() * getMAssetEthPrice(MBTC)) / 1e18;\n    else revert(\"Invalid token passed to MStablePriceOracle.\");\n  }\n\n  /**\n   * @dev Returns the price in ETH of the mAsset using `msg.sender` as a root price oracle for underlying bAssets.\n   */\n  function getMAssetEthPrice(IMasset mAsset) internal view returns (uint256) {\n    (IMasset.BassetPersonal[] memory bAssetPersonal, IMasset.BassetData[] memory bAssetData) = mAsset.getBassets();\n    uint256 underlyingValueInEthScaled = 0;\n    for (uint256 i = 0; i < bAssetData.length; i++) {\n      underlyingValueInEthScaled =\n        underlyingValueInEthScaled +\n        (((uint256(bAssetData[i].vaultBalance) * uint256(bAssetData[i].ratio)) / 1e8) *\n          BasePriceOracle(msg.sender).price(bAssetPersonal[i].addr));\n    }\n    return underlyingValueInEthScaled / ERC20Upgradeable(address(mAsset)).totalSupply();\n  }\n}\n"
    },
    "contracts/external/mstable/IMasset.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./MassetStructs.sol\";\n\n/**\n * @title IMasset\n * @dev   (Internal) Interface for interacting with Masset\n *        VERSION: 1.0\n *        DATE:    2020-05-05\n */\ninterface IMasset is MassetStructs {\n  // Mint\n  function mint(\n    address _input,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 mintOutput);\n\n  function mintMulti(\n    address[] calldata _inputs,\n    uint256[] calldata _inputQuantities,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 mintOutput);\n\n  function getMintOutput(address _input, uint256 _inputQuantity) external view returns (uint256 mintOutput);\n\n  function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\n    external\n    view\n    returns (uint256 mintOutput);\n\n  // Swaps\n  function swap(\n    address _input,\n    address _output,\n    uint256 _inputQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 swapOutput);\n\n  function getSwapOutput(\n    address _input,\n    address _output,\n    uint256 _inputQuantity\n  ) external view returns (uint256 swapOutput);\n\n  // Redemption\n  function redeem(\n    address _output,\n    uint256 _mAssetQuantity,\n    uint256 _minOutputQuantity,\n    address _recipient\n  ) external returns (uint256 outputQuantity);\n\n  function redeemMasset(\n    uint256 _mAssetQuantity,\n    uint256[] calldata _minOutputQuantities,\n    address _recipient\n  ) external returns (uint256[] memory outputQuantities);\n\n  function redeemExactBassets(\n    address[] calldata _outputs,\n    uint256[] calldata _outputQuantities,\n    uint256 _maxMassetQuantity,\n    address _recipient\n  ) external returns (uint256 mAssetRedeemed);\n\n  function getRedeemOutput(address _output, uint256 _mAssetQuantity) external view returns (uint256 bAssetOutput);\n\n  function getRedeemExactBassetsOutput(address[] calldata _outputs, uint256[] calldata _outputQuantities)\n    external\n    view\n    returns (uint256 mAssetAmount);\n\n  // Views\n  function getBasket() external view returns (bool, bool);\n\n  function getBasset(address _token) external view returns (BassetPersonal memory personal, BassetData memory data);\n\n  function getBassets() external view returns (BassetPersonal[] memory personal, BassetData[] memory data);\n\n  function bAssetIndexes(address) external view returns (uint8);\n\n  // SavingsManager\n  function collectInterest() external returns (uint256 swapFeesGained, uint256 newSupply);\n\n  function collectPlatformInterest() external returns (uint256 mintAmount, uint256 newSupply);\n\n  // Admin\n  function setCacheSize(uint256 _cacheSize) external;\n\n  function upgradeForgeValidator(address _newForgeValidator) external;\n\n  function setFees(uint256 _swapFee, uint256 _redemptionFee) external;\n\n  function setTransferFeesFlag(address _bAsset, bool _flag) external;\n\n  function migrateBassets(address[] calldata _bAssets, address _newIntegration) external;\n}\n"
    },
    "contracts/external/mstable/ISavingsContractV2.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\n/**\n * @title ISavingsContractV2\n */\ninterface ISavingsContractV2 {\n  function redeemCredits(uint256 _amount) external returns (uint256 underlyingReturned); // V2\n\n  function exchangeRate() external view returns (uint256); // V1 & V2\n}\n"
    },
    "contracts/external/mstable/MassetStructs.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.0;\n\ninterface MassetStructs {\n  struct BassetPersonal {\n    // Address of the bAsset\n    address addr;\n    // Address of the bAsset\n    address integrator;\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\n    bool hasTxFee; // takes a byte in storage\n    // Status of the bAsset\n    BassetStatus status;\n  }\n\n  struct BassetData {\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\n    uint128 ratio;\n    // Amount of the Basset that is held in Collateral\n    uint128 vaultBalance;\n  }\n\n  // Status of the Basset - has it broken its peg?\n  enum BassetStatus {\n    Default,\n    Normal,\n    BrokenBelowPeg,\n    BrokenAbovePeg,\n    Blacklisted,\n    Liquidating,\n    Liquidated,\n    Failed\n  }\n\n  struct BasketState {\n    bool undergoingRecol;\n    bool failed;\n  }\n\n  struct InvariantConfig {\n    uint256 a;\n    WeightLimits limits;\n  }\n\n  struct WeightLimits {\n    uint128 min;\n    uint128 max;\n  }\n\n  struct AmpData {\n    uint64 initialA;\n    uint64 targetA;\n    uint64 rampStartTime;\n    uint64 rampEndTime;\n  }\n}\n"
    },
    "contracts/liquidators/MStableLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/mstable/IMasset.sol\";\nimport \"../external/mstable/ISavingsContractV2.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title MStableLiquidator\n * @notice Redeems mUSD, imUSD, mBTC, and imBTC for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MStableLiquidator is IRedemptionStrategy {\n  /**\n   * @dev mStable imUSD ERC20 token contract object.\n   */\n  IMasset public constant MUSD = IMasset(0xe2f2a5C287993345a840Db3B0845fbC70f5935a5);\n\n  /**\n   * @dev mStable mUSD ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMUSD = ISavingsContractV2(0x30647a72Dc82d7Fbb1123EA74716aB8A317Eac19);\n\n  /**\n   * @dev mStable mBTC ERC20 token contract object.\n   */\n  IMasset public constant MBTC = IMasset(0x945Facb997494CC2570096c74b5F66A3507330a1);\n\n  /**\n   * @dev mStable imBTC ERC20 token contract object.\n   */\n  ISavingsContractV2 public constant IMBTC = ISavingsContractV2(0x17d8CBB6Bce8cEE970a4027d1198F6700A7a6c24);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get output token\n    if (strategyData.length > 0) (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n\n    // TODO: Choose asset to redeem dynamically\n    if (address(inputToken) == address(MUSD)) {\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n      outputAmount = MUSD.redeem(address(outputToken), inputAmount, 1, address(this));\n    } else if (address(inputToken) == address(IMUSD)) {\n      // Redeem imUSD for mUSD\n      uint256 mAssetReturned = IMUSD.redeemCredits(inputAmount);\n      require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // Output USDC by default\n      outputAmount = MUSD.redeem(address(outputToken), mAssetReturned, 1, address(this));\n    } else if (address(inputToken) == address(MBTC)) {\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n      outputAmount = MBTC.redeem(address(outputToken), inputAmount, 1, address(this));\n    } else if (address(inputToken) == address(IMBTC)) {\n      // Redeem imUSD for mUSD\n      uint256 mAssetReturned = IMBTC.redeemCredits(inputAmount);\n      require(mAssetReturned > 0, \"Error calling redeem on mStable savings contract: no mUSD returned.\");\n\n      // Redeem mUSD for USDC\n      if (address(outputToken) == address(0))\n        outputToken = IERC20Upgradeable(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599); // Output WBTC by default\n      outputAmount = MBTC.redeem(address(outputToken), mAssetReturned, 1, address(this));\n    }\n  }\n}\n"
    },
    "contracts/oracles/mainnet/TokemakPoolTAssetPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/tokemak/ILiquidityPool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title TokemakPoolTAssetPriceOracle\n * @notice Returns prices for Tokenmak pools (tAssets).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract TokemakPoolTAssetPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    return BasePriceOracle(msg.sender).price(address(ILiquidityPool(token).underlyer()));\n  }\n}\n"
    },
    "contracts/external/tokemak/ILiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title Interface for Pool\n/// @notice Allows users to deposit ERC-20 tokens to be deployed to market makers.\n/// @notice Mints 1:1 fToken on deposit, represeting an IOU for the undelrying token that is freely transferable.\n/// @notice Holders of fTokens earn rewards based on duration their tokens were deployed and the demand for that asset.\n/// @notice Holders of fTokens can redeem for underlying asset after issuing requestWithdrawal and waiting for the next cycle.\ninterface ILiquidityPool {\n  /// @return Reference to the underlying ERC-20 contract\n  function underlyer() external view returns (ERC20Upgradeable);\n}\n"
    },
    "contracts/oracles/mainnet/SynthetixPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/synthetix/AddressResolver.sol\";\nimport \"../../external/synthetix/ExchangeRates.sol\";\nimport \"../../external/synthetix/ISynth.sol\";\nimport \"../../external/synthetix/MixinResolver.sol\";\nimport \"../../external/synthetix/Proxy.sol\";\n\n/**\n * @title SynthetixPriceOracle\n * @notice Returns prices for Synths from Synthetix's official `ExchangeRates` contract.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixPriceOracle is IPriceOracle {\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    underlying = Proxy(underlying).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `resolver` and `currencyKey`\n    ExchangeRates exchangeRates = ExchangeRates(\n      MixinResolver(underlying).resolver().requireAndGetAddress(\n        \"ExchangeRates\",\n        \"Failed to get Synthetix's ExchangeRates contract address.\"\n      )\n    );\n    return (exchangeRates.effectiveValue(ISynth(underlying).currencyKey(), baseUnit, \"ETH\") * 1e18) / baseUnit;\n  }\n}\n"
    },
    "contracts/external/synthetix/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface AddressResolver {\n  function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n"
    },
    "contracts/external/synthetix/ExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ExchangeRates {\n  function effectiveValue(\n    bytes32 sourceCurrencyKey,\n    uint256 sourceAmount,\n    bytes32 destinationCurrencyKey\n  ) external view returns (uint256 value);\n}\n"
    },
    "contracts/external/synthetix/ISynth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISynth {\n  function currencyKey() external view returns (bytes32);\n}\n"
    },
    "contracts/external/synthetix/MixinResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./AddressResolver.sol\";\n\ncontract MixinResolver {\n  AddressResolver public resolver;\n}\n"
    },
    "contracts/external/synthetix/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ncontract Proxy {\n  address public target;\n}\n"
    },
    "contracts/liquidators/SynthetixSynthLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/synthetix/ISynthetix.sol\";\nimport \"../external/synthetix/ISynth.sol\";\nimport \"../external/synthetix/Proxy.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SynthetixSynthLiquidator\n * @notice Exchanges seized Synthetix Synth token collateral for more common Synthetix Synth tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SynthetixSynthLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Synthetix SNX token contract.\n   */\n  ISynthetix public constant SYNTHETIX = ISynthetix(0x97767D7D04Fd0dB0A1a2478DCd4BA85290556B48);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Swap Synth token for other Synth token (and store output as new collateral)\n    (outputToken) = abi.decode(strategyData, (IERC20Upgradeable));\n    address inputSynthLogic = Proxy(address(inputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n    address outputSynthLogic = Proxy(address(outputToken)).target(); // For some reason we have to use the logic contract instead of the proxy contract to get `currencyKey`\n    SYNTHETIX.exchange(ISynth(inputSynthLogic).currencyKey(), inputAmount, ISynth(outputSynthLogic).currencyKey());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/external/synthetix/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ISynthetix {\n  function exchange(\n    bytes32 sourceCurrencyKey,\n    uint256 sourceAmount,\n    bytes32 destinationCurrencyKey\n  ) external returns (uint256 amountReceived);\n}\n"
    },
    "contracts/oracles/mainnet/StakedSdtPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/stakedao/Sanctuary.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title StakedSdtPriceOracle\n * @notice Returns prices for Staked SDT (xSDT).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    Sanctuary sanctuary = Sanctuary(token);\n    IERC20Upgradeable sdt = sanctuary.sdt();\n    uint256 sdtEthPrice = BasePriceOracle(msg.sender).price(address(sdt));\n    return (sdt.balanceOf(token) * sdtEthPrice) / sanctuary.totalSupply();\n  }\n}\n"
    },
    "contracts/external/stakedao/Sanctuary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract Sanctuary is IERC20Upgradeable {\n  IERC20Upgradeable public sdt;\n\n  // Enter the Sanctuary. Pay some SDTs. Earn some shares.\n  function enter(uint256 _amount) public virtual;\n\n  // Leave the Sanctuary. Claim back your SDTs.\n  function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/liquidators/StakedSdtLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/stakedao/Sanctuary.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title StakedSdtLiquidator\n * @notice Redeems Staked SDT (xSDT) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract StakedSdtLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unstake xSDT (and store output SDT as new collateral)\n    Sanctuary sanctuary = Sanctuary(address(inputToken));\n    sanctuary.leave(inputAmount);\n    outputToken = IERC20Upgradeable(sanctuary.sdt());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/oracles/mainnet/Keep3rPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/keep3r/Keep3rV1Oracle.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title Keep3rPriceOracle\n * @notice Returns prices from `Keep3rV1Oracle` or `SushiswapV1Oracle`.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract Keep3rPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev Constructor that sets the Keep3rV1Oracle or SushiswapV1Oracle.\n   */\n  constructor(bool sushiSwap) {\n    Keep3rV1Oracle _rootOracle = Keep3rV1Oracle(\n      sushiSwap ? 0xf67Ab1c914deE06Ba0F264031885Ea7B276a7cDa : 0x73353801921417F465377c8d898c6f4C0270282C\n    );\n    rootOracle = _rootOracle;\n    uniswapV2Factory = IUniswapV2Factory(_rootOracle.factory());\n  }\n\n  /**\n   * @dev Keep3rV1Oracle token contract object.\n   */\n  Keep3rV1Oracle public immutable rootOracle;\n\n  /**\n   * @dev WETH token contract address.\n   */\n  address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @dev UniswapV2Factory contract address.\n   */\n  IUniswapV2Factory public immutable uniswapV2Factory;\n\n  /**\n   * @dev Minimum TWAP interval.\n   */\n  uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n  /**\n   * @dev Maximum TWAP interval.\n   */\n  uint256 public constant MAX_TWAP_TIME = 60 minutes;\n\n  /**\n   * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price0.\n   */\n  function price0TWAP(address pair) internal view returns (uint256) {\n    uint256 length = rootOracle.observationLength(pair);\n    require(length > 0, \"no length-1 observation\");\n    (uint256 lastTime, uint256 lastPx0Cumu, ) = rootOracle.observations(pair, length - 1);\n    if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"no length-2 observation\");\n      (lastTime, lastPx0Cumu, ) = rootOracle.observations(pair, length - 2);\n    }\n    uint256 elapsedTime = block.timestamp - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, \"bad TWAP time\");\n    uint256 currPx0Cumu = currentPx0Cumu(pair);\n    return (currPx0Cumu - lastPx0Cumu) / (block.timestamp - lastTime); // overflow is desired\n  }\n\n  /**\n   * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price1.\n   */\n  function price1TWAP(address pair) internal view returns (uint256) {\n    uint256 length = rootOracle.observationLength(pair);\n    require(length > 0, \"no length-1 observation\");\n    (uint256 lastTime, , uint256 lastPx1Cumu) = rootOracle.observations(pair, length - 1);\n    if (lastTime > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"no length-2 observation\");\n      (lastTime, , lastPx1Cumu) = rootOracle.observations(pair, length - 2);\n    }\n    uint256 elapsedTime = block.timestamp - lastTime;\n    require(elapsedTime >= MIN_TWAP_TIME && elapsedTime <= MAX_TWAP_TIME, \"bad TWAP time\");\n    uint256 currPx1Cumu = currentPx1Cumu(pair);\n    return (currPx1Cumu - lastPx1Cumu) / (block.timestamp - lastTime); // overflow is desired\n  }\n\n  /**\n   * @dev Return the current price0 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price0 cumulative value.\n   */\n  function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != block.timestamp) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Return the current price1 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price1 cumulative value.\n   */\n  function currentPx1Cumu(address pair) internal view returns (uint256 px1Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying ERC20 token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price, format, and return\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (_price(underlying) * 1e18) / baseUnit;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == WETH_ADDRESS) return 1e18;\n\n    // Call Keep3r for ERC20/ETH price and return\n    address pair = uniswapV2Factory.getPair(underlying, WETH_ADDRESS);\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (((underlying < WETH_ADDRESS ? price0TWAP(pair) : price1TWAP(pair)) / (2**56)) * baseUnit) / (2**56); // Scaled by 1e18, not 2 ** 112\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n}\n"
    },
    "contracts/external/keep3r/Keep3rV1Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nabstract contract Keep3rV1Oracle {\n  struct Observation {\n    uint256 timestamp;\n    uint256 price0Cumulative;\n    uint256 price1Cumulative;\n  }\n\n  function factory() external pure virtual returns (address);\n\n  mapping(address => Observation[]) public observations;\n\n  function observationLength(address pair) external view virtual returns (uint256);\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Root.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\nimport \"../../external/uniswap/IUniswapV2Factory.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Root\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Root {\n  /**\n   * @dev wtoken token contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev Minimum TWAP interval.\n   */\n  uint256 public constant MIN_TWAP_TIME = 15 minutes;\n\n  /**\n   * @dev Constructor to set wtoken address\n   */\n  constructor(address _wtoken) {\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @dev Return the TWAP value price0. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price0.\n   */\n  function price0TWAP(address pair) internal view returns (uint256) {\n    uint256 length = observationCount[pair];\n    require(length > 0, \"No length-1 TWAP observation.\");\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"No length-2 TWAP observation.\");\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n    }\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n    uint256 currPx0Cumu = currentPx0Cumu(pair);\n    return (currPx0Cumu - lastObservation.price0Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n  }\n\n  /**\n   * @dev Return the TWAP value price1. Revert if TWAP time range is not within the threshold.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The pair to query for price1.\n   */\n  function price1TWAP(address pair) internal view returns (uint256) {\n    uint256 length = observationCount[pair];\n    require(length > 0, \"No length-1 TWAP observation.\");\n    Observation memory lastObservation = observations[pair][(length - 1) % OBSERVATION_BUFFER];\n    if (lastObservation.timestamp > block.timestamp - MIN_TWAP_TIME) {\n      require(length > 1, \"No length-2 TWAP observation.\");\n      lastObservation = observations[pair][(length - 2) % OBSERVATION_BUFFER];\n    }\n    uint256 elapsedTime = block.timestamp - lastObservation.timestamp;\n    require(elapsedTime >= MIN_TWAP_TIME, \"Bad TWAP time.\");\n    uint256 currPx1Cumu = currentPx1Cumu(pair);\n    return (currPx1Cumu - lastObservation.price1Cumulative) / (block.timestamp - lastObservation.timestamp); // overflow is desired\n  }\n\n  /**\n   * @dev Return the current price0 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price0 cumulative value.\n   */\n  function currentPx0Cumu(address pair) internal view returns (uint256 px0Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px0Cumu = IUniswapV2Pair(pair).price0CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != block.timestamp) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px0Cumu += uint256((reserve1 << 112) / reserve0) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Return the current price1 cumulative value on Uniswap.\n   * Copied from: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BaseKP3ROracle.sol\n   * @param pair The uniswap pair to query for price1 cumulative value.\n   */\n  function currentPx1Cumu(address pair) internal view returns (uint256 px1Cumu) {\n    uint32 currTime = uint32(block.timestamp);\n    px1Cumu = IUniswapV2Pair(pair).price1CumulativeLast();\n    (uint256 reserve0, uint256 reserve1, uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    if (lastTime != currTime) {\n      uint32 timeElapsed = currTime - lastTime; // overflow is desired\n      px1Cumu += uint256((reserve0 << 112) / reserve1) * timeElapsed; // overflow is desired\n    }\n  }\n\n  /**\n   * @dev Returns the price of `underlying` in terms of `baseToken` given `factory`.\n   */\n  function price(\n    address underlying,\n    address baseToken,\n    address factory\n  ) external view returns (uint256) {\n    // Return ERC20/ETH TWAP\n    address pair = IUniswapV2Factory(factory).getPair(underlying, baseToken);\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (((underlying < baseToken ? price0TWAP(pair) : price1TWAP(pair)) / (2**56)) * baseUnit) / (2**56); // Scaled by 1e18, not 2 ** 112\n  }\n\n  /**\n   * @dev Struct for cumulative price observations.\n   */\n  struct Observation {\n    uint32 timestamp;\n    uint256 price0Cumulative;\n    uint256 price1Cumulative;\n  }\n\n  /**\n   * @dev Length after which observations roll over to index 0.\n   */\n  uint8 public constant OBSERVATION_BUFFER = 4;\n\n  /**\n   * @dev Total observation count for each pair.\n   */\n  mapping(address => uint256) public observationCount;\n\n  /**\n   * @dev Array of cumulative price observations for each pair.\n   */\n  mapping(address => Observation[OBSERVATION_BUFFER]) public observations;\n\n  /// @notice Get pairs for token combinations.\n  function pairsFor(\n    address[] calldata tokenA,\n    address[] calldata tokenB,\n    address factory\n  ) external view returns (address[] memory) {\n    require(\n      tokenA.length > 0 && tokenA.length == tokenB.length,\n      \"Token array lengths must be equal and greater than 0.\"\n    );\n    address[] memory pairs = new address[](tokenA.length);\n    for (uint256 i = 0; i < tokenA.length; i++) pairs[i] = IUniswapV2Factory(factory).getPair(tokenA[i], tokenB[i]);\n    return pairs;\n  }\n\n  /// @notice Check which of multiple pairs are workable/updatable.\n  function workable(\n    address[] calldata pairs,\n    address[] calldata baseTokens,\n    uint256[] calldata minPeriods,\n    uint256[] calldata deviationThresholds\n  ) external view returns (bool[] memory) {\n    require(\n      pairs.length > 0 &&\n        pairs.length == baseTokens.length &&\n        pairs.length == minPeriods.length &&\n        pairs.length == deviationThresholds.length,\n      \"Array lengths must be equal and greater than 0.\"\n    );\n    bool[] memory answers = new bool[](pairs.length);\n    for (uint256 i = 0; i < pairs.length; i++)\n      answers[i] = _workable(pairs[i], baseTokens[i], minPeriods[i], deviationThresholds[i]);\n    return answers;\n  }\n\n  /// @dev Internal function to check if a pair is workable (updateable AND reserves have changed AND deviation threshold is satisfied).\n  function _workable(\n    address pair,\n    address baseToken,\n    uint256 minPeriod,\n    uint256 deviationThreshold\n  ) internal view returns (bool) {\n    // Workable if:\n    // 1) We have no observations\n    // 2) The elapsed time since the last observation is > minPeriod AND reserves have changed AND deviation threshold is satisfied\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    if (observationCount[pair] <= 0) return true;\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    return\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\n      (minPeriod >= MIN_TWAP_TIME ? minPeriod : MIN_TWAP_TIME) &&\n      lastTime != observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp &&\n      _deviation(pair, baseToken) >= deviationThreshold;\n  }\n\n  /// @dev Internal function to check if a pair's spot price's deviation from its TWAP price as a ratio scaled by 1e18\n  function _deviation(address pair, address baseToken) internal view returns (uint256) {\n    // Get token base unit\n    address token0 = IUniswapV2Pair(pair).token0();\n    bool useToken0Price = token0 != baseToken;\n    address underlying = useToken0Price ? token0 : IUniswapV2Pair(pair).token1();\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n\n    // Get TWAP price\n    uint256 twapPrice = (((useToken0Price ? price0TWAP(pair) : price1TWAP(pair)) / (2**56)) * baseUnit) / (2**56); // Scaled by 1e18, not 2 ** 112\n\n    // Get spot price\n    (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pair).getReserves();\n    uint256 spotPrice = useToken0Price ? (reserve1 * baseUnit) / reserve0 : (reserve0 * baseUnit) / reserve1;\n\n    // Get ratio and return deviation\n    uint256 ratio = (spotPrice * 1e18) / twapPrice;\n    return ratio >= 1e18 ? ratio - 1e18 : 1e18 - ratio;\n  }\n\n  /// @dev Internal function to check if a pair is updatable at all.\n  function _updateable(address pair) internal view returns (bool) {\n    // Updateable if:\n    // 1) We have no observations\n    // 2) The elapsed time since the last observation is > MIN_TWAP_TIME\n    // Note that we loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    return\n      observationCount[pair] <= 0 ||\n      (block.timestamp - observations[pair][(observationCount[pair] - 1) % OBSERVATION_BUFFER].timestamp) >\n      MIN_TWAP_TIME;\n  }\n\n  /// @notice Update one pair.\n  function update(address pair) external {\n    require(_update(pair), \"Failed to update pair.\");\n  }\n\n  /// @notice Update multiple pairs at once.\n  function update(address[] calldata pairs) external {\n    bool worked = false;\n    for (uint256 i = 0; i < pairs.length; i++) if (_update(pairs[i])) worked = true;\n    require(worked, \"No pairs can be updated (yet).\");\n  }\n\n  /// @dev Internal function to update a single pair.\n  function _update(address pair) internal returns (bool) {\n    // Check if workable\n    if (!_updateable(pair)) return false;\n\n    // Get cumulative price(s)\n    uint256 price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    uint256 price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // Loop observationCount[pair] around OBSERVATION_BUFFER so we don't waste gas on new storage slots\n    (, , uint32 lastTime) = IUniswapV2Pair(pair).getReserves();\n    observations[pair][observationCount[pair] % OBSERVATION_BUFFER] = Observation(\n      lastTime,\n      price0Cumulative,\n      price1Cumulative\n    );\n    observationCount[pair]++;\n    return true;\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"./UniswapTwapPriceOracleV2Root.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2\n * @notice Stores cumulative prices and returns TWAPs for assets on Uniswap V2 pairs.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2 is Initializable, IPriceOracle, BasePriceOracle {\n  /**\n   * @dev wtoken token contract address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev UniswapTwapPriceOracleV2Root contract address.\n   */\n  UniswapTwapPriceOracleV2Root public rootOracle;\n\n  /**\n   * @dev UniswapV2Factory contract address.\n   */\n  address public uniswapV2Factory;\n\n  /**\n   * @dev The token on which to base TWAPs (its price must be available via `msg.sender`).\n   */\n  address public baseToken;\n\n  /**\n   * @dev Constructor that sets the UniswapTwapPriceOracleV2Root, UniswapV2Factory, and base token.\n   */\n  function initialize(\n    address _rootOracle,\n    address _uniswapV2Factory,\n    address _baseToken,\n    address _wtoken\n  ) external initializer {\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n    require(_uniswapV2Factory != address(0), \"UniswapV2Factory not defined.\");\n    rootOracle = UniswapTwapPriceOracleV2Root(_rootOracle);\n    uniswapV2Factory = _uniswapV2Factory;\n    wtoken = _wtoken;\n    baseToken = _baseToken == address(0) ? address(wtoken) : _baseToken;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying ERC20 token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price, format, and return\n    uint256 baseUnit = 10**uint256(ERC20Upgradeable(underlying).decimals());\n    return (_price(underlying) * 1e18) / baseUnit;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Return root oracle ERC20/ETH TWAP\n    uint256 twap = rootOracle.price(underlying, baseToken, uniswapV2Factory);\n    return\n      baseToken == address(wtoken)\n        ? twap\n        : (twap * BasePriceOracle(msg.sender).price(baseToken)) / (10**uint256(ERC20Upgradeable(baseToken).decimals()));\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapTwapPriceOracleV2Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\nimport \"./UniswapTwapPriceOracleV2.sol\";\n\n/**\n * @title UniswapTwapPriceOracleV2Factory\n * @notice Deploys and catalogs UniswapTwapPriceOracleV2 contracts.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapTwapPriceOracleV2Factory {\n  /**\n   * @dev WETH token contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev `UniswapTwapPriceOracleV2Root` contract address.\n   */\n  address public immutable rootOracle;\n\n  /**\n   * @dev Implementation address for the `UniswapV3TwapPriceOracleV2`.\n   */\n  address public immutable logic;\n\n  /**\n   * @notice Maps `UniswapV2Factory` contracts to base tokens to `UniswapTwapPriceOracleV2` contract addresses.\n   */\n  mapping(address => mapping(address => UniswapTwapPriceOracleV2)) public oracles;\n\n  /**\n   * @dev Constructor that sets the `UniswapTwapPriceOracleV2Root` and `UniswapTwapPriceOracleV2` implementation contract.\n   */\n  constructor(\n    address _rootOracle,\n    address _logic,\n    address _wtoken\n  ) {\n    require(_rootOracle != address(0), \"UniswapTwapPriceOracleV2Root not defined.\");\n    require(_logic != address(0), \"UniswapTwapPriceOracleV2 implementation/logic contract not defined.\");\n    rootOracle = _rootOracle;\n    logic = _logic;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @notice Deploys a `UniswapTwapPriceOracleV2`.\n   * @param uniswapV2Factory The `UniswapV2Factory` contract of the pairs for which this oracle will be used.\n   * @param baseToken The base token of the pairs for which this oracle will be used.\n   */\n  function deploy(address uniswapV2Factory, address baseToken) external returns (address) {\n    // Input validation\n    if (baseToken == address(0)) baseToken = address(wtoken);\n\n    // Return existing oracle if present\n    address currentOracle = address(oracles[uniswapV2Factory][baseToken]);\n    if (currentOracle != address(0)) return currentOracle;\n\n    // Deploy oracle\n    bytes32 salt = keccak256(abi.encodePacked(uniswapV2Factory, baseToken));\n    address oracle = ClonesUpgradeable.cloneDeterministic(logic, salt);\n    UniswapTwapPriceOracleV2(oracle).initialize(rootOracle, uniswapV2Factory, baseToken, wtoken);\n\n    // Set oracle in state\n    oracles[uniswapV2Factory][baseToken] = UniswapTwapPriceOracleV2(oracle);\n\n    // Return oracle address\n    return oracle;\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/utils/InitializableClones.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\n/**\n * @title InitializableClones\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice Deploys minimal proxy contracts (known as \"clones\") and initializes them.\n */\ncontract InitializableClones {\n  using AddressUpgradeable for address;\n\n  /**\n   * @dev Event emitted when a clone is deployed.\n   */\n  event Deployed(address instance);\n\n  /**\n   * @dev Deploys, initializes, and returns the address of a clone that mimics the behaviour of `master`.\n   */\n  function clone(address master, bytes memory initializer) external returns (address instance) {\n    instance = ClonesUpgradeable.clone(master);\n    instance.functionCall(initializer, \"Failed to initialize clone.\");\n    emit Deployed(instance);\n  }\n}\n"
    },
    "contracts/liquidators/CustomLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CustomLiquidator\n * @notice Redeems seized collateral tokens for the specified output token by calling the specified contract for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CustomLiquidator is IRedemptionStrategy {\n  using AddressUpgradeable for address;\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Call arbitrary contract\n    address target;\n    bytes memory data;\n    (target, data, outputToken) = abi.decode(strategyData, (address, bytes, IERC20Upgradeable));\n    target.functionCall(data);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n}\n"
    },
    "contracts/liquidators/UniswapV1Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/uniswap/IUniswapV1Exchange.sol\";\nimport \"../external/uniswap/IUniswapV1Factory.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title UniswapV1Liquidator\n * @notice Exchanges seized token collateral for underlying tokens via a Uniswap V1 pool for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract UniswapV1Liquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev The V1 Uniswap factory contract.\n   */\n  IUniswapV1Factory private constant UNISWAP_V1_FACTORY = IUniswapV1Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Get Uniswap exchange\n    IUniswapV1Exchange uniswapV1Exchange = IUniswapV1Exchange(UNISWAP_V1_FACTORY.getExchange(address(inputToken)));\n\n    // Swap underlying tokens\n    safeApprove(inputToken, address(uniswapV1Exchange), inputAmount);\n    uniswapV1Exchange.tokenToEthSwapInput(inputAmount, 1, block.timestamp);\n\n    // Get new collateral\n    outputAmount = address(this).balance;\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Exchange.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV1Exchange {\n  function tokenToEthSwapInput(\n    uint256 tokens_sold,\n    uint256 min_eth,\n    uint256 deadline\n  ) external returns (uint256);\n}\n"
    },
    "contracts/external/uniswap/IUniswapV1Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.8.0;\n\ninterface IUniswapV1Factory {\n  function getExchange(address token) external view returns (address);\n}\n"
    },
    "contracts/liquidators/CurveSwapLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveSwapLiquidator\n * @notice Swaps seized token collateral via Curve as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveSwapLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Exchange and store output\n    (ICurvePool curvePool, int128 i, int128 j, address jToken) = abi.decode(\n      strategyData,\n      (ICurvePool, int128, int128, address)\n    );\n    outputToken = IERC20Upgradeable(jToken == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : jToken);\n    safeApprove(inputToken, address(curvePool), inputAmount);\n    outputAmount = curvePool.exchange(i, j, inputAmount, 0);\n\n    // Convert to W_NATIVE if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n}\n"
    },
    "contracts/external/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface ICurveRegistry {\n  function get_n_coins(address lp) external view returns (uint256);\n\n  function get_coins(address pool) external view returns (address[8] memory);\n\n  function get_pool_from_lp_token(address lp) external view returns (address);\n}\n"
    },
    "contracts/external/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface ICurvePool {\n  function get_virtual_price() external view returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n\n  function exchange(\n    int128 i,\n    int128 j,\n    uint256 dx,\n    uint256 min_dy\n  ) external returns (uint256);\n}\n"
    },
    "contracts/oracles/mainnet/CurveLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/curve/ICurveRegistry.sol\";\nimport \"../../external/curve/ICurvePool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLpTokenPriceOracle is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveLpTokenPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n   * @param lpToken The LP token contract address for price retrieval.\n   */\n  function _price(address lpToken) internal view returns (uint256) {\n    address pool = poolOf[lpToken];\n    require(pool != address(0), \"LP token is not registered.\");\n    address[] memory tokens = underlyingTokens[lpToken];\n    uint256 minPx = type(uint256).max;\n    uint256 n = tokens.length;\n\n    for (uint256 i = 0; i < n; i++) {\n      address ulToken = tokens[i];\n      uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n\n    require(minPx != type(uint256).max, \"No minimum underlying token price found.\");\n    return (minPx * ICurvePool(pool).get_virtual_price()) / 1e18; // Use min underlying token prices\n  }\n\n  /**\n   * @dev The Curve registry.\n   */\n  ICurveRegistry public constant registry = ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c);\n\n  /**\n   * @dev Maps Curve LP token addresses to underlying token addresses.\n   */\n  mapping(address => address[]) public underlyingTokens;\n\n  /**\n   * @dev Maps Curve LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolOf;\n\n  /**\n   * @dev Register the pool given LP token address and set the pool info.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n   * @param lpToken LP token to find the corresponding pool.\n   */\n  function registerPool(address lpToken) external {\n    address pool = poolOf[lpToken];\n    require(pool == address(0), \"This LP token is already registered.\");\n    pool = registry.get_pool_from_lp_token(lpToken);\n    require(pool != address(0), \"No corresponding pool found for this LP token in the Curve registry.\");\n    poolOf[lpToken] = pool;\n    uint256 n = registry.get_n_coins(pool);\n    address[8] memory tokens = registry.get_coins(pool);\n    for (uint256 i = 0; i < n; i++) underlyingTokens[lpToken].push(tokens[i]);\n  }\n}\n"
    },
    "contracts/oracles/default/CurveLpTokenPriceOracleNoRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/curve/ICurveRegistry.sol\";\nimport \"../../external/curve/ICurvePool.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLpTokenPriceOracle is a price oracle for Curve LP tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract CurveLpTokenPriceOracleNoRegistry is IPriceOracle, BasePriceOracle, OwnableUpgradeable {\n  /**\n   * @dev Maps Curve LP token addresses to underlying token addresses.\n   */\n  mapping(address => address[]) public underlyingTokens;\n\n  /**\n   * @dev Maps Curve LP token addresses to pool addresses.\n   */\n  mapping(address => address) public poolOf;\n\n  /**\n   * @dev Initializes an array of LP tokens and pools if desired.\n   * @param _lpTokens Array of LP token addresses.\n   * @param _pools Array of pool addresses.\n   */\n  function initialize(\n    address[] memory _lpTokens,\n    address[] memory _pools,\n    address[][] memory _poolUnderlyings\n  ) public initializer {\n    __Ownable_init();\n    for (uint256 i = 0; i < _lpTokens.length; i++) {\n      poolOf[_lpTokens[i]] = _pools[i];\n      underlyingTokens[_lpTokens[i]] = _poolUnderlyings[i];\n    }\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Curve, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/CurveOracle.sol\n   * @param lpToken The LP token contract address for price retrieval.\n   */\n  function _price(address lpToken) internal view returns (uint256) {\n    address pool = poolOf[lpToken];\n    require(pool != address(0), \"LP token is not registered.\");\n    address[] memory tokens = underlyingTokens[lpToken];\n    uint256 minPx = type(uint256).max;\n    uint256 n = tokens.length;\n\n    for (uint256 i = 0; i < n; i++) {\n      address ulToken = tokens[i];\n      uint256 tokenPx = BasePriceOracle(msg.sender).price(ulToken);\n      if (tokenPx < minPx) minPx = tokenPx;\n    }\n\n    require(minPx != type(uint256).max, \"No minimum underlying token price found.\");\n    return (minPx * ICurvePool(pool).get_virtual_price()) / 1e18; // Use min underlying token prices\n  }\n\n  /**\n   * @dev Register the pool given LP token address and set the pool info.\n   * @param _lpToken LP token to find the corresponding pool.\n   * @param _pool Pool address.\n   * @param _underlyings Underlying addresses.\n   */\n  function registerPool(\n    address _lpToken,\n    address _pool,\n    address[] memory _underlyings\n  ) external onlyOwner {\n    address pool = poolOf[_lpToken];\n    require(pool == address(0), \"This LP token is already registered.\");\n    poolOf[_lpToken] = _pool;\n    underlyingTokens[_lpToken] = _underlyings;\n  }\n}\n"
    },
    "contracts/FusePoolDirectory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/Create2Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IUnitroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./compound/Unitroller.sol\";\n\n/**\n * @title FusePoolDirectory\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolDirectory is a directory for Fuse interest rate pools.\n */\ncontract FusePoolDirectory is OwnableUpgradeable {\n  /**\n   * @dev Initializes a deployer whitelist if desired.\n   * @param _enforceDeployerWhitelist Boolean indicating if the deployer whitelist is to be enforced.\n   * @param _deployerWhitelist Array of Ethereum accounts to be whitelisted.\n   */\n  function initialize(bool _enforceDeployerWhitelist, address[] memory _deployerWhitelist) public initializer {\n    __Ownable_init();\n    enforceDeployerWhitelist = _enforceDeployerWhitelist;\n    for (uint256 i = 0; i < _deployerWhitelist.length; i++) deployerWhitelist[_deployerWhitelist[i]] = true;\n  }\n\n  /**\n   * @dev Struct for a Fuse interest rate pool.\n   */\n  struct FusePool {\n    string name;\n    address creator;\n    address comptroller;\n    uint256 blockPosted;\n    uint256 timestampPosted;\n  }\n\n  /**\n   * @dev Array of Fuse interest rate pools.\n   */\n  FusePool[] public pools;\n\n  /**\n   * @dev Maps Ethereum accounts to arrays of Fuse pool indexes.\n   */\n  mapping(address => uint256[]) private _poolsByAccount;\n\n  /**\n   * @dev Maps Fuse pool Comptroller addresses to bools indicating if they have been registered via the directory.\n   */\n  mapping(address => bool) public poolExists;\n\n  /**\n   * @dev Emitted when a new Fuse pool is added to the directory.\n   */\n  event PoolRegistered(uint256 index, FusePool pool);\n\n  /**\n   * @dev Booleans indicating if the deployer whitelist is enforced.\n   */\n  bool public enforceDeployerWhitelist;\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are allowed to deploy pools.\n   */\n  mapping(address => bool) public deployerWhitelist;\n\n  /**\n   * @dev Controls if the deployer whitelist is to be enforced.\n   * @param enforce Boolean indicating if the deployer whitelist is to be enforced.\n   */\n  function _setDeployerWhitelistEnforcement(bool enforce) external onlyOwner {\n    enforceDeployerWhitelist = enforce;\n  }\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the deployer whitelist.\n   * @param deployers Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editDeployerWhitelist(address[] calldata deployers, bool status) external onlyOwner {\n    require(deployers.length > 0, \"No deployers supplied.\");\n    for (uint256 i = 0; i < deployers.length; i++) deployerWhitelist[deployers[i]] = status;\n  }\n\n  /**\n   * @dev Adds a new Fuse pool to the directory (without checking msg.sender).\n   * @param name The name of the pool.\n   * @param comptroller The pool's Comptroller proxy contract address.\n   * @return The index of the registered Fuse pool.\n   */\n  function _registerPool(string memory name, address comptroller) internal returns (uint256) {\n    require(!poolExists[comptroller], \"Pool already exists in the directory.\");\n    require(!enforceDeployerWhitelist || deployerWhitelist[msg.sender], \"Sender is not on deployer whitelist.\");\n    require(bytes(name).length <= 100, \"No pool name supplied.\");\n    FusePool memory pool = FusePool(name, msg.sender, comptroller, block.number, block.timestamp);\n    pools.push(pool);\n    _poolsByAccount[msg.sender].push(pools.length - 1);\n    poolExists[comptroller] = true;\n    emit PoolRegistered(pools.length - 1, pool);\n    return pools.length - 1;\n  }\n\n  /**\n   * @dev Deploys a new Fuse pool and adds to the directory.\n   * @param name The name of the pool.\n   * @param implementation The Comptroller implementation contract address.\n   * @param enforceWhitelist Boolean indicating if the pool's supplier/borrower whitelist is to be enforced.\n   * @param closeFactor The pool's close factor (scaled by 1e18).\n   * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18).\n   * @param priceOracle The pool's PriceOracle contract address.\n   * @return The index of the registered Fuse pool and the Unitroller proxy address.\n   */\n  function deployPool(\n    string memory name,\n    address implementation,\n    bool enforceWhitelist,\n    uint256 closeFactor,\n    uint256 liquidationIncentive,\n    address priceOracle\n  ) external returns (uint256, address) {\n    // Input validation\n    require(implementation != address(0), \"No Comptroller implementation contract address specified.\");\n    require(priceOracle != address(0), \"No PriceOracle contract address specified.\");\n\n    // Deploy CEtherDelegator using msg.sender, underlying, and block.number as a salt\n    //        bytes32 salt = keccak256(abi.encodePacked(msg.sender, address(0), block.number));\n    //\n\n    //        address proxy = Create2Upgradeable.deploy(0, salt, cEtherDelegatorCreationCode);\n\n    // Deploy Unitroller using msg.sender, name, and block.number as a salt\n    bytes32 salt = keccak256(abi.encodePacked(msg.sender, name, block.number));\n    bytes memory unitrollerCreationCode = abi.encodePacked(type(Unitroller).creationCode);\n    address proxy = Create2Upgradeable.deploy(0, salt, unitrollerCreationCode);\n\n    // Setup Unitroller\n    IUnitroller unitroller = IUnitroller(proxy);\n    require(\n      unitroller._setPendingImplementation(implementation) == 0,\n      \"Failed to set pending implementation on Unitroller.\"\n    ); // Checks Comptroller implementation whitelist\n    IComptroller comptrollerImplementation = IComptroller(implementation);\n    comptrollerImplementation._become(unitroller);\n    IComptroller comptrollerProxy = IComptroller(proxy);\n\n    // Set pool parameters\n    require(comptrollerProxy._setCloseFactor(closeFactor) == 0, \"Failed to set pool close factor.\");\n    require(\n      comptrollerProxy._setLiquidationIncentive(liquidationIncentive) == 0,\n      \"Failed to set pool liquidation incentive.\"\n    );\n    require(comptrollerProxy._setPriceOracle(IPriceOracle(priceOracle)) == 0, \"Failed to set pool price oracle.\");\n\n    // Whitelist\n    if (enforceWhitelist)\n      require(comptrollerProxy._setWhitelistEnforcement(true) == 0, \"Failed to enforce supplier/borrower whitelist.\");\n\n    // Enable auto-implementation\n    require(comptrollerProxy._toggleAutoImplementations(true) == 0, \"Failed to enable pool auto implementations.\");\n\n    // Make msg.sender the admin\n    require(unitroller._setPendingAdmin(msg.sender) == 0, \"Failed to set pending admin on Unitroller.\");\n\n    // Register the pool with this FusePoolDirectory\n    return (_registerPool(name, proxy), proxy);\n  }\n\n  /**\n   * @notice Returns arrays of all Fuse pools' data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getAllPools() external view returns (FusePool[] memory) {\n    return pools;\n  }\n\n  /**\n   * @notice Returns arrays of all public Fuse pool indexes and data.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPools() external view returns (uint256[] memory, FusePool[] memory) {\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try IComptroller(pools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    FusePool[] memory publicPools = new FusePool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try IComptroller(pools[i].comptroller).enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = pools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n\n  /**\n   * @notice Returns arrays of Fuse pool indexes and data created by `account`.\n   */\n  function getPoolsByAccount(address account) external view returns (uint256[] memory, FusePool[] memory) {\n    uint256[] memory indexes = new uint256[](_poolsByAccount[account].length);\n    FusePool[] memory accountPools = new FusePool[](_poolsByAccount[account].length);\n\n    for (uint256 i = 0; i < _poolsByAccount[account].length; i++) {\n      indexes[i] = _poolsByAccount[account][i];\n      accountPools[i] = pools[_poolsByAccount[account][i]];\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @dev Maps Ethereum accounts to arrays of Fuse pool Comptroller proxy contract addresses.\n   */\n  mapping(address => address[]) private _bookmarks;\n\n  /**\n   * @notice Returns arrays of Fuse pool Unitroller (Comptroller proxy) contract addresses bookmarked by `account`.\n   */\n  function getBookmarks(address account) external view returns (address[] memory) {\n    return _bookmarks[account];\n  }\n\n  /**\n   * @notice Bookmarks a Fuse pool Unitroller (Comptroller proxy) contract addresses.\n   */\n  function bookmarkPool(address comptroller) external {\n    _bookmarks[msg.sender].push(comptroller);\n  }\n\n  /**\n   * @notice Modify existing Fuse pool name.\n   */\n  function setPoolName(uint256 index, string calldata name) external {\n    IComptroller _comptroller = IComptroller(pools[index].comptroller);\n    require((msg.sender == _comptroller.admin() && _comptroller.adminHasRights()) || msg.sender == owner());\n    pools[index].name = name;\n  }\n\n  /**\n   * @dev Maps Ethereum accounts to booleans indicating if they are a whitelisted admin.\n   */\n  mapping(address => bool) public adminWhitelist;\n\n  /**\n   * @dev Event emitted when the admin whitelist is updated.\n   */\n  event AdminWhitelistUpdated(address[] admins, bool status);\n\n  /**\n   * @dev Adds/removes Ethereum accounts to the admin whitelist.\n   * @param admins Array of Ethereum accounts to be whitelisted.\n   * @param status Whether to add or remove the accounts.\n   */\n  function _editAdminWhitelist(address[] calldata admins, bool status) external onlyOwner {\n    require(admins.length > 0, \"No admins supplied.\");\n    for (uint256 i = 0; i < admins.length; i++) adminWhitelist[admins[i]] = status;\n    emit AdminWhitelistUpdated(admins, status);\n  }\n\n  /**\n   * @notice Returns arrays of all public Fuse pool indexes and data with whitelisted admins.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPublicPoolsByVerification(bool whitelistedAdmin)\n    external\n    view\n    returns (uint256[] memory, FusePool[] memory)\n  {\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n\n        try comptroller.admin() returns (address admin) {\n          if (whitelistedAdmin != adminWhitelist[admin]) continue;\n        } catch {}\n      } catch {}\n\n      arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    FusePool[] memory publicPools = new FusePool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      try comptroller.enforceWhitelist() returns (bool enforceWhitelist) {\n        if (enforceWhitelist) continue;\n\n        try comptroller.admin() returns (address admin) {\n          if (whitelistedAdmin != adminWhitelist[admin]) continue;\n        } catch {}\n      } catch {}\n\n      indexes[index] = i;\n      publicPools[index] = pools[i];\n      index++;\n    }\n\n    return (indexes, publicPools);\n  }\n}\n"
    },
    "contracts/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./IPriceOracle.sol\";\nimport \"./ICToken.sol\";\nimport \"./IUnitroller.sol\";\nimport \"./IRewardsDistributor.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ninterface IComptroller {\n  function admin() external view returns (address);\n\n  function adminHasRights() external view returns (bool);\n\n  function fuseAdminHasRights() external view returns (bool);\n\n  function oracle() external view returns (IPriceOracle);\n\n  function closeFactorMantissa() external view returns (uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  function markets(address cToken) external view returns (bool, uint256);\n\n  function getAssetsIn(address account) external view returns (ICToken[] memory);\n\n  function checkMembership(address account, ICToken cToken) external view returns (bool);\n\n  function getAccountLiquidity(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function _setPriceOracle(IPriceOracle newOracle) external returns (uint256);\n\n  function _setCloseFactor(uint256 newCloseFactorMantissa) external returns (uint256);\n\n  function _setLiquidationIncentive(uint256 newLiquidationIncentiveMantissa) external returns (uint256);\n\n  function _become(IUnitroller unitroller) external;\n\n  function borrowGuardianPaused(address cToken) external view returns (bool);\n\n  function getRewardsDistributors() external view returns (IRewardsDistributor[] memory);\n\n  function getAllMarkets() external view returns (ICToken[] memory);\n\n  function getAllBorrowers() external view returns (address[] memory);\n\n  function suppliers(address account) external view returns (bool);\n\n  function enforceWhitelist() external view returns (bool);\n\n  function whitelist(address account) external view returns (bool);\n\n  function _setWhitelistEnforcement(bool enforce) external returns (uint256);\n\n  function _setWhitelistStatuses(address[] calldata _suppliers, bool[] calldata statuses) external returns (uint256);\n\n  function _toggleAutoImplementations(bool enabled) external returns (uint256);\n}\n"
    },
    "contracts/external/compound/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ninterface IUnitroller {\n  function _setPendingImplementation(address newPendingImplementation) external returns (uint256);\n\n  function _setPendingAdmin(address newPendingAdmin) external returns (uint256);\n}\n"
    },
    "contracts/external/compound/IRewardsDistributor.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\nimport \"./ICToken.sol\";\n\n/**\n * @title RewardsDistributor\n * @author Compound\n */\ninterface IRewardsDistributor {\n  /// @dev The token to reward (i.e., COMP)\n  function rewardToken() external view returns (address);\n\n  /// @notice The portion of compRate that each market currently receives\n  function compSupplySpeeds(address) external view returns (uint256);\n\n  /// @notice The portion of compRate that each market currently receives\n  function compBorrowSpeeds(address) external view returns (uint256);\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  function compAccrued(address) external view returns (uint256);\n\n  /**\n   * @notice Keeps the flywheel moving pre-mint and pre-redeem\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param supplier The minter/redeemer\n   */\n  function flywheelPreSupplierAction(address cToken, address supplier) external;\n\n  /**\n   * @notice Keeps the flywheel moving pre-borrow and pre-repay\n   * @dev Called by the Comptroller\n   * @param cToken The relevant market\n   * @param borrower The borrower\n   */\n  function flywheelPreBorrowerAction(address cToken, address borrower) external;\n\n  /**\n   * @notice Returns an array of all markets.\n   */\n  function getAllMarkets() external view returns (ICToken[] memory);\n}\n"
    },
    "contracts/FusePoolLensSecondary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\n\n/**\n * @title FusePoolLensSecondary\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLensSecondary returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLensSecondary is Initializable {\n  /**\n   * @notice Constructor to set the `FusePoolDirectory` contract object.\n   */\n  function initialize(FusePoolDirectory _directory) public initializer {\n    require(address(_directory) != address(0), \"FusePoolDirectory instance cannot be the zero address.\");\n    directory = _directory;\n  }\n\n  /**\n   * @notice `FusePoolDirectory` contract object.\n   */\n  FusePoolDirectory public directory;\n\n  /**\n   * @notice Struct for ownership over a CToken.\n   */\n  struct CTokenOwnership {\n    address cToken;\n    address admin;\n    bool adminHasRights;\n    bool fuseAdminHasRights;\n  }\n\n  /**\n   * @notice Returns the admin, admin rights, Fuse admin (constant), Fuse admin rights, and an array of cTokens with differing properties.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolOwnership(IComptroller comptroller)\n    external\n    view\n    returns (\n      address,\n      bool,\n      bool,\n      CTokenOwnership[] memory\n    )\n  {\n    // Get pool ownership\n    address comptrollerAdmin = comptroller.admin();\n    bool comptrollerAdminHasRights = comptroller.adminHasRights();\n    bool comptrollerFuseAdminHasRights = comptroller.fuseAdminHasRights();\n\n    // Get cToken ownership\n    ICToken[] memory cTokens = comptroller.getAllMarkets();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICToken cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n\n      address cTokenAdmin;\n      try cToken.admin() returns (address _cTokenAdmin) {\n        cTokenAdmin = _cTokenAdmin;\n      } catch {\n        continue;\n      }\n      bool cTokenAdminHasRights = cToken.adminHasRights();\n      bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n      // If outlier, push to array\n      if (\n        cTokenAdmin != comptrollerAdmin ||\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\n        cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights\n      ) arrayLength++;\n    }\n\n    CTokenOwnership[] memory outliers = new CTokenOwnership[](arrayLength);\n    uint256 arrayIndex = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICToken cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n\n      address cTokenAdmin;\n      try cToken.admin() returns (address _cTokenAdmin) {\n        cTokenAdmin = _cTokenAdmin;\n      } catch {\n        continue;\n      }\n      bool cTokenAdminHasRights = cToken.adminHasRights();\n      bool cTokenFuseAdminHasRights = cToken.fuseAdminHasRights();\n\n      // If outlier, push to array and increment array index\n      if (\n        cTokenAdmin != comptrollerAdmin ||\n        cTokenAdminHasRights != comptrollerAdminHasRights ||\n        cTokenFuseAdminHasRights != comptrollerFuseAdminHasRights\n      ) {\n        outliers[arrayIndex] = CTokenOwnership(\n          address(cToken),\n          cTokenAdmin,\n          cTokenAdminHasRights,\n          cTokenFuseAdminHasRights\n        );\n        arrayIndex++;\n      }\n    }\n\n    return (comptrollerAdmin, comptrollerAdminHasRights, comptrollerFuseAdminHasRights, outliers);\n  }\n\n  /**\n   * @notice Determine the maximum redeem amount of a cToken.\n   * @param cTokenModify The market to hypothetically redeem in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum redeem amount.\n   */\n  function getMaxRedeem(address account, ICToken cTokenModify) external returns (uint256) {\n    return getMaxRedeemOrBorrow(account, cTokenModify, false);\n  }\n\n  /**\n   * @notice Determine the maximum borrow amount of a cToken.\n   * @param cTokenModify The market to hypothetically borrow in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum borrow amount.\n   */\n  function getMaxBorrow(address account, ICToken cTokenModify) external returns (uint256) {\n    return getMaxRedeemOrBorrow(account, cTokenModify, true);\n  }\n\n  /**\n   * @dev Internal function to determine the maximum borrow/redeem amount of a cToken.\n   * @param cTokenModify The market to hypothetically borrow/redeem in.\n   * @param account The account to determine liquidity for.\n   * @return Maximum borrow/redeem amount.\n   */\n  function getMaxRedeemOrBorrow(\n    address account,\n    ICToken cTokenModify,\n    bool isBorrow\n  ) internal returns (uint256) {\n    // Accrue interest\n    uint256 balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n\n    // Get account liquidity\n    IComptroller comptroller = IComptroller(cTokenModify.comptroller());\n    (uint256 err, uint256 liquidity, uint256 shortfall) = comptroller.getAccountLiquidity(account);\n    require(err == 0, \"Comptroller error when calculating account liquidity.\");\n    if (shortfall > 0) return 0; // Shortfall, so no more borrow/redeem\n\n    // Get max borrow/redeem\n    uint256 maxBorrowOrRedeemAmount;\n\n    if (!isBorrow && !comptroller.checkMembership(msg.sender, cTokenModify)) {\n      // Max redeem = balance of underlying if not used as collateral\n      maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    } else {\n      // Avoid \"stack too deep\" error by separating this logic\n      maxBorrowOrRedeemAmount = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\n\n      // Redeem only: max out at underlying balance\n      if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\n    }\n\n    // Get max borrow or redeem considering cToken liquidity\n    uint256 cTokenLiquidity = cTokenModify.getCash();\n\n    // Return the minimum of the two maximums\n    return maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity;\n  }\n\n  /**\n   * @dev Portion of the logic in `getMaxRedeemOrBorrow` above separated to avoid \"stack too deep\" errors.\n   */\n  function _getMaxRedeemOrBorrow(\n    uint256 liquidity,\n    ICToken cTokenModify,\n    bool isBorrow\n  ) internal view returns (uint256) {\n    if (liquidity <= 0) return 0; // No available account liquidity, so no more borrow/redeem\n\n    // Get the normalized price of the asset\n    IComptroller comptroller = IComptroller(cTokenModify.comptroller());\n    uint256 conversionFactor = comptroller.oracle().getUnderlyingPrice(cTokenModify);\n    require(conversionFactor > 0, \"Oracle price error.\");\n\n    // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n    if (!isBorrow) {\n      (, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokenModify));\n      conversionFactor = (collateralFactorMantissa * conversionFactor) / 1e18;\n    }\n\n    // Get max borrow or redeem considering excess account liquidity\n    return (liquidity * 1e18) / conversionFactor;\n  }\n\n  /**\n   * @notice Returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n   * @param comptroller The Fuse pool Comptroller to check.\n   */\n  function getRewardSpeedsByPool(IComptroller comptroller)\n    public\n    view\n    returns (\n      ICToken[] memory,\n      IRewardsDistributor[] memory,\n      address[] memory,\n      uint256[][] memory,\n      uint256[][] memory\n    )\n  {\n    ICToken[] memory allMarkets = comptroller.getAllMarkets();\n    IRewardsDistributor[] memory distributors;\n\n    try comptroller.getRewardsDistributors() returns (IRewardsDistributor[] memory _distributors) {\n      distributors = _distributors;\n    } catch {\n      distributors = new IRewardsDistributor[](0);\n    }\n\n    address[] memory rewardTokens = new address[](distributors.length);\n    uint256[][] memory supplySpeeds = new uint256[][](allMarkets.length);\n    uint256[][] memory borrowSpeeds = new uint256[][](allMarkets.length);\n\n    // Get reward tokens for each distributor\n    for (uint256 i = 0; i < distributors.length; i++) rewardTokens[i] = distributors[i].rewardToken();\n\n    // Get reward speeds for each market for each distributor\n    for (uint256 i = 0; i < allMarkets.length; i++) {\n      address cToken = address(allMarkets[i]);\n      supplySpeeds[i] = new uint256[](distributors.length);\n      borrowSpeeds[i] = new uint256[](distributors.length);\n\n      for (uint256 j = 0; j < distributors.length; j++) {\n        IRewardsDistributor distributor = distributors[j];\n        supplySpeeds[i][j] = distributor.compSupplySpeeds(cToken);\n        borrowSpeeds[i][j] = distributor.compBorrowSpeeds(cToken);\n      }\n    }\n\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n  }\n\n  /**\n   * @notice For each `Comptroller`, returns an array of all markets, an array of all `RewardsDistributor` contracts, an array of reward token addresses for each `RewardsDistributor`, an array of supply speeds for each distributor for each, and their borrow speeds.\n   * @param comptrollers The Fuse pool Comptrollers to check.\n   */\n  function getRewardSpeedsByPools(IComptroller[] memory comptrollers)\n    external\n    view\n    returns (\n      ICToken[][] memory,\n      IRewardsDistributor[][] memory,\n      address[][] memory,\n      uint256[][][] memory,\n      uint256[][][] memory\n    )\n  {\n    ICToken[][] memory allMarkets = new ICToken[][](comptrollers.length);\n    IRewardsDistributor[][] memory distributors = new IRewardsDistributor[][](comptrollers.length);\n    address[][] memory rewardTokens = new address[][](comptrollers.length);\n    uint256[][][] memory supplySpeeds = new uint256[][][](comptrollers.length);\n    uint256[][][] memory borrowSpeeds = new uint256[][][](comptrollers.length);\n    for (uint256 i = 0; i < comptrollers.length; i++)\n      (allMarkets[i], distributors[i], rewardTokens[i], supplySpeeds[i], borrowSpeeds[i]) = getRewardSpeedsByPool(\n        comptrollers[i]\n      );\n    return (allMarkets, distributors, rewardTokens, supplySpeeds, borrowSpeeds);\n  }\n\n  /**\n   * @notice Returns unaccrued rewards by `holder` from `cToken` on `distributor`.\n   * @param holder The address to check.\n   * @param distributor The RewardsDistributor to check.\n   * @param cToken The CToken to check.\n   * @return Unaccrued (unclaimed) supply-side rewards and unaccrued (unclaimed) borrow-side rewards.\n   */\n  function getUnaccruedRewards(\n    address holder,\n    IRewardsDistributor distributor,\n    ICToken cToken\n  ) internal returns (uint256, uint256) {\n    // Get unaccrued supply rewards\n    uint256 compAccruedPrior = distributor.compAccrued(holder);\n    distributor.flywheelPreSupplierAction(address(cToken), holder);\n    uint256 supplyRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\n\n    // Get unaccrued borrow rewards\n    compAccruedPrior = distributor.compAccrued(holder);\n    distributor.flywheelPreBorrowerAction(address(cToken), holder);\n    uint256 borrowRewardsUnaccrued = distributor.compAccrued(holder) - compAccruedPrior;\n\n    // Return both\n    return (supplyRewardsUnaccrued, borrowRewardsUnaccrued);\n  }\n\n  /**\n   * @notice Returns all unclaimed rewards accrued by the `holder` on `distributors`.\n   * @param holder The address to check.\n   * @param distributors The `RewardsDistributor` contracts to check.\n   * @return For each of `distributors`: total quantity of unclaimed rewards, array of cTokens, array of unaccrued (unclaimed) supply-side and borrow-side rewards per cToken, and quantity of funds available in the distributor.\n   */\n  function getUnclaimedRewardsByDistributors(address holder, IRewardsDistributor[] memory distributors)\n    external\n    returns (\n      address[] memory,\n      uint256[] memory,\n      ICToken[][] memory,\n      uint256[2][][] memory,\n      uint256[] memory\n    )\n  {\n    address[] memory rewardTokens = new address[](distributors.length);\n    uint256[] memory compUnclaimedTotal = new uint256[](distributors.length);\n    ICToken[][] memory allMarkets = new ICToken[][](distributors.length);\n    uint256[2][][] memory rewardsUnaccrued = new uint256[2][][](distributors.length);\n    uint256[] memory distributorFunds = new uint256[](distributors.length);\n\n    for (uint256 i = 0; i < distributors.length; i++) {\n      IRewardsDistributor distributor = distributors[i];\n      rewardTokens[i] = distributor.rewardToken();\n      allMarkets[i] = distributor.getAllMarkets();\n      rewardsUnaccrued[i] = new uint256[2][](allMarkets[i].length);\n      for (uint256 j = 0; j < allMarkets[i].length; j++)\n        (rewardsUnaccrued[i][j][0], rewardsUnaccrued[i][j][1]) = getUnaccruedRewards(\n          holder,\n          distributor,\n          allMarkets[i][j]\n        );\n      compUnclaimedTotal[i] = distributor.compAccrued(holder);\n      distributorFunds[i] = IERC20Upgradeable(rewardTokens[i]).balanceOf(address(distributor));\n    }\n\n    return (rewardTokens, compUnclaimedTotal, allMarkets, rewardsUnaccrued, distributorFunds);\n  }\n\n  /**\n   * @notice Returns arrays of indexes, `Comptroller` proxy contracts, and `RewardsDistributor` contracts for Fuse pools supplied to by `account`.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getRewardsDistributorsBySupplier(address supplier)\n    external\n    view\n    returns (\n      uint256[] memory,\n      IComptroller[] memory,\n      IRewardsDistributor[][] memory\n    )\n  {\n    // Get array length\n    FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try IComptroller(pools[i].comptroller).suppliers(supplier) returns (bool isSupplier) {\n        if (isSupplier) arrayLength++;\n      } catch {}\n    }\n\n    // Build array\n    uint256[] memory indexes = new uint256[](arrayLength);\n    IComptroller[] memory comptrollers = new IComptroller[](arrayLength);\n    IRewardsDistributor[][] memory distributors = new IRewardsDistributor[][](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      try comptroller.suppliers(supplier) returns (bool isSupplier) {\n        if (isSupplier) {\n          indexes[index] = i;\n          comptrollers[index] = comptroller;\n\n          try comptroller.getRewardsDistributors() returns (IRewardsDistributor[] memory _distributors) {\n            distributors[index] = _distributors;\n          } catch {}\n\n          index++;\n        }\n      } catch {}\n    }\n\n    // Return distributors\n    return (indexes, comptrollers, distributors);\n  }\n}\n"
    },
    "contracts/FusePoolLens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"./external/compound/IComptroller.sol\";\nimport \"./external/compound/IPriceOracle.sol\";\nimport \"./external/compound/ICToken.sol\";\nimport \"./external/compound/ICErc20.sol\";\nimport \"./external/compound/IRewardsDistributor.sol\";\n\nimport \"./external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"./FusePoolDirectory.sol\";\nimport \"./oracles/MasterPriceOracle.sol\";\n\n/**\n * @title FusePoolLens\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice FusePoolLens returns data on Fuse interest rate pools in mass for viewing by dApps, bots, etc.\n */\ncontract FusePoolLens is Initializable {\n  /**\n   * @notice Constructor to set the `FusePoolDirectory` contract object.\n   */\n  function initialize(\n    FusePoolDirectory _directory,\n    string memory _name,\n    string memory _symbol,\n    address[] memory _hardcodedAddresses,\n    string[] memory _hardcodedNames,\n    string[] memory _hardcodedSymbols,\n    string[] memory _uniswapLPTokenNames,\n    string[] memory _uniswapLPTokenSymbols,\n    string[] memory _uniswapLPTokenDisplayNames\n  ) public initializer {\n    require(address(_directory) != address(0), \"FusePoolDirectory instance cannot be the zero address.\");\n\n    directory = _directory;\n    name = _name;\n    symbol = _symbol;\n    for (uint256 i = 0; i < _hardcodedAddresses.length; i++) {\n      hardcoded[_hardcodedAddresses[i]] = TokenData({ name: _hardcodedNames[i], symbol: _hardcodedSymbols[i] });\n    }\n\n    for (uint256 i = 0; i < _uniswapLPTokenNames.length; i++) {\n      uniswapData.push(\n        UniswapData({\n          name: _uniswapLPTokenNames[i],\n          symbol: _uniswapLPTokenSymbols[i],\n          displayName: _uniswapLPTokenDisplayNames[i]\n        })\n      );\n    }\n  }\n\n  string public name;\n  string public symbol;\n\n  struct TokenData {\n    string name;\n    string symbol;\n  }\n  mapping(address => TokenData) hardcoded;\n\n  struct UniswapData {\n    string name; // ie \"Uniswap V2\" or \"SushiSwap LP Token\"\n    string symbol; // ie \"UNI-V2\" or \"SLP\"\n    string displayName; // ie \"SushiSwap\" or \"Uniswap\"\n  }\n  UniswapData[] uniswapData;\n\n  /**\n   * @notice `FusePoolDirectory` contract object.\n   */\n  FusePoolDirectory public directory;\n\n  /**\n   * @dev Struct for Fuse pool summary data.\n   */\n  struct FusePoolData {\n    uint256 totalSupply;\n    uint256 totalBorrow;\n    address[] underlyingTokens;\n    string[] underlyingSymbols;\n    bool whitelistedAdmin;\n  }\n\n  /**\n   * @notice Returns arrays of all public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPublicPoolsWithData()\n    external\n    returns (\n      uint256[] memory,\n      FusePoolDirectory.FusePool[] memory,\n      FusePoolData[] memory,\n      bool[] memory\n    )\n  {\n    (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory publicPools) = directory.getPublicPools();\n    (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n    return (indexes, publicPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of all whitelisted public Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPublicPoolsByVerificationWithData(bool whitelistedAdmin)\n    external\n    returns (\n      uint256[] memory,\n      FusePoolDirectory.FusePool[] memory,\n      FusePoolData[] memory,\n      bool[] memory\n    )\n  {\n    (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory publicPools) = directory\n      .getPublicPoolsByVerification(whitelistedAdmin);\n    (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(publicPools);\n    return (indexes, publicPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Fuse pools created by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsByAccountWithData(address account)\n    external\n    returns (\n      uint256[] memory,\n      FusePoolDirectory.FusePool[] memory,\n      FusePoolData[] memory,\n      bool[] memory\n    )\n  {\n    (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = directory.getPoolsByAccount(account);\n    (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n    return (indexes, accountPools, data, errored);\n  }\n\n  /**\n   * @notice Internal function returning arrays of requested Fuse pool indexes, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsData(FusePoolDirectory.FusePool[] memory pools)\n    internal\n    returns (FusePoolData[] memory, bool[] memory)\n  {\n    FusePoolData[] memory data = new FusePoolData[](pools.length);\n    bool[] memory errored = new bool[](pools.length);\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      try this.getPoolSummary(IComptroller(pools[i].comptroller)) returns (\n        uint256 _totalSupply,\n        uint256 _totalBorrow,\n        address[] memory _underlyingTokens,\n        string[] memory _underlyingSymbols,\n        bool _whitelistedAdmin\n      ) {\n        data[i] = FusePoolData(_totalSupply, _totalBorrow, _underlyingTokens, _underlyingSymbols, _whitelistedAdmin);\n      } catch {\n        errored[i] = true;\n      }\n    }\n\n    return (data, errored);\n  }\n\n  /**\n   * @notice Returns total supply balance (in ETH), total borrow balance (in ETH), underlying token addresses, and underlying token symbols of a Fuse pool.\n   */\n  function getPoolSummary(IComptroller comptroller)\n    external\n    returns (\n      uint256,\n      uint256,\n      address[] memory,\n      string[] memory,\n      bool\n    )\n  {\n    uint256 totalBorrow = 0;\n    uint256 totalSupply = 0;\n    ICToken[] memory cTokens = comptroller.getAllMarkets();\n    address[] memory underlyingTokens = new address[](cTokens.length);\n    string[] memory underlyingSymbols = new string[](cTokens.length);\n    IPriceOracle oracle = comptroller.oracle();\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      ICToken cToken = cTokens[i];\n      (bool isListed, ) = comptroller.markets(address(cToken));\n      if (!isListed) continue;\n      uint256 assetTotalBorrow = cToken.totalBorrowsCurrent();\n      uint256 assetTotalSupply = cToken.getCash() +\n        assetTotalBorrow -\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalFuseFees());\n      uint256 underlyingPrice = oracle.getUnderlyingPrice(cToken);\n      totalBorrow = totalBorrow + (assetTotalBorrow * underlyingPrice) / 1e18;\n      totalSupply = totalSupply + (assetTotalSupply * underlyingPrice) / 1e18;\n\n      if (cToken.isCEther()) {\n        underlyingTokens[i] = address(0);\n        underlyingSymbols[i] = symbol;\n      } else {\n        underlyingTokens[i] = ICErc20(address(cToken)).underlying();\n        (, underlyingSymbols[i]) = getTokenNameAndSymbol(underlyingTokens[i]);\n      }\n    }\n\n    bool whitelistedAdmin = directory.adminWhitelist(comptroller.admin());\n    return (totalSupply, totalBorrow, underlyingTokens, underlyingSymbols, whitelistedAdmin);\n  }\n\n  /**\n   * @dev Struct for a Fuse pool asset.\n   */\n  struct FusePoolAsset {\n    address cToken;\n    address underlyingToken;\n    string underlyingName;\n    string underlyingSymbol;\n    uint256 underlyingDecimals;\n    uint256 underlyingBalance;\n    uint256 supplyRatePerBlock;\n    uint256 borrowRatePerBlock;\n    uint256 totalSupply;\n    uint256 totalBorrow;\n    uint256 supplyBalance;\n    uint256 borrowBalance;\n    uint256 liquidity;\n    bool membership;\n    uint256 exchangeRate; // Price of cTokens in terms of underlying tokens\n    uint256 underlyingPrice; // Price of underlying tokens in ETH (scaled by 1e18)\n    address oracle;\n    uint256 collateralFactor;\n    uint256 reserveFactor;\n    uint256 adminFee;\n    uint256 fuseFee;\n    bool borrowGuardianPaused;\n  }\n\n  /**\n   * @notice Returns data on the specified assets of the specified Fuse pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptroller The Comptroller proxy contract address of the Fuse pool.\n   * @param cTokens The cToken contract addresses of the assets to query.\n   * @param user The user for which to get account data.\n   * @return An array of Fuse pool assets.\n   */\n  function getPoolAssetsWithData(\n    IComptroller comptroller,\n    ICToken[] memory cTokens,\n    address user\n  ) internal returns (FusePoolAsset[] memory) {\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      (bool isListed, ) = comptroller.markets(address(cTokens[i]));\n      if (isListed) arrayLength++;\n    }\n\n    FusePoolAsset[] memory detailedAssets = new FusePoolAsset[](arrayLength);\n    uint256 index = 0;\n    IPriceOracle oracle = comptroller.oracle();\n\n    for (uint256 i = 0; i < cTokens.length; i++) {\n      // Check if market is listed and get collateral factor\n      (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(cTokens[i]));\n      if (!isListed) continue;\n\n      // Start adding data to FusePoolAsset\n      FusePoolAsset memory asset;\n      ICToken cToken = cTokens[i];\n      asset.cToken = address(cToken);\n\n      // Get underlying asset data\n      if (cToken.isCEther()) {\n        asset.underlyingName = name;\n        asset.underlyingSymbol = symbol;\n        asset.underlyingDecimals = 18;\n        asset.underlyingBalance = user.balance;\n      } else {\n        asset.underlyingToken = ICErc20(address(cToken)).underlying();\n        ERC20Upgradeable underlying = ERC20Upgradeable(asset.underlyingToken);\n        (asset.underlyingName, asset.underlyingSymbol) = getTokenNameAndSymbol(asset.underlyingToken);\n        asset.underlyingDecimals = underlying.decimals();\n        asset.underlyingBalance = underlying.balanceOf(user);\n      }\n\n      // Get cToken data\n      asset.supplyRatePerBlock = cToken.supplyRatePerBlock();\n      asset.borrowRatePerBlock = cToken.borrowRatePerBlock();\n      asset.liquidity = cToken.getCash();\n      asset.totalBorrow = cToken.totalBorrowsCurrent();\n      asset.totalSupply =\n        asset.liquidity +\n        asset.totalBorrow -\n        (cToken.totalReserves() + cToken.totalAdminFees() + cToken.totalFuseFees());\n      asset.supplyBalance = cToken.balanceOfUnderlying(user);\n      asset.borrowBalance = cToken.borrowBalanceStored(user); // We would use borrowBalanceCurrent but we already accrue interest above\n      asset.membership = comptroller.checkMembership(user, cToken);\n      asset.exchangeRate = cToken.exchangeRateStored(); // We would use exchangeRateCurrent but we already accrue interest above\n      asset.underlyingPrice = oracle.getUnderlyingPrice(cToken);\n\n      // Get oracle for this cToken\n      asset.oracle = address(oracle);\n\n      try MasterPriceOracle(asset.oracle).oracles(asset.underlyingToken) returns (IPriceOracle _oracle) {\n        asset.oracle = address(_oracle);\n      } catch {}\n\n      // More cToken data\n      asset.collateralFactor = collateralFactorMantissa;\n      asset.reserveFactor = cToken.reserveFactorMantissa();\n      asset.adminFee = cToken.adminFeeMantissa();\n      asset.fuseFee = cToken.fuseFeeMantissa();\n      asset.borrowGuardianPaused = comptroller.borrowGuardianPaused(address(cToken));\n\n      // Add to assets array and increment index\n      detailedAssets[index] = asset;\n      index++;\n    }\n\n    return (detailedAssets);\n  }\n\n  /**\n   * @notice Returns the `name` and `symbol` of `token`.\n   * Supports Uniswap V2 and SushiSwap LP tokens as well as MKR.\n   * @param token An ERC20 token contract object.\n   * @return The `name` and `symbol`.\n   */\n  function getTokenNameAndSymbol(address token) internal view returns (string memory, string memory) {\n    // i.e. MKR is a DSToken and uses bytes32\n    if (bytes(hardcoded[token].symbol).length != 0) {\n      return (hardcoded[token].name, hardcoded[token].symbol);\n    }\n\n    // Get name and symbol from token contract\n    ERC20Upgradeable tokenContract = ERC20Upgradeable(token);\n    string memory _name = tokenContract.name();\n    string memory _symbol = tokenContract.symbol();\n\n    // Check for Uniswap V2/SushiSwap pair\n    for (uint256 i = 0; i < uniswapData.length; i++) {\n      try IUniswapV2Pair(token).token0() returns (address _token0) {\n        UniswapData memory ud = uniswapData[i];\n        bool isUniswapToken = keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked(ud.name)) &&\n          keccak256(abi.encodePacked(_symbol)) == keccak256(abi.encodePacked(ud.symbol));\n\n        if (isUniswapToken) {\n          ERC20Upgradeable token0 = ERC20Upgradeable(_token0);\n          ERC20Upgradeable token1 = ERC20Upgradeable(IUniswapV2Pair(token).token1());\n          _name = string(abi.encodePacked(ud.displayName, \" \", token0.symbol(), \"/\", token1.symbol(), \" LP\")); // add space\n          _symbol = string(abi.encodePacked(token0.symbol(), \"-\", token1.symbol()));\n          return (_name, _symbol);\n        }\n      } catch {}\n    }\n\n    return (_name, _symbol);\n  }\n\n  /**\n   * @notice Returns the assets of the specified Fuse pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptroller The Comptroller proxy contract of the Fuse pool.\n   * @return An array of Fuse pool assets.\n   */\n  function getPoolAssetsWithData(IComptroller comptroller) external returns (FusePoolAsset[] memory) {\n    return getPoolAssetsWithData(comptroller, comptroller.getAllMarkets(), msg.sender);\n  }\n\n  /**\n   * @dev Struct for a Fuse pool user.\n   */\n  struct FusePoolUser {\n    address account;\n    uint256 totalBorrow;\n    uint256 totalCollateral;\n    uint256 health;\n  }\n\n  /**\n   * @notice Returns the borrowers of the specified Fuse pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptroller The Comptroller proxy contract of the Fuse pool.\n   * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n   * @return An array of Fuse pool users, the pool's close factor, and the pool's liquidation incentive.\n   */\n  function getPoolUsersWithData(IComptroller comptroller, uint256 maxHealth)\n    external\n    returns (\n      FusePoolUser[] memory,\n      uint256,\n      uint256\n    )\n  {\n    address[] memory users = comptroller.getAllBorrowers();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < users.length; i++) {\n      uint256 totalBorrow = 0;\n      uint256 totalCollateral = 0;\n      FusePoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(users[i]), users[i]);\n\n      for (uint256 j = 0; j < assets.length; j++) {\n        totalBorrow = totalBorrow + (assets[j].borrowBalance * assets[j].underlyingPrice) / 1e18;\n        if (assets[j].membership) {\n          totalCollateral =\n            totalCollateral +\n            (((assets[j].supplyBalance * assets[j].underlyingPrice) / 1e18) * assets[j].collateralFactor) /\n            1e18;\n        }\n      }\n\n      uint256 health = totalBorrow > 0 ? (totalCollateral * 1e18) / totalBorrow : 1e36;\n      if (health <= maxHealth) arrayLength++;\n    }\n\n    FusePoolUser[] memory detailedUsers = new FusePoolUser[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < users.length; i++) {\n      uint256 totalBorrow = 0;\n      uint256 totalCollateral = 0;\n      FusePoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(users[i]), users[i]);\n\n      for (uint256 j = 0; j < assets.length; j++) {\n        totalBorrow = totalBorrow + (assets[j].borrowBalance * assets[j].underlyingPrice) / 1e18;\n        if (assets[j].membership) {\n          totalCollateral =\n            totalCollateral +\n            (((assets[j].supplyBalance * assets[j].underlyingPrice) / 1e18) * assets[j].collateralFactor) /\n            1e18;\n        }\n      }\n\n      uint256 health = totalBorrow > 0 ? (totalCollateral * 1e18) / totalBorrow : 1e36;\n      if (health > maxHealth) continue;\n      detailedUsers[index] = FusePoolUser(users[i], totalBorrow, totalCollateral, health);\n      index++;\n    }\n\n    return (detailedUsers, comptroller.closeFactorMantissa(), comptroller.liquidationIncentiveMantissa());\n  }\n\n  /**\n   * @notice Returns the users of each public Fuse pool.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n   * @return An array of pools' Comptroller proxy addresses, an array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n   */\n  function getPublicPoolUsersWithData(uint256 maxHealth)\n    external\n    returns (\n      IComptroller[] memory,\n      FusePoolUser[][] memory,\n      uint256[] memory,\n      uint256[] memory,\n      bool[] memory\n    )\n  {\n    // Get Comptroller addresses of all public pools\n    IComptroller[] memory comptrollers;\n\n    // Scope to avoid \"stack too deep\" error\n    {\n      (, FusePoolDirectory.FusePool[] memory publicPools) = directory.getPublicPools();\n      comptrollers = new IComptroller[](publicPools.length);\n      for (uint256 i = 0; i < publicPools.length; i++) comptrollers[i] = IComptroller(publicPools[i].comptroller);\n    }\n\n    // Get all public pools' data\n    (\n      FusePoolUser[][] memory users,\n      uint256[] memory closeFactors,\n      uint256[] memory liquidationIncentives,\n      bool[] memory errored\n    ) = getPoolUsersWithData(comptrollers, maxHealth);\n    return (comptrollers, users, closeFactors, liquidationIncentives, errored);\n  }\n\n  /**\n   * @notice Returns the users of the specified Fuse pools.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   * @param comptrollers The Comptroller proxy contracts of the Fuse pools.\n   * @param maxHealth The maximum health (scaled by 1e18) for which to return data.\n   * @return An array of arrays of Fuse pool users, an array of pools' close factors, an array of pools' liquidation incentives, and an array of booleans indicating if retrieving each pool's data failed.\n   */\n  function getPoolUsersWithData(IComptroller[] memory comptrollers, uint256 maxHealth)\n    public\n    returns (\n      FusePoolUser[][] memory,\n      uint256[] memory,\n      uint256[] memory,\n      bool[] memory\n    )\n  {\n    FusePoolUser[][] memory users = new FusePoolUser[][](comptrollers.length);\n    uint256[] memory closeFactors = new uint256[](comptrollers.length);\n    uint256[] memory liquidationIncentives = new uint256[](comptrollers.length);\n    bool[] memory errored = new bool[](comptrollers.length);\n\n    for (uint256 i = 0; i < comptrollers.length; i++) {\n      try this.getPoolUsersWithData(IComptroller(comptrollers[i]), maxHealth) returns (\n        FusePoolUser[] memory _users,\n        uint256 closeFactor,\n        uint256 liquidationIncentive\n      ) {\n        users[i] = _users;\n        closeFactors[i] = closeFactor;\n        liquidationIncentives[i] = liquidationIncentive;\n      } catch {\n        errored[i] = true;\n      }\n    }\n\n    return (users, closeFactors, liquidationIncentives, errored);\n  }\n\n  /**\n   * @notice Returns arrays of FusePoolAsset for a specific user\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPoolAssetsByUser(IComptroller comptroller, address user) public returns (FusePoolAsset[] memory) {\n    FusePoolAsset[] memory assets = getPoolAssetsWithData(comptroller, comptroller.getAssetsIn(user), user);\n    return assets;\n  }\n\n  /**\n   * @notice Returns arrays of Fuse pool indexes and data supplied to by `account`.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getPoolsBySupplier(address account)\n    public\n    view\n    returns (uint256[] memory, FusePoolDirectory.FusePool[] memory)\n  {\n    FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      try comptroller.suppliers(account) returns (bool isSupplier) {\n        if (isSupplier) {\n          ICToken[] memory allMarkets = comptroller.getAllMarkets();\n\n          for (uint256 j = 0; j < allMarkets.length; j++)\n            if (allMarkets[j].balanceOf(account) > 0) {\n              arrayLength++;\n              break;\n            }\n        }\n      } catch {}\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    FusePoolDirectory.FusePool[] memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      try comptroller.suppliers(account) returns (bool isSupplier) {\n        if (isSupplier) {\n          ICToken[] memory allMarkets = comptroller.getAllMarkets();\n\n          for (uint256 j = 0; j < allMarkets.length; j++)\n            if (allMarkets[j].balanceOf(account) > 0) {\n              indexes[index] = i;\n              accountPools[index] = pools[i];\n              index++;\n              break;\n            }\n        }\n      } catch {}\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Fuse pools supplied to by `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getPoolsBySupplierWithData(address account)\n    external\n    returns (\n      uint256[] memory,\n      FusePoolDirectory.FusePool[] memory,\n      FusePoolData[] memory,\n      bool[] memory\n    )\n  {\n    (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = getPoolsBySupplier(account);\n    (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n    return (indexes, accountPools, data, errored);\n  }\n\n  /**\n   * @notice Returns arrays of Fuse pool indexes and data with a whitelist containing `account`.\n   * Note that the whitelist does not have to be enforced.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   */\n  function getWhitelistedPoolsByAccount(address account)\n    public\n    view\n    returns (uint256[] memory, FusePoolDirectory.FusePool[] memory)\n  {\n    FusePoolDirectory.FusePool[] memory pools = directory.getAllPools();\n    uint256 arrayLength = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      if (comptroller.whitelist(account)) arrayLength++;\n    }\n\n    uint256[] memory indexes = new uint256[](arrayLength);\n    FusePoolDirectory.FusePool[] memory accountPools = new FusePoolDirectory.FusePool[](arrayLength);\n    uint256 index = 0;\n\n    for (uint256 i = 0; i < pools.length; i++) {\n      IComptroller comptroller = IComptroller(pools[i].comptroller);\n\n      if (comptroller.whitelist(account)) {\n        indexes[index] = i;\n        accountPools[index] = pools[i];\n        index++;\n        break;\n      }\n    }\n\n    return (indexes, accountPools);\n  }\n\n  /**\n   * @notice Returns arrays of the indexes of Fuse pools with a whitelist containing `account`, data, total supply balances (in ETH), total borrow balances (in ETH), arrays of underlying token addresses, arrays of underlying asset symbols, and booleans indicating if retrieving each pool's data failed.\n   * @dev This function is not designed to be called in a transaction: it is too gas-intensive.\n   * Ideally, we can add the `view` modifier, but many cToken functions potentially modify the state.\n   */\n  function getWhitelistedPoolsByAccountWithData(address account)\n    external\n    returns (\n      uint256[] memory,\n      FusePoolDirectory.FusePool[] memory,\n      FusePoolData[] memory,\n      bool[] memory\n    )\n  {\n    (uint256[] memory indexes, FusePoolDirectory.FusePool[] memory accountPools) = getWhitelistedPoolsByAccount(\n      account\n    );\n    (FusePoolData[] memory data, bool[] memory errored) = getPoolsData(accountPools);\n    return (indexes, accountPools, data, errored);\n  }\n}\n"
    },
    "contracts/oracles/MasterPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../external/compound/IPriceOracle.sol\";\nimport \"../external/compound/ICToken.sol\";\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./BasePriceOracle.sol\";\nimport \"./keydonix/UniswapOracle.sol\";\nimport \"./default/KeydonixUniswapTwapPriceOracle.sol\";\n\n/**\n * @title MasterPriceOracle\n * @notice Use a combination of price oracles.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract MasterPriceOracle is Initializable, IPriceOracle, BasePriceOracle {\n  /**\n   * @dev Maps underlying token addresses to `PriceOracle` contracts (can be `BasePriceOracle` contracts too).\n   */\n  mapping(address => IPriceOracle) public oracles;\n\n  /**\n   * @dev Default/fallback `PriceOracle`.\n   */\n  IPriceOracle public defaultOracle;\n\n  /**\n   * @dev The administrator of this `MasterPriceOracle`.\n   */\n  address public admin;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool internal noAdminOverwrite;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev Returns a boolean indicating if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  function canAdminOverwrite() external view returns (bool) {\n    return !noAdminOverwrite;\n  }\n\n  /**\n   * @dev Event emitted when `admin` is changed.\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @dev Event emitted when the default oracle is changed.\n   */\n  event NewDefaultOracle(address oldOracle, address newOracle);\n\n  /**\n   * @dev Event emitted when an underlying token's oracle is changed.\n   */\n  event NewOracle(address underlying, address oldOracle, address newOracle);\n\n  /**\n   * @dev Constructor to initialize state variables.\n   * @param underlyings The underlying ERC20 token addresses to link to `_oracles`.\n   * @param _oracles The `PriceOracle` contracts to be assigned to `underlyings`.\n   * @param _defaultOracle The default `PriceOracle` contract to use.\n   * @param _admin The admin who can assign oracles to underlying tokens.\n   * @param _canAdminOverwrite Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  function initialize(\n    address[] memory underlyings,\n    IPriceOracle[] memory _oracles,\n    IPriceOracle _defaultOracle,\n    address _admin,\n    bool _canAdminOverwrite,\n    address _wtoken\n  ) external initializer {\n    // Input validation\n    require(underlyings.length == _oracles.length, \"Lengths of both arrays must be equal.\");\n\n    // Initialize state variables\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      IPriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, address(0), address(newOracle));\n    }\n\n    defaultOracle = _defaultOracle;\n    admin = _admin;\n    noAdminOverwrite = !_canAdminOverwrite;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @dev Sets `_oracles` for `underlyings`.\n   */\n  function add(address[] calldata underlyings, IPriceOracle[] calldata _oracles) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == _oracles.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // Assign oracles to underlying tokens\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n      address oldOracle = address(oracles[underlying]);\n      if (noAdminOverwrite)\n        require(\n          oldOracle == address(0),\n          \"Admin cannot overwrite existing assignments of oracles to underlying tokens.\"\n        );\n      IPriceOracle newOracle = _oracles[i];\n      oracles[underlying] = newOracle;\n      emit NewOracle(underlying, oldOracle, address(newOracle));\n    }\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function setDefaultOracle(IPriceOracle newOracle) external onlyAdmin {\n    IPriceOracle oldOracle = defaultOracle;\n    defaultOracle = newOracle;\n    emit NewDefaultOracle(address(oldOracle), address(newOracle));\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  /**\n   * @dev Modifier that checks if `msg.sender == admin`.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Sender is not the admin.\");\n    _;\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get underlying ERC20 token address\n    address underlying = address(ICErc20(address(cToken)).underlying());\n\n    // Return 1e18 for WETH\n    if (underlying == wtoken) return 1e18;\n\n    // Get underlying price from assigned oracle\n    IPriceOracle oracle = oracles[underlying];\n    if (address(oracle) != address(0)) return oracle.getUnderlyingPrice(cToken);\n    if (address(defaultOracle) != address(0)) return defaultOracle.getUnderlyingPrice(cToken);\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n\n  /**\n   * @dev Attempts to return the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == wtoken) return 1e18;\n\n    // Get underlying price from assigned oracle\n    IPriceOracle oracle = oracles[underlying];\n    if (address(oracle) != address(0)) return BasePriceOracle(address(oracle)).price(underlying);\n    if (address(defaultOracle) != address(0)) return BasePriceOracle(address(defaultOracle)).price(underlying);\n    revert(\"Price oracle not found for this underlying token address.\");\n  }\n}\n"
    },
    "contracts/oracles/default/PreferredPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\nimport \"../MasterPriceOracle.sol\";\nimport \"../default/ChainlinkPriceOracleV2.sol\";\n\n/**\n * @title PreferredPriceOracle\n * @notice Returns prices from MasterPriceOracle, ChainlinkPriceOracleV2, or prices from a tertiary oracle (in order of preference).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PreferredPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev The primary `MasterPriceOracle`.\n   */\n  MasterPriceOracle public masterOracle;\n\n  /**\n   * @dev The secondary `ChainlinkPriceOracleV2`.\n   */\n  ChainlinkPriceOracleV2 public chainlinkOracleV2;\n\n  /**\n   * @dev The tertiary `PriceOracle`.\n   */\n  IPriceOracle public tertiaryOracle;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public wtoken;\n\n  /**\n   * @dev Constructor to set the primary `MasterPriceOracle`, the secondary `ChainlinkPriceOracleV2`, and the tertiary `PriceOracle`.\n   */\n  constructor(\n    MasterPriceOracle _masterOracle,\n    ChainlinkPriceOracleV2 _chainlinkOracleV2,\n    IPriceOracle _tertiaryOracle,\n    address _wtoken\n  ) {\n    require(address(_masterOracle) != address(0), \"MasterPriceOracle not set.\");\n    require(address(_chainlinkOracleV2) != address(0), \"ChainlinkPriceOracleV2 not set.\");\n    require(address(_tertiaryOracle) != address(0), \"Tertiary price oracle not set.\");\n    masterOracle = _masterOracle;\n    chainlinkOracleV2 = _chainlinkOracleV2;\n    tertiaryOracle = _tertiaryOracle;\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Try to get MasterPriceOracle price\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.price(underlying);\n\n    // Try to get ChainlinkPriceOracleV2 price\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0)) return chainlinkOracleV2.price(underlying);\n\n    // Otherwise, get price from tertiary oracle\n    return BasePriceOracle(address(tertiaryOracle)).price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying ERC20 token address\n    address underlying = address(ICErc20(address(cToken)).underlying());\n\n    // Return 1e18 for wtoken\n    if (underlying == wtoken) return 1e18;\n\n    // Try to get MasterPriceOracle price\n    if (address(masterOracle.oracles(underlying)) != address(0)) return masterOracle.getUnderlyingPrice(cToken);\n\n    // Try to get ChainlinkPriceOracleV2 price\n    if (address(chainlinkOracleV2.priceFeeds(underlying)) != address(0))\n      return chainlinkOracleV2.getUnderlyingPrice(cToken);\n\n    // Otherwise, get price from tertiary oracle\n    return tertiaryOracle.getUnderlyingPrice(cToken);\n  }\n}\n"
    },
    "contracts/oracles/default/ChainlinkPriceOracleV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title ChainlinkPriceOracleV2\n * @notice Returns prices from Chainlink.\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract ChainlinkPriceOracleV2 is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Maps ERC20 token addresses to ETH-based Chainlink price feed contracts.\n   */\n  mapping(address => AggregatorV3Interface) public priceFeeds;\n\n  /**\n   * @notice Maps ERC20 token addresses to enums indicating the base currency of the feed.\n   */\n  mapping(address => FeedBaseCurrency) public feedBaseCurrencies;\n\n  /**\n   * @notice Enum indicating the base currency of a Chainlink price feed.\n   */\n  enum FeedBaseCurrency {\n    ETH,\n    USD\n  }\n\n  /**\n   * @notice Chainlink NATIVE/USD price feed contracts.\n   */\n  AggregatorV3Interface public immutable NATIVE_TOKEN_USD_PRICE_FEED;\n\n  /**\n   * @dev The administrator of this `MasterPriceOracle`.\n   */\n  address public admin;\n\n  /**\n   * @dev Controls if `admin` can overwrite existing assignments of oracles to underlying tokens.\n   */\n  bool public canAdminOverwrite;\n\n  /**\n   * @dev The Wrapped native asset address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  constructor(\n    address _admin,\n    bool _canAdminOverwrite,\n    address _wtoken,\n    address nativeTokenUsd\n  ) {\n    admin = _admin;\n    canAdminOverwrite = _canAdminOverwrite;\n    wtoken = _wtoken;\n    NATIVE_TOKEN_USD_PRICE_FEED = AggregatorV3Interface(nativeTokenUsd);\n  }\n\n  /**\n   * @dev Changes the admin and emits an event.\n   */\n  function changeAdmin(address newAdmin) external onlyAdmin {\n    address oldAdmin = admin;\n    admin = newAdmin;\n    emit NewAdmin(oldAdmin, newAdmin);\n  }\n\n  /**\n   * @dev Event emitted when `admin` is changed.\n   */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @dev Modifier that checks if `msg.sender == admin`.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == admin, \"Sender is not the admin.\");\n    _;\n  }\n\n  /**\n   * @dev Admin-only function to set price feeds.\n   * @param underlyings Underlying token addresses for which to set price feeds.\n   * @param feeds The Chainlink price feed contract addresses for each of `underlyings`.\n   * @param baseCurrency The currency in which `feeds` are based.\n   */\n  function setPriceFeeds(\n    address[] memory underlyings,\n    AggregatorV3Interface[] memory feeds,\n    FeedBaseCurrency baseCurrency\n  ) external onlyAdmin {\n    // Input validation\n    require(\n      underlyings.length > 0 && underlyings.length == feeds.length,\n      \"Lengths of both arrays must be equal and greater than 0.\"\n    );\n\n    // For each token/feed\n    for (uint256 i = 0; i < underlyings.length; i++) {\n      address underlying = underlyings[i];\n\n      // Check for existing oracle if !canAdminOverwrite\n      if (!canAdminOverwrite)\n        require(\n          address(priceFeeds[underlying]) == address(0),\n          \"Admin cannot overwrite existing assignments of price feeds to underlying tokens.\"\n        );\n\n      // Set feed and base currency\n      priceFeeds[underlying] = feeds[i];\n      feedBaseCurrencies[underlying] = baseCurrency;\n    }\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WTOKEN\n    if (underlying == wtoken || underlying == address(0)) return 1e18;\n\n    // Get token/ETH price from Chainlink\n    AggregatorV3Interface feed = priceFeeds[underlying];\n    require(address(feed) != address(0), \"No Chainlink price feed found for this underlying ERC20 token.\");\n    FeedBaseCurrency baseCurrency = feedBaseCurrencies[underlying];\n\n    if (baseCurrency == FeedBaseCurrency.ETH) {\n      (, int256 tokenEthPrice, , , ) = feed.latestRoundData();\n      return tokenEthPrice >= 0 ? (uint256(tokenEthPrice) * 1e18) / (10**uint256(feed.decimals())) : 0;\n    } else if (baseCurrency == FeedBaseCurrency.USD) {\n      (, int256 nativeTokenUsdPrice, , , ) = NATIVE_TOKEN_USD_PRICE_FEED.latestRoundData();\n      if (nativeTokenUsdPrice <= 0) return 0;\n      (, int256 tokenUsdPrice, , , ) = feed.latestRoundData();\n      return\n        tokenUsdPrice >= 0\n          ? ((uint256(tokenUsdPrice) * 1e26) / (10**uint256(feed.decimals()))) / uint256(nativeTokenUsdPrice)\n          : 0;\n    }\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price\n    uint256 chainlinkPrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(chainlinkPrice) * (10**(18 - underlyingDecimals))\n        : uint256(chainlinkPrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/oracles/mainnet/BadgerPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../../external/badger/IXToken.sol\";\nimport \"../../external/badger/IDigg.sol\";\nimport \"../../external/badger/DiggSett.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title BadgerPriceOracle\n * @notice Returns prices for bDIGG, bBADGER, and ibBTC.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev BADGER/ETH Chainlink price feed.\n   */\n  AggregatorV3Interface public constant BADGER_ETH_FEED =\n    AggregatorV3Interface(0x58921Ac140522867bf50b9E009599Da0CA4A2379);\n\n  /**\n   * @dev bBADGER ERC20 token contract.\n   */\n  IXToken public constant BBADGER = IXToken(0x19D97D8fA813EE2f51aD4B4e04EA08bAf4DFfC28);\n\n  /**\n   * @dev DIGG/BTC Chainlink price feed.\n   */\n  AggregatorV3Interface public constant DIGG_BTC_FEED =\n    AggregatorV3Interface(0x418a6C98CD5B8275955f08F0b8C1c6838c8b1685);\n\n  /**\n   * @dev bDIGG ERC20 token contract.\n   */\n  DiggSett public constant BDIGG = DiggSett(0x7e7E112A68d8D2E221E11047a72fFC1065c38e1a);\n\n  /**\n   * @dev BTC/ETH Chainlink price feed.\n   */\n  AggregatorV3Interface public constant BTC_ETH_FEED =\n    AggregatorV3Interface(0xdeb288F737066589598e9214E782fa5A8eD689e8);\n\n  /**\n   * @dev ibBTC ERC20 token contract.\n   */\n  IXToken public constant IBBTC = IXToken(0xc4E15973E6fF2A35cC804c2CF9D2a1b817a8b40F);\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    if (token == address(BBADGER)) {\n      (uint80 roundId, int256 badgerEthPrice, , , uint80 answeredInRound) = BADGER_ETH_FEED.latestRoundData();\n      require(answeredInRound == roundId, \"Chainlink round timed out.\");\n      return badgerEthPrice > 0 ? (uint256(badgerEthPrice) * BBADGER.getPricePerFullShare()) / 1e18 : 0;\n    } else if (token == address(BDIGG)) {\n      (uint80 roundId, int256 diggBtcPrice, , , uint80 answeredInRound) = DIGG_BTC_FEED.latestRoundData();\n      require(answeredInRound == roundId, \"Chainlink round timed out.\");\n      if (diggBtcPrice < 0) return 0;\n      int256 btcEthPrice;\n      (roundId, btcEthPrice, , , answeredInRound) = BTC_ETH_FEED.latestRoundData();\n      require(answeredInRound == roundId, \"Chainlink round timed out.\");\n      if (btcEthPrice < 0) return 0;\n      // SafeMath removal refactoring: multiplication before division for higher precision\n      uint256 bDiggDiggPrice = IDigg(BDIGG.token()).sharesToFragments((BDIGG.shares() * 1e18) / BDIGG.totalSupply());\n      // bDIGG/ETH price = (bDIGG/DIGG price / 1e9) * (DIGG/BTC price / 1e8) * BTC/ETH price\n      // Divide by BTC base unit 1e8 (BTC has 8 decimals) and DIGG base unit 1e9 (DIGG has 9 decimals)\n      return bDiggDiggPrice > 0 ? (((uint256(diggBtcPrice) * uint256(btcEthPrice)) / 1e8) * bDiggDiggPrice) / 1e9 : 0;\n    } else if (token == address(IBBTC)) {\n      (uint80 roundId, int256 btcEthPrice, , , uint80 answeredInRound) = BTC_ETH_FEED.latestRoundData();\n      require(answeredInRound == roundId, \"Chainlink round timed out.\");\n      return btcEthPrice > 0 ? (uint256(btcEthPrice) * IBBTC.pricePerShare()) / 1e18 : 0;\n    } else revert(\"Invalid token address passed to BadgerPriceOracle.\");\n  }\n}\n"
    },
    "contracts/external/badger/IXToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IXToken {\n  function pricePerShare() external view returns (uint256);\n\n  function getPricePerFullShare() external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/IDigg.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IDigg {\n  /**\n   * @param shares Share value to convert.\n   * @return The current fragment value of the specified underlying share amount.\n   */\n  function sharesToFragments(uint256 shares) external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/DiggSett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./Sett.sol\";\n\ninterface DiggSett is Sett {\n  function shares() external view returns (uint256);\n}\n"
    },
    "contracts/external/badger/Sett.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface Sett {\n  function totalSupply() external view returns (uint256);\n\n  function withdrawAll() external;\n\n  function token() external view returns (address);\n}\n"
    },
    "contracts/liquidators/BadgerSettLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/badger/Sett.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title BadgerSettLiquidator\n * @notice Redeems a Badger Sett for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BadgerSettLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unwrap wstETH (and store output stETH as new collateral)\n    Sett token = Sett(address(inputToken));\n    token.withdrawAll();\n    outputToken = IERC20Upgradeable(token.token());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/oracles/default/FixedEurPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedEurPriceOracle\n * @notice Returns fixed prices of 1 EUR in terms of Native Token for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedEurPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice The maximum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n   */\n  uint256 public maxSecondsBeforePriceIsStale;\n\n  /**\n   * @notice Chainlink NATIVE/USD price feed contracts.\n   */\n  AggregatorV3Interface public immutable NATIVE_TOKEN_USD_PRICE_FEED;\n\n  /**\n   * @notice Chainlink EUR/USD price feed contracts.\n   */\n  AggregatorV3Interface public immutable EUR_USD_PRICE_FEED;\n\n  /**\n   * @dev Constructor to set `maxSecondsBeforePriceIsStale`.\n   */\n  constructor(\n    uint256 _maxSecondsBeforePriceIsStale,\n    address nativeTokenUsdPriceFeed,\n    address eurUsdPriceFeed\n  ) {\n    maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n    NATIVE_TOKEN_USD_PRICE_FEED = AggregatorV3Interface(nativeTokenUsdPriceFeed);\n    EUR_USD_PRICE_FEED = AggregatorV3Interface(eurUsdPriceFeed);\n  }\n\n  /**\n   * @dev Internal function returning the price in NATIVE of `underlying`.\n   */\n  function _price(address underlying) internal view returns (uint256) {\n    // Get NATIVE/USD price from Chainlink\n\n    (, int256 nativeUsdPrice, , uint256 updatedAt, ) = NATIVE_TOKEN_USD_PRICE_FEED.latestRoundData();\n    if (maxSecondsBeforePriceIsStale > 0)\n      require(block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale, \"NATIVE/USD Chainlink price is stale.\");\n    if (nativeUsdPrice <= 0) return 0;\n\n    // Get EUR/USD price from Chainlink\n    int256 eurUsdPrice;\n    (, eurUsdPrice, , updatedAt, ) = EUR_USD_PRICE_FEED.latestRoundData();\n    if (maxSecondsBeforePriceIsStale > 0)\n      require(block.timestamp <= updatedAt + maxSecondsBeforePriceIsStale, \"EUR/USD Chainlink price is stale.\");\n    if (eurUsdPrice <= 0) return 0;\n\n    // Return EUR/NATIVE price = EUR/USD price / NATIVE/USD price\n    return (uint256(eurUsdPrice) * 1e18) / uint256(nativeUsdPrice);\n  }\n\n  /**\n   * @dev Returns the price in NATIVE of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in NATIVE of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in NATIVE of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Format and return price\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n}\n"
    },
    "contracts/oracles/1337/MockPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/chainlink/AggregatorV3Interface.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title MockPriceOracle\n * @notice Returns mocked prices from a Chainlink-like oracle. Used for local dev only\n * @dev Implements `PriceOracle`.\n * @author Carlo Mazzaferro <carlo.mazzaferro@gmail.com> (https://github.com/carlomazzaferro)\n */\ncontract MockPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice The maxmimum number of seconds elapsed since the round was last updated before the price is considered stale. If set to 0, no limit is enforced.\n   */\n  uint256 public maxSecondsBeforePriceIsStale;\n\n  /**\n   * @dev Constructor to set `maxSecondsBeforePriceIsStale` as well as all Chainlink price feeds.\n   */\n  constructor(uint256 _maxSecondsBeforePriceIsStale) {\n    // Set maxSecondsBeforePriceIsStale\n    maxSecondsBeforePriceIsStale = _maxSecondsBeforePriceIsStale;\n  }\n\n  /**\n   * @dev Returns a boolean indicating if a price feed exists for the underlying asset.\n   */\n\n  function hasPriceFeed(address underlying) external view returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Internal function returning the price in ETH of `underlying`.\n   */\n\n  function random() private view returns (uint256) {\n    uint256 r = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 99;\n    r = r + 1;\n    return r;\n  }\n\n  function _price(address underlying) internal view returns (uint256) {\n    // Return 1e18 for WETH\n    if (underlying == 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2) return 1e18;\n\n    int256 tokenEthPrice = 1;\n    uint256 r = random();\n\n    return ((uint256(tokenEthPrice) * 1e18) / r) / 1e18;\n  }\n\n  /**\n   * @dev Returns the price in ETH of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Return 1e18 for ETH\n    if (cToken.isCEther()) return 1e18;\n\n    // Get underlying token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Get price\n    uint256 chainlinkPrice = _price(underlying);\n\n    // Format and return price\n    uint256 underlyingDecimals = uint256(ERC20Upgradeable(underlying).decimals());\n    return\n      underlyingDecimals <= 18\n        ? uint256(chainlinkPrice) * (10**(18 - underlyingDecimals))\n        : uint256(chainlinkPrice) / (10**(underlyingDecimals - 18));\n  }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "contracts/external/chainlink/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/external/chainlink/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "contracts/compound/CEther.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CToken.sol\";\nimport \"../oracles/default/KeydonixUniswapTwapPriceOracle.sol\";\nimport \"../oracles/keydonix/UniswapOracle.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @dev This contract should not to be deployed on its own; instead, deploy `CEtherDelegator` (proxy contract) and `CEtherDelegate` (logic/implementation contract).\n * @author Compound\n */\ncontract CEther is CToken, CEtherInterface {\n  bool public constant override isCEther = true;\n\n  /**\n   * @notice Initialize the new money market\n   * @param comptroller_ The address of the Comptroller\n   * @param interestRateModel_ The address of the interest rate model\n   * @param name_ ERC-20 name of this token\n   * @param symbol_ ERC-20 symbol of this token\n   */\n  function initialize(\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    string memory name_,\n    string memory symbol_,\n    uint256 reserveFactorMantissa_,\n    uint256 adminFeeMantissa_\n  ) public {\n    // CToken initialize does the bulk of the work\n    uint256 initialExchangeRateMantissa_ = 0.2e18;\n    uint8 decimals_ = 18;\n    super.initialize(\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_,\n      reserveFactorMantissa_,\n      adminFeeMantissa_\n    );\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n   * @dev Reverts upon any failure\n   */\n  function mint() external payable {\n    (uint256 err, ) = mintInternal(msg.value);\n    requireNoError(err, \"mint failed\");\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemTokens The number of cTokens to redeem into underlying\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeem(uint256 redeemTokens) external returns (uint256) {\n    return redeemInternal(redeemTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n   * @dev Accrues interest whether or not the operation succeeds, unless reverted\n   * @param redeemAmount The amount of underlying to redeem\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256) {\n    return redeemUnderlyingInternal(redeemAmount);\n  }\n\n  /**\n   * @notice Sender borrows assets from the protocol to their own address\n   * @param borrowAmount The amount of the underlying asset to borrow\n   * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n   */\n  function borrow(uint256 borrowAmount) external returns (uint256) {\n    return borrowInternal(borrowAmount);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n   * @dev Reverts upon any failure\n   */\n  function repayBorrow() external payable {\n    (uint256 err, ) = repayBorrowInternal(msg.value);\n    requireNoError(err, \"repayBorrow failed\");\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n   * @dev Reverts upon any failure\n   * @param borrower the account with the debt being payed off\n   */\n  function repayBorrowBehalf(address borrower) external payable {\n    (uint256 err, ) = repayBorrowBehalfInternal(borrower, msg.value);\n    requireNoError(err, \"repayBorrowBehalf failed\");\n  }\n\n  function liquidateBorrowWithPriceProof(\n    address borrower,\n    CTokenInterface cTokenCollateral,\n    UniswapOracle.ProofData calldata collateralProofData,\n    address _keydonixPriceOracle\n  ) external payable {\n    ICToken collateralAsInterface = ICToken(address(cTokenCollateral));\n    KeydonixUniswapTwapPriceOracle(_keydonixPriceOracle).verifyPrice(collateralAsInterface, collateralProofData);\n\n    return liquidateBorrow(borrower, cTokenCollateral);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n   *  The collateral seized is transferred to the liquidator.\n   * @dev Reverts upon any failure\n   * @param borrower The borrower of this cToken to be liquidated\n   * @param cTokenCollateral The market in which to seize collateral from the borrower\n   */\n  function liquidateBorrow(address borrower, CTokenInterface cTokenCollateral) public payable {\n    (uint256 err, ) = liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\n    requireNoError(err, \"liquidateBorrow failed\");\n  }\n\n  /**\n   * @notice Send Ether to CEther to mint\n   */\n  receive() external payable {\n    (uint256 err, ) = mintInternal(msg.value);\n    requireNoError(err, \"mint failed\");\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of Ether, before this message\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of Ether owned by this contract\n   */\n  function getCashPrior() internal view override returns (uint256) {\n    (MathError err, uint256 startingBalance) = subUInt(address(this).balance, msg.value);\n    require(err == MathError.NO_ERROR);\n    return startingBalance;\n  }\n\n  /**\n   * @notice Perform the actual transfer in, which is a no-op\n   * @param from Address sending the Ether\n   * @param amount Amount of Ether being sent\n   * @return The actual amount of Ether transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Sanity checks\n    require(msg.sender == from, \"sender mismatch\");\n    require(msg.value == amount, \"value mismatch\");\n    return amount;\n  }\n\n  function doTransferOut(address to, uint256 amount) internal override {\n    // Send the Ether and revert on failure\n    (bool success, ) = to.call{ value: amount }(\"\");\n    require(success, \"doTransferOut failed\");\n  }\n\n  function requireNoError(uint256 errCode, string memory message) internal pure {\n    if (errCode == uint256(Error.NO_ERROR)) {\n      return;\n    }\n\n    bytes memory fullMessage = new bytes(bytes(message).length + 7);\n    uint256 i;\n\n    for (i = 0; i < bytes(message).length; i++) {\n      fullMessage[i] = bytes(message)[i];\n    }\n\n    fullMessage[i + 0] = bytes1(uint8(32));\n    fullMessage[i + 1] = bytes1(uint8(40));\n    fullMessage[i + 2] = bytes1(uint8(48 + (errCode / 1000)));\n    fullMessage[i + 3] = bytes1(uint8(48 + ((errCode / 100) % 10)));\n    fullMessage[i + 4] = bytes1(uint8(48 + ((errCode / 10) % 10)));\n    fullMessage[i + 5] = bytes1(uint8(48 + (errCode % 10)));\n    fullMessage[i + 6] = bytes1(uint8(41));\n\n    require(errCode == uint256(Error.NO_ERROR), string(fullMessage));\n  }\n}\n"
    },
    "contracts/compound/Maximillion.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's Maximillion Contract\n * @author Compound\n */\ncontract Maximillion {\n  /**\n   * @notice The default cEther market to repay in\n   */\n  CEther public cEther;\n\n  /**\n   * @notice Construct a Maximillion to repay max in a CEther market\n   */\n  constructor(CEther cEther_) {\n    cEther = cEther_;\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\n   * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n   * @param borrower The address of the borrower account to repay on behalf of\n   */\n  function repayBehalf(address borrower) public payable {\n    repayBehalfExplicit(borrower, cEther);\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\n   * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n   * @param borrower The address of the borrower account to repay on behalf of\n   * @param cEther_ The address of the cEther contract to repay in\n   */\n  function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n    uint256 received = msg.value;\n    uint256 borrows = cEther_.borrowBalanceCurrent(borrower);\n    if (received > borrows) {\n      cEther_.repayBorrowBehalf{ value: borrows }(borrower);\n      payable(msg.sender).transfer(received - borrows);\n    } else {\n      cEther_.repayBorrowBehalf{ value: received }(borrower);\n    }\n  }\n}\n"
    },
    "contracts/compound/CEtherDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CEther.sol\";\nimport \"./CDelegateInterface.sol\";\n\n/**\n * @title Compound's CEtherDelegate Contract\n * @notice CTokens which wrap Ether and are delegated to\n * @author Compound\n */\ncontract CEtherDelegate is CDelegateInterface, CEther {\n  /**\n   * @notice Construct an empty delegate\n   */\n  constructor() {}\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n   * @param data The encoded bytes data for any initialization\n   */\n  function _becomeImplementation(bytes calldata data) external override {\n    require(msg.sender == address(this) || hasAdminRights(), \"!self\");\n\n    // Make sure admin storage is set up correctly\n    __admin = payable(0);\n    __adminHasRights = false;\n    __fuseAdminHasRights = false;\n  }\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n   */\n  function _resignImplementation() internal {\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n  }\n\n  /**\n   * @dev Internal function to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationInternal(\n    address implementation_,\n    bool allowResign,\n    bytes memory becomeImplementationData\n  ) internal {\n    // Check whitelist\n    require(fuseAdmin.cEtherDelegateWhitelist(implementation, implementation_, allowResign), \"!impl\");\n\n    // Call _resignImplementation internally (this delegate's code)\n    if (allowResign) _resignImplementation();\n\n    // Get old implementation\n    address oldImplementation = implementation;\n\n    // Store new implementation\n    implementation = implementation_;\n\n    // Call _becomeImplementation externally (delegating to new delegate's code)\n    _functionCall(\n      address(this),\n      abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData),\n      \"!become\"\n    );\n\n    // Emit event\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n   * @param implementation_ The address of the new implementation for delegation\n   * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n   * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n   */\n  function _setImplementationSafe(\n    address implementation_,\n    bool allowResign,\n    bytes calldata becomeImplementationData\n  ) external override {\n    // Check admin rights\n    require(hasAdminRights(), \"!admin\");\n\n    // Set implementation\n    _setImplementationInternal(implementation_, allowResign, becomeImplementationData);\n  }\n\n  /**\n   * @notice Function called before all delegator functions\n   * @dev Checks comptroller.autoImplementation and upgrades the implementation if necessary\n   */\n  function _prepare() external payable override {\n    if (msg.sender != address(this) && ComptrollerV3Storage(address(comptroller)).autoImplementation()) {\n      (address latestCEtherDelegate, bool allowResign, bytes memory becomeImplementationData) = fuseAdmin\n        .latestCEtherDelegate(implementation);\n      if (implementation != latestCEtherDelegate)\n        _setImplementationInternal(latestCEtherDelegate, allowResign, becomeImplementationData);\n    }\n  }\n}\n"
    },
    "contracts/oracles/1337/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../compound/PriceOracle.sol\";\nimport \"../../compound/CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n  mapping(address => uint256) prices;\n  event PricePosted(\n    address asset,\n    uint256 previousPriceMantissa,\n    uint256 requestedPriceMantissa,\n    uint256 newPriceMantissa\n  );\n\n  function getUnderlyingPrice(CToken cToken) public view override returns (uint256) {\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\n      return 1e18;\n    } else {\n      return prices[address(CErc20(address(cToken)).underlying())];\n    }\n  }\n\n  function setUnderlyingPrice(CToken cToken, uint256 underlyingPriceMantissa) public {\n    address asset = address(CErc20(address(cToken)).underlying());\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n    prices[asset] = underlyingPriceMantissa;\n  }\n\n  function setDirectPrice(address asset, uint256 price) public {\n    emit PricePosted(asset, prices[asset], price, price);\n    prices[asset] = price;\n  }\n\n  function price(address underlying) external view returns (uint256) {\n    return prices[address(underlying)];\n  }\n\n  // v1 price oracle interface for use as backing of proxy\n  function assetPrices(address asset) external view returns (uint256) {\n    return prices[asset];\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/oracles/default/RecursivePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\nimport \"../../external/compound/IComptroller.sol\";\n\n/**\n * @title RecursivePriceOracle\n * @notice Returns prices from other cTokens (from Fuse).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract RecursivePriceOracle is IPriceOracle {\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get cToken's underlying cToken\n    ICToken underlying = ICToken(ICErc20(address(cToken)).underlying());\n\n    // Get Comptroller\n    IComptroller comptroller = IComptroller(underlying.comptroller());\n\n    // If cETH, return cETH/ETH exchange rate\n    if (underlying.isCEther()) {\n      return underlying.exchangeRateStored();\n    }\n\n    // Fuse cTokens: cToken/token price * token/ETH price = cToken/ETH price\n    return (underlying.exchangeRateStored() * comptroller.oracle().getUnderlyingPrice(underlying)) / 1e18;\n  }\n}\n"
    },
    "contracts/liquidators/CurveLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLpTokenLiquidator\n * @notice Redeems seized Curve LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLpTokenLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurvePool curvePool = ICurvePool(\n      ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken))\n    );\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n}\n"
    },
    "contracts/liquidators/CurveLiquidityGaugeV2Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveRegistry.sol\";\nimport \"../external/curve/ICurvePool.sol\";\nimport \"../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2Liquidator\n * @notice Redeems seized Curve LiquidityGaugeV2 collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveLiquidityGaugeV2Liquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem Curve liquidity gauge V2 token for Curve pool LP token (and store output as new collateral)\n    ICurveLiquidityGaugeV2 gauge = ICurveLiquidityGaugeV2(address(inputToken));\n    gauge.withdraw(inputAmount);\n    inputToken = IERC20Upgradeable(gauge.lp_token());\n\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurvePool curvePool = ICurvePool(\n      ICurveRegistry(0x7D86446dDb609eD0F5f8684AcF30380a356b2B4c).get_pool_from_lp_token(address(inputToken))\n    );\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n}\n"
    },
    "contracts/external/curve/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface ICurveLiquidityGaugeV2 {\n  function lp_token() external view returns (address);\n\n  function deposit(uint256 _value) external;\n\n  function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/oracles/mainnet/CurveLiquidityGaugeV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/curve/ICurveLiquidityGaugeV2.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title CurveLiquidityGaugeV2PriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice CurveLiquidityGaugeV2PriceOracle is a price oracle for Curve LiquidityGaugeV2 tokens (using the sender as a root oracle).\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n * This contract is expected to be called by a `MasterPriceOracle` with the necessary `CurveLpTokenPriceOracle` configured.\n * The price of a Curve LiquidityGaugeV2 token is the same as the price of its underlying Curve LP token.\n */\ncontract CurveLiquidityGaugeV2PriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Get the LiquidityGaugeV2 price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LiquidityGaugeV2/ETH price from Curve, with 18 decimals of precision.\n   * @param gauge The LiquidityGaugeV2 contract address for price retrieval.\n   */\n  function _price(address gauge) internal view returns (uint256) {\n    return BasePriceOracle(msg.sender).price(ICurveLiquidityGaugeV2(gauge).lp_token());\n  }\n}\n"
    },
    "contracts/liquidators/CurveMetapoolLpTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/curve/ICurveStableSwap.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CurveMetaPoolLpTokenLiquidator\n * @notice Redeems seized Curve Metapool LP token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CurveMetaPoolLpTokenLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Remove liquidity from Curve pool in the form of one coin only (and store output as new collateral)\n    ICurveStableSwap curvePool = ICurveStableSwap(address(inputToken));\n    (uint8 curveCoinIndex, address underlying) = abi.decode(strategyData, (uint8, address));\n    curvePool.remove_liquidity_one_coin(inputAmount, int128(int8(curveCoinIndex)), 1);\n    outputToken = IERC20Upgradeable(underlying == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ? address(0) : underlying);\n    outputAmount = address(outputToken) == address(0) ? address(this).balance : outputToken.balanceOf(address(this));\n\n    // Convert to W_NATIVE if ETH because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    if (address(outputToken) == address(0)) {\n      W_NATIVE.deposit{ value: outputAmount }();\n      return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n    }\n  }\n}\n"
    },
    "contracts/external/curve/ICurveStableSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ICurveStableSwap is IERC20Upgradeable {\n  function get_balances() external view returns (uint256[2] memory);\n\n  function remove_liquidity_one_coin(\n    uint256 _token_amount,\n    int128 i,\n    uint256 min_amount\n  ) external;\n}\n"
    },
    "contracts/liquidators/CEtherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICEther.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CEtherLiquidator\n * @notice Redeems seized Compound/Cream/Fuse CEther cTokens for underlying ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CEtherLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem cEther for underlying ETH (and store output as new collateral)\n    ICEther cEther = ICEther(address(inputToken));\n    uint256 redeemResult = cEther.redeem(inputAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cEther: error code not equal to 0\");\n    outputToken = IERC20Upgradeable(address(0));\n    outputAmount = address(this).balance;\n\n    // Convert to W_NATIVE because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxETHLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBoxETH.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxETHLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibETHv2\" (SafeBoxETH) tokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxETHLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ETH (and store output as new collateral)\n    ISafeBoxETH safeBox = ISafeBoxETH(address(inputToken));\n    safeBox.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(address(0));\n    outputAmount = address(this).balance;\n\n    // Convert to W_NATIVE because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n}\n"
    },
    "contracts/external/alpha/ISafeBoxETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBoxETH is IERC20Upgradeable {\n  function cToken() external view returns (address);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV1BankLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/Bank.sol\";\n\nimport \"../external/aave/IW_NATIVE.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV1BankLiquidator\n * @notice Redeems seized Alpha Homora v1 ibETH (Bank) tokens for ETH for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1BankLiquidator is IRedemptionStrategy {\n  /**\n   * @dev W_NATIVE contract object.\n   */\n  IW_NATIVE private constant W_NATIVE = IW_NATIVE(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ETH token (and store output as new collateral)\n    Bank bank = Bank(address(inputToken));\n    bank.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(address(0));\n    outputAmount = address(this).balance;\n\n    // Convert to W_NATIVE because `FuseSafeLiquidator.repayTokenFlashLoan` only supports tokens (not ETH) as output from redemptions (reverts on line 24 because `underlyingCollateral` is the zero address)\n    W_NATIVE.deposit{ value: outputAmount }();\n    return (IERC20Upgradeable(address(W_NATIVE)), outputAmount);\n  }\n}\n"
    },
    "contracts/external/alpha/Bank.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface Bank is IERC20Upgradeable {\n  /// @dev Return the total ETH entitled to the token holders. Be careful of unaccrued interests.\n  function totalETH() external view returns (uint256);\n\n  /// @dev Add more ETH to the bank. Hope to get some good returns.\n  function deposit() external payable;\n\n  /// @dev Withdraw ETH from the bank by burning the share tokens.\n  function withdraw(uint256 share) external;\n}\n"
    },
    "contracts/oracles/mainnet/AlphaHomoraV1PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/alpha/Bank.sol\";\n\n/**\n * @title AlphaHomoraV1PriceOracle\n * @notice Returns prices the Alpha Homora V1 ibETH ERC20 token.\n * @dev Implements the `PriceOracle` interface.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV1PriceOracle is IPriceOracle {\n  /**\n   * @dev Alpha Homora ibETH token contract object.\n   */\n  Bank public constant IBETH = Bank(0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A);\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    require(ICErc20(address(cToken)).underlying() == address(IBETH));\n    return (IBETH.totalETH() * 1e18) / IBETH.totalSupply();\n  }\n}\n"
    },
    "contracts/oracles/mainnet/HarvestPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/harvest/IFarmVault.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title HarvestPriceOracle\n * @notice Returns prices for iFARM.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev FARM ERC20 token contract.\n   */\n  address public constant FARM = 0xa0246c9032bC3A600820415aE600c6388619A14D;\n\n  /**\n   * @dev iFARM ERC20 token contract.\n   */\n  IFarmVault public constant IFARM = IFarmVault(0x1571eD0bed4D987fe2b498DdBaE7DFA19519F651);\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    if (token == address(IFARM)) return (BasePriceOracle(msg.sender).price(FARM) * IFARM.getPricePerFullShare()) / 1e18;\n    else revert(\"Invalid token address passed to HarvestPriceOracle.\");\n  }\n}\n"
    },
    "contracts/external/harvest/IFarmVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface IFarmVault {\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  // function store() external view returns (address);\n  function governance() external view returns (address);\n\n  function controller() external view returns (address);\n\n  function underlying() external view returns (address);\n\n  function strategy() external view returns (address);\n\n  function setStrategy(address _strategy) external;\n\n  function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n  function deposit(uint256 amountWei) external;\n\n  function depositFor(uint256 amountWei, address holder) external;\n\n  function withdrawAll() external;\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n  // hard work should be callable only by the controller (by the hard worker) or by governance\n  function doHardWork() external;\n}\n"
    },
    "contracts/liquidators/HarvestLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/harvest/IFarmVault.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title HarvestLiquidator\n * @notice Exchanges seized iFARM token collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract HarvestLiquidator is IRedemptionStrategy {\n  /**\n   * @dev FARM ERC20 token contract.\n   */\n  IERC20Upgradeable public constant FARM = IERC20Upgradeable(0xa0246c9032bC3A600820415aE600c6388619A14D);\n\n  /**\n   * @dev iFARM ERC20 token contract.\n   */\n  IFarmVault public constant IFARM = IFarmVault(0x1571eD0bed4D987fe2b498DdBaE7DFA19519F651);\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    if (address(inputToken) == address(IFARM)) {\n      IFARM.withdrawAll();\n      outputToken = FARM;\n      outputAmount = outputToken.balanceOf(address(this));\n    } else revert(\"Invalid token address passed to HarvestLiquidator.\");\n  }\n}\n"
    },
    "contracts/oracles/mainnet/AlphaHomoraV2PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/alpha/ISafeBox.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title AlphaHomoraV2PriceOracle\n * @notice Returns prices from Alpha Homora v2 \"ibTokenV2\" tokens (e.g., ibETHv2, ibDAIv2).\n * @dev Implements `PriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2PriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair ibTokenV2/ETH price, with 18 decimals of precision.\n   * @param safeBox The SafeBox (or SafeBoxETH) contract address for price retrieval.\n   */\n  function _price(address safeBox) internal view returns (uint256) {\n    // Get the cToken's underlying ibToken's underlying cToken\n    ICErc20 underlyingCErc20 = ICErc20(ISafeBox(safeBox).cToken());\n\n    // Get the token underlying the underlying cToken\n    address baseToken = underlyingCErc20.underlying();\n\n    // ibTokenV2/ETH price = underlying cToken/ETH price = underlying cToken/token price * base token/ETH price\n    return (underlyingCErc20.exchangeRateStored() * BasePriceOracle(msg.sender).price(baseToken)) / 1e18;\n  }\n}\n"
    },
    "contracts/external/alpha/ISafeBox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ISafeBox is IERC20Upgradeable {\n  function cToken() external view returns (address);\n\n  function uToken() external view returns (address);\n\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/liquidators/AlphaHomoraV2SafeBoxLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/alpha/ISafeBox.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title AlphaHomoraV2SafeBoxLiquidator\n * @notice Redeems seized Alpha Homora v2 \"ibTokenV2\" or SafeBox tokens (e.g., ibDAIv2) for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract AlphaHomoraV2SafeBoxLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem ibTokenV2 for underlying ERC20 token (and store output as new collateral)\n    ISafeBox safeBox = ISafeBox(address(inputToken));\n    safeBox.withdraw(inputAmount);\n    outputToken = IERC20Upgradeable(safeBox.uToken());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/oracles/default/UniswapLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title UniswapLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice UniswapLpTokenPriceOracle is a price oracle for Uniswap (and SushiSwap) LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract UniswapLpTokenPriceOracle is IPriceOracle {\n  /**\n   * @dev wtoken contract address.\n   */\n  address public immutable wtoken;\n\n  /**\n   * @dev Constructor to set admin and canAdminOverwrite, wtoken address and native token USD price feed address\n   */\n  constructor(address _wtoken) {\n    wtoken = _wtoken;\n  }\n\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH)\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Uniswap, with 18 decimals of precision.\n   */\n  function _price(address token) internal view virtual returns (uint256) {\n    IUniswapV2Pair pair = IUniswapV2Pair(token);\n    uint256 totalSupply = pair.totalSupply();\n    if (totalSupply == 0) return 0;\n    (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n    address token0 = pair.token0();\n    address token1 = pair.token1();\n\n    // Get fair price of non-WETH token (underlying the pair) in terms of ETH\n    uint256 token0FairPrice = token0 == wtoken\n      ? 1e18\n      : (BasePriceOracle(msg.sender).price(token0) * 1e18) / (10**uint256(ERC20Upgradeable(token0).decimals()));\n    uint256 token1FairPrice = token1 == wtoken\n      ? 1e18\n      : (BasePriceOracle(msg.sender).price(token1) * 1e18) / (10**uint256(ERC20Upgradeable(token1).decimals()));\n\n    // Implementation from https://github.com/AlphaFinanceLab/homora-v2/blob/e643392d582c81f6695136971cff4b685dcd2859/contracts/oracle/UniswapV2Oracle.sol#L18\n    uint256 sqrtK = (sqrt(reserve0 * reserve1) * (2**112)) / totalSupply;\n    return (((sqrtK * 2 * sqrt(token0FairPrice)) / (2**56)) * sqrt(token1FairPrice)) / (2**56);\n  }\n\n  /**\n   * @dev Fast square root function.\n   * Implementation from: https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c5292fb8291a0\n   * Original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n   */\n  function sqrt(uint256 x) internal pure returns (uint256) {\n    if (x == 0) return 0;\n    uint256 xx = x;\n    uint256 r = 1;\n\n    if (xx >= 0x100000000000000000000000000000000) {\n      xx >>= 128;\n      r <<= 64;\n    }\n    if (xx >= 0x10000000000000000) {\n      xx >>= 64;\n      r <<= 32;\n    }\n    if (xx >= 0x100000000) {\n      xx >>= 32;\n      r <<= 16;\n    }\n    if (xx >= 0x10000) {\n      xx >>= 16;\n      r <<= 8;\n    }\n    if (xx >= 0x100) {\n      xx >>= 8;\n      r <<= 4;\n    }\n    if (xx >= 0x10) {\n      xx >>= 4;\n      r <<= 2;\n    }\n    if (xx >= 0x8) {\n      r <<= 1;\n    }\n\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1;\n    r = (r + x / r) >> 1; // Seven iterations should be enough\n    uint256 r1 = x / r;\n    return (r < r1 ? r : r1);\n  }\n}\n"
    },
    "contracts/oracles/default/SushiBarPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/sushi/SushiBar.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title SushiBarPriceOracle\n * @notice Returns prices for SushiBar (xSUSHI).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    SushiBar sushiBar = SushiBar(token);\n    IERC20Upgradeable sushi = sushiBar.sushi();\n    uint256 sushiEthPrice = BasePriceOracle(msg.sender).price(address(sushi));\n    return (sushi.balanceOf(token) * sushiEthPrice) / sushiBar.totalSupply();\n  }\n}\n"
    },
    "contracts/external/sushi/SushiBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nabstract contract SushiBar is IERC20Upgradeable {\n  IERC20Upgradeable public sushi;\n\n  // Enter the bar. Pay some SUSHIs. Earn some shares.\n  function enter(uint256 _amount) public virtual;\n\n  // Leave the bar. Claim back your SUSHIs.\n  function leave(uint256 _share) public virtual;\n}\n"
    },
    "contracts/liquidators/SushiBarLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/sushi/SushiBar.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SushiBarLiquidator\n * @notice Redeems SushiBar (xSUSHI) for underlying SUSHI for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SushiBarLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unstake sOHM (and store output OHM as new collateral)\n    SushiBar sushiBar = SushiBar(address(inputToken));\n    sushiBar.leave(inputAmount);\n    outputToken = IERC20Upgradeable(sushiBar.sushi());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/oracles/default/FixedTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedTokenPriceOracle\n * @notice Returns token prices using the prices for another token.\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedTokenPriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev The token to base prices on.\n   */\n  address public immutable baseToken;\n\n  /**\n   * @dev Sets the token to base prices on.\n   */\n  constructor(address _baseToken) {\n    baseToken = _baseToken;\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   * @param underlying The underlying token address for which to get the price.\n   * @return Price denominated in ETH (scaled by 1e18)\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @notice Fetches the token/ETH price, with 18 decimals of precision.\n   */\n  function _price(address token) internal view returns (uint256) {\n    return BasePriceOracle(msg.sender).price(baseToken);\n  }\n}\n"
    },
    "contracts/oracles/default/FixedNativePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title FixedEthPriceOracle\n * @notice Returns fixed prices of 1 denominated in the chain's native token for all tokens (expected to be used under a `MasterPriceOracle`).\n * @dev Implements `PriceOracle` and `BasePriceOracle`.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract FixedNativePriceOracle is IPriceOracle, BasePriceOracle {\n  /**\n   * @dev Returns the price in native token of `underlying` (implements `BasePriceOracle`).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return 1e18;\n  }\n\n  /**\n   * @notice Returns the price in native token of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in native token of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    // Get underlying token address\n    address underlying = ICErc20(address(cToken)).underlying();\n\n    // Format and return price\n    return uint256(1e36) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n}\n"
    },
    "contracts/oracles/default/BalancerLpTokenPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport \"../../external/compound/IPriceOracle.sol\";\nimport \"../../external/compound/ICToken.sol\";\nimport \"../../external/compound/ICErc20.sol\";\n\nimport \"../../external/balancer/IBalancerPool.sol\";\nimport \"../../external/balancer/BNum.sol\";\n\nimport \"../BasePriceOracle.sol\";\n\n/**\n * @title BalancerLpTokenPriceOracle\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n * @notice BalancerLpTokenPriceOracle is a price oracle for Balancer LP tokens.\n * @dev Implements the `PriceOracle` interface used by Fuse pools (and Compound v2).\n */\ncontract BalancerLpTokenPriceOracle is IPriceOracle, BasePriceOracle, BNum {\n  /**\n   * @notice Get the LP token price price for an underlying token address.\n   * @param underlying The underlying token address for which to get the price (set to zero address for ETH).\n   * @return Price denominated in ETH (scaled by 1e18).\n   */\n  function price(address underlying) external view override returns (uint256) {\n    return _price(underlying);\n  }\n\n  /**\n   * @notice Returns the price in ETH of the token underlying `cToken`.\n   * @dev Implements the `PriceOracle` interface for Fuse pools (and Compound v2).\n   * @return Price in ETH of the token underlying `cToken`, scaled by `10 ** (36 - underlyingDecimals)`.\n   */\n  function getUnderlyingPrice(ICToken cToken) external view override returns (uint256) {\n    address underlying = ICErc20(address(cToken)).underlying();\n    // Comptroller needs prices to be scaled by 1e(36 - decimals)\n    // Since `_price` returns prices scaled by 18 decimals, we must scale them by 1e(36 - 18 - decimals)\n    return (_price(underlying) * 1e18) / (10**uint256(ERC20Upgradeable(underlying).decimals()));\n  }\n\n  /**\n   * @dev Fetches the fair LP token/ETH price from Balancer, with 18 decimals of precision.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n   */\n  function _price(address underlying) internal view virtual returns (uint256) {\n    IBalancerPool pool = IBalancerPool(underlying);\n    require(pool.getNumTokens() == 2, \"Balancer pool must have exactly 2 tokens.\");\n    address[] memory tokens = pool.getFinalTokens();\n    address tokenA = tokens[0];\n    address tokenB = tokens[1];\n    uint256 pxA = BasePriceOracle(msg.sender).price(tokenA);\n    uint256 pxB = BasePriceOracle(msg.sender).price(tokenB);\n    uint8 decimalsA = ERC20Upgradeable(tokenA).decimals();\n    uint8 decimalsB = ERC20Upgradeable(tokenB).decimals();\n    if (decimalsA < 18) pxA = pxA * (10**(18 - uint256(decimalsA)));\n    if (decimalsA > 18) pxA = pxA / (10**(uint256(decimalsA) - 18));\n    if (decimalsB < 18) pxB = pxB * (10**(18 - uint256(decimalsB)));\n    if (decimalsB > 18) pxB = pxB / (10**(uint256(decimalsB) - 18));\n    (uint256 fairResA, uint256 fairResB) = computeFairReserves(\n      pool.getBalance(tokenA),\n      pool.getBalance(tokenB),\n      pool.getNormalizedWeight(tokenA),\n      pool.getNormalizedWeight(tokenB),\n      pxA,\n      pxB\n    );\n    // use fairReserveA and fairReserveB to compute LP token price\n    // LP price = (fairResA * pxA + fairResB * pxB) / totalLPSupply\n    return (fairResA * pxA + fairResB * pxB) / pool.totalSupply();\n  }\n\n  /**\n   * @dev Returns fair reserve amounts given spot reserves, weights, and fair prices.\n   * Source: https://github.com/AlphaFinanceLab/homora-v2/blob/master/contracts/oracle/BalancerPairOracle.sol\n   * @param resA Reserve of the first asset\n   * @param resB Reserev of the second asset\n   * @param wA Weight of the first asset\n   * @param wB Weight of the second asset\n   * @param pxA Fair price of the first asset\n   * @param pxB Fair price of the second asset\n   */\n  function computeFairReserves(\n    uint256 resA,\n    uint256 resB,\n    uint256 wA,\n    uint256 wB,\n    uint256 pxA,\n    uint256 pxB\n  ) internal pure returns (uint256 fairResA, uint256 fairResB) {\n    // NOTE: wA + wB = 1 (normalize weights)\n    // constant product = resA^wA * resB^wB\n    // constraints:\n    // - fairResA^wA * fairResB^wB = constant product\n    // - fairResA * pxA / wA = fairResB * pxB / wB\n    // Solving equations:\n    // --> fairResA^wA * (fairResA * (pxA * wB) / (wA * pxB))^wB = constant product\n    // --> fairResA / r1^wB = constant product\n    // --> fairResA = resA^wA * resB^wB * r1^wB\n    // --> fairResA = resA * (resB/resA)^wB * r1^wB = resA * (r1/r0)^wB\n    uint256 r0 = bdiv(resA, resB);\n    uint256 r1 = bdiv(bmul(wA, pxB), bmul(wB, pxA));\n    // fairResA = resA * (r1 / r0) ^ wB\n    // fairResB = resB * (r0 / r1) ^ wA\n    if (r0 > r1) {\n      uint256 ratio = bdiv(r1, r0);\n      fairResA = bmul(resA, bpow(ratio, wB));\n      fairResB = bdiv(resB, bpow(ratio, wA));\n    } else {\n      uint256 ratio = bdiv(r0, r1);\n      fairResA = bdiv(resA, bpow(ratio, wB));\n      fairResB = bmul(resB, bpow(ratio, wA));\n    }\n  }\n}\n"
    },
    "contracts/external/balancer/IBalancerPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\ninterface IBalancerPool {\n  function getFinalTokens() external view returns (address[] memory);\n\n  function getNormalizedWeight(address token) external view returns (uint256);\n\n  function getSwapFee() external view returns (uint256);\n\n  function getNumTokens() external view returns (uint256);\n\n  function getBalance(address token) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n  function joinswapExternAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    uint256 minPoolAmountOut\n  ) external returns (uint256 poolAmountOut);\n\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  function exitswapExternAmountOut(\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPoolAmountIn\n  ) external returns (uint256 poolAmountIn);\n}\n"
    },
    "contracts/external/balancer/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nimport \"./BConst.sol\";\n\ncontract BNum is BConst {\n  function btoi(uint256 a) internal pure returns (uint256) {\n    return a / BONE;\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    return btoi(a) * BONE;\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"ERR_ADD_OVERFLOW\");\n    return c;\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    (uint256 c, bool flag) = bsubSign(a, b);\n    require(!flag, \"ERR_SUB_UNDERFLOW\");\n    return c;\n  }\n\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    if (a >= b) {\n      return (a - b, false);\n    } else {\n      return (b - a, true);\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c0 = a * b;\n    require(a == 0 || c0 / a == b, \"ERR_MUL_OVERFLOW\");\n    uint256 c1 = c0 + (BONE / 2);\n    require(c1 >= c0, \"ERR_MUL_OVERFLOW\");\n    uint256 c2 = c1 / BONE;\n    return c2;\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"ERR_DIV_ZERO\");\n    uint256 c0 = a * BONE;\n    require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bmul overflow\n    uint256 c1 = c0 + (b / 2);\n    require(c1 >= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n    uint256 c2 = c1 / b;\n    return c2;\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    uint256 z = n % 2 != 0 ? a : BONE;\n\n    for (n /= 2; n != 0; n /= 2) {\n      a = bmul(a, a);\n\n      if (n % 2 != 0) {\n        z = bmul(z, a);\n      }\n    }\n    return z;\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    require(base >= MIN_BPOW_BASE, \"ERR_BPOW_BASE_TOO_LOW\");\n    require(base <= MAX_BPOW_BASE, \"ERR_BPOW_BASE_TOO_HIGH\");\n\n    uint256 whole = bfloor(exp);\n    uint256 remain = bsub(exp, whole);\n\n    uint256 wholePow = bpowi(base, btoi(whole));\n\n    if (remain == 0) {\n      return wholePow;\n    }\n\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n    return bmul(wholePow, partialResult);\n  }\n\n  function bpowApprox(\n    uint256 base,\n    uint256 exp,\n    uint256 precision\n  ) internal pure returns (uint256) {\n    // term 0:\n    uint256 a = exp;\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\n    uint256 term = BONE;\n    uint256 sum = term;\n    bool negative = false;\n\n    // term(k) = numer / denom\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\n    // continue until term is less than precision\n    for (uint256 i = 1; term >= precision; i++) {\n      uint256 bigK = i * BONE;\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n      term = bmul(term, bmul(c, x));\n      term = bdiv(term, bigK);\n      if (term == 0) break;\n\n      if (xneg) negative = !negative;\n      if (cneg) negative = !negative;\n      if (negative) {\n        sum = bsub(sum, term);\n      } else {\n        sum = badd(sum, term);\n      }\n    }\n\n    return sum;\n  }\n}\n"
    },
    "contracts/external/balancer/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\ncontract BConst {\n  uint256 public constant BONE = 10**18;\n\n  uint256 public constant MIN_BOUND_TOKENS = 2;\n  uint256 public constant MAX_BOUND_TOKENS = 8;\n\n  uint256 public constant MIN_FEE = BONE / 10**6;\n  uint256 public constant MAX_FEE = BONE / 10;\n  uint256 public constant EXIT_FEE = 0;\n\n  uint256 public constant MIN_WEIGHT = BONE;\n  uint256 public constant MAX_WEIGHT = BONE * 50;\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  uint256 public constant MIN_BALANCE = BONE / 10**12;\n\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  uint256 public constant BPOW_PRECISION = BONE / 10**10;\n\n  uint256 public constant MAX_IN_RATIO = BONE / 2;\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n}\n"
    },
    "contracts/liquidators/BalancerPoolTokenLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/balancer/IBalancerPool.sol\";\nimport \"../external/uniswap/IUniswapV2Router02.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title BalancerPoolTokenLiquidator\n * @notice Exchanges seized Balancer Pool Token (BPT) collateral for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract BalancerPoolTokenLiquidator is IRedemptionStrategy {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n     */\n    function safeApprove(IERC20Upgradeable token, address to, uint256 minAmount) private {\n        uint256 allowance = token.allowance(address(this), to);\n\n        if (allowance < minAmount) {\n            if (allowance > 0) token.safeApprove(to, 0);\n            token.safeApprove(to, type(uint256).max);\n        }\n    }\n\n    /**\n     * @notice Redeems custom collateral `token` for an underlying token.\n     * @param inputToken The input wrapped token to be redeemed for an underlying token.\n     * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n     * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n     * @return outputToken The underlying ERC20 token outputted.\n     * @return outputAmount The quantity of underlying tokens outputted.\n     */\n    function redeem(IERC20Upgradeable inputToken, uint256 inputAmount, bytes memory strategyData) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n        // Exit Balancer pool\n        IBalancerPool balancerPool = IBalancerPool(address(inputToken));\n        address[] memory tokens = balancerPool.getFinalTokens();\n        uint256[] memory minAmountsOut = new uint256[](tokens.length);\n        balancerPool.exitPool(inputAmount, minAmountsOut);\n\n        // Swap underlying tokens\n        (IUniswapV2Router02 uniswapV2Router, address[][] memory swapPaths) = abi.decode(strategyData, (IUniswapV2Router02, address[][]));\n        require(swapPaths.length == tokens.length, \"Swap paths array length must match the number of underlying tokens in the Balancer pool.\");\n        for (uint256 i = 1; i < swapPaths.length; i++)\n            require((swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]) == (swapPaths[i].length > 0 ? swapPaths[i][swapPaths[i].length - 1] : tokens[i]), \"All underlying token swap paths must output the same token.\");\n\n        for (uint256 i = 0; i < swapPaths.length; i++) if (swapPaths[i].length > 0 && swapPaths[i][swapPaths[i].length - 1] != tokens[i]) {\n            uint256 swapAmountIn = IERC20Upgradeable(tokens[i]).balanceOf(address(this));\n            safeApprove(IERC20Upgradeable(tokens[i]), address(uniswapV2Router), swapAmountIn);\n            uniswapV2Router.swapExactTokensForTokens(swapAmountIn, 0, swapPaths[i], address(this), block.timestamp);\n        }\n\n        // Get new collateral\n        outputToken = IERC20Upgradeable(swapPaths[0].length > 0 ? swapPaths[0][swapPaths[0].length - 1] : tokens[0]);\n        outputAmount = outputToken.balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/liquidators/SOhmLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/olympus/sOlympus.sol\";\nimport \"../external/olympus/OlympusStaking.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title SOhmLiquidator\n * @notice Redeems sOHM for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract SOhmLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Unstake sOHM (and store output OHM as new collateral)\n    sOlympus token = sOlympus(address(inputToken));\n    OlympusStaking staking = OlympusStaking(token.stakingContract());\n    safeApprove(inputToken, address(staking), inputAmount);\n    staking.unstake(inputAmount, false);\n    outputToken = IERC20Upgradeable(staking.OHM());\n    outputAmount = inputAmount;\n  }\n}\n"
    },
    "contracts/external/olympus/sOlympus.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nabstract contract sOlympus {\n  address public stakingContract;\n}\n"
    },
    "contracts/external/olympus/OlympusStaking.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nabstract contract OlympusStaking {\n  address public OHM;\n\n  function unstake(uint256 _amount, bool _trigger) external virtual;\n}\n"
    },
    "contracts/liquidators/DolaStabilizerLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../external/inverse/Stabilizer.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title DolaStabilizerLiquidator\n * @notice Buys DOLA using DAI and sells DOLA for DAI using the Anchor Stabilizer contract as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract DolaStabilizerLiquidator is IRedemptionStrategy {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n\n  /**\n   * @dev Anchor's Stabilizer contract for DOLA.\n   */\n  Stabilizer public STABILIZER = Stabilizer(0x7eC0D931AFFBa01b77711C2cD07c76B970795CDd);\n\n  /**\n   * @dev Stabilizer's fee denominator.\n   */\n  uint256 public constant FEE_DENOMINATOR = 10000;\n\n  /**\n   * @dev Internal function to approve unlimited tokens of `erc20Contract` to `to`.\n   */\n  function safeApprove(\n    IERC20Upgradeable token,\n    address to,\n    uint256 minAmount\n  ) private {\n    uint256 allowance = token.allowance(address(this), to);\n\n    if (allowance < minAmount) {\n      if (allowance > 0) token.safeApprove(to, 0);\n      token.safeApprove(to, type(uint256).max);\n    }\n  }\n\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Approve input token to Stabilizer\n    safeApprove(inputToken, address(STABILIZER), inputAmount);\n\n    // Buy or sell depending on if input is synth or reserve\n    address synth = STABILIZER.synth();\n    address reserve = STABILIZER.reserve();\n\n    if (address(inputToken) == reserve) {\n      // Buy DOLA with DAI\n      outputAmount = (inputAmount * FEE_DENOMINATOR) / (FEE_DENOMINATOR + STABILIZER.buyFee());\n      STABILIZER.buy(outputAmount);\n      outputToken = IERC20Upgradeable(synth);\n    } else if (address(inputToken) == synth) {\n      // Sell DOLA for DAI\n      STABILIZER.sell(inputAmount);\n      outputToken = IERC20Upgradeable(reserve);\n      outputAmount = outputToken.balanceOf(address(this));\n    }\n  }\n}\n"
    },
    "contracts/external/inverse/Stabilizer.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity >=0.8.0;\n\ninterface Stabilizer {\n  function buyFee() external view returns (uint256);\n\n  function synth() external view returns (address);\n\n  function reserve() external view returns (address);\n\n  function buy(uint256 amount) external;\n\n  function sell(uint256 amount) external;\n}\n"
    },
    "contracts/liquidators/PoolTogetherLiquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/pooltogether/ControlledTokenInterface.sol\";\nimport \"../external/pooltogether/PrizePoolInterface.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title PoolTogetherLiquidator\n * @notice Redeems PoolTogether PcTokens for underlying assets for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract PoolTogetherLiquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem PcToken (and store output as new collateral)\n    ControlledTokenInterface token = ControlledTokenInterface(address(inputToken));\n    PrizePoolInterface controller = PrizePoolInterface(token.controller());\n    controller.withdrawInstantlyFrom(address(this), inputAmount, address(token), type(uint256).max);\n    outputToken = IERC20Upgradeable(controller.token());\n    outputAmount = inputAmount;\n  }\n}\n"
    },
    "contracts/external/pooltogether/ControlledTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\n/// @title Controlled ERC20 Token\n/// @notice ERC20 Tokens with a controller for minting & burning\ninterface ControlledTokenInterface {\n  /// @notice Interface to the contract responsible for controlling mint/burn\n  function controller() external view returns (address);\n}\n"
    },
    "contracts/external/pooltogether/PrizePoolInterface.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0;\n\n/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.\n/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.\n/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens\ninterface PrizePoolInterface {\n  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.\n  /// @param from The address to redeem tokens from.\n  /// @param amount The amount of tokens to redeem for assets.\n  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)\n  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.\n  /// @return The actual exit fee paid\n  function withdrawInstantlyFrom(\n    address from,\n    uint256 amount,\n    address controlledToken,\n    uint256 maximumExitFee\n  ) external returns (uint256);\n\n  /// @dev Returns the address of the underlying ERC20 asset\n  /// @return The address of the asset\n  function token() external view returns (address);\n}\n"
    },
    "contracts/liquidators/CErc20Liquidator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../external/compound/ICErc20.sol\";\n\nimport \"./IRedemptionStrategy.sol\";\n\n/**\n * @title CErc20Liquidator\n * @notice Redeems seized Compound/Cream/Fuse CErc20 cTokens for underlying tokens for use as a step in a liquidation.\n * @author David Lucid <david@rari.capital> (https://github.com/davidlucid)\n */\ncontract CErc20Liquidator is IRedemptionStrategy {\n  /**\n   * @notice Redeems custom collateral `token` for an underlying token.\n   * @param inputToken The input wrapped token to be redeemed for an underlying token.\n   * @param inputAmount The amount of the input wrapped token to be redeemed for an underlying token.\n   * @param strategyData The ABI-encoded data to be used in the redemption strategy logic.\n   * @return outputToken The underlying ERC20 token outputted.\n   * @return outputAmount The quantity of underlying tokens outputted.\n   */\n  function redeem(\n    IERC20Upgradeable inputToken,\n    uint256 inputAmount,\n    bytes memory strategyData\n  ) external override returns (IERC20Upgradeable outputToken, uint256 outputAmount) {\n    // Redeem cErc20 for underlying ERC20 token (and store output as new collateral)\n    ICErc20 cErc20 = ICErc20(address(inputToken));\n    uint256 redeemResult = cErc20.redeem(inputAmount);\n    require(redeemResult == 0, \"Error calling redeeming seized cErc20: error code not equal to 0\");\n    outputToken = IERC20Upgradeable(cErc20.underlying());\n    outputAmount = outputToken.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/compound/CDaiDelegate.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"./CErc20Delegate.sol\";\n\n/**\n * @title Compound's CDai Contract\n * @notice CToken which wraps Multi-Collateral DAI\n * @author Compound\n */\ncontract CDaiDelegate is CErc20Delegate {\n  /**\n   * @notice DAI adapter address\n   */\n  address public daiJoinAddress;\n\n  /**\n   * @notice DAI Savings Rate (DSR) pot address\n   */\n  address public potAddress;\n\n  /**\n   * @notice DAI vat address\n   */\n  address public vatAddress;\n\n  /**\n   * @notice Delegate interface to become the implementation\n   * @param data The encoded arguments for becoming\n   */\n  function _becomeImplementation(bytes calldata data) external override {\n    require(msg.sender == address(this) || hasAdminRights(), \"only self or admin may call _becomeImplementation\");\n\n    // Decode data\n    (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n    return _becomeImplementation(daiJoinAddress_, potAddress_);\n  }\n\n  /**\n   * @notice Explicit interface to become the implementation\n   * @param daiJoinAddress_ DAI adapter address\n   * @param potAddress_ DAI Savings Rate (DSR) pot address\n   */\n  function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n    // Get dai and vat and sanity check the underlying\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n    PotLike pot = PotLike(potAddress_);\n    GemLike dai = daiJoin.dai();\n    VatLike vat = daiJoin.vat();\n    require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n    // Remember the relevant addresses\n    daiJoinAddress = daiJoinAddress_;\n    potAddress = potAddress_;\n    vatAddress = address(vat);\n\n    // Approve moving our DAI into the vat through daiJoin\n    dai.approve(daiJoinAddress, type(uint256).max);\n\n    // Approve the pot to transfer our funds within the vat\n    vat.hope(potAddress);\n    vat.hope(daiJoinAddress);\n\n    // Accumulate DSR interest -- must do this in order to doTransferIn\n    pot.drip();\n\n    // Transfer all cash in (doTransferIn does this regardless of amount)\n    doTransferIn(address(this), 0);\n  }\n\n  /**\n   * @notice Delegate interface to resign the implementation\n   */\n  function _resignImplementation() internal override {\n    // Transfer all cash out of the DSR - note that this relies on self-transfer\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Accumulate interest\n    pot.drip();\n\n    // Calculate the total amount in the pot, and move it out\n    uint256 pie = pot.pie(address(this));\n    pot.exit(pie);\n\n    // Checks the actual balance of DAI in the vat after the pot exit\n    uint256 bal = vat.dai(address(this));\n\n    // Remove our whole balance\n    daiJoin.exit(address(this), bal / RAY);\n  }\n\n  /*** CToken Overrides ***/\n\n  /**\n   * @notice Accrues DSR then applies accrued interest to total borrows and reserves\n   * @dev This calculates interest accrued from the last checkpointed block\n   *      up to the current block and writes new checkpoint to storage.\n   */\n  function accrueInterest() public override returns (uint256) {\n    // Accumulate DSR interest\n    PotLike(potAddress).drip();\n\n    // Accumulate CToken interest\n    return super.accrueInterest();\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n   * @dev This excludes the value of the current message, if any\n   * @return The quantity of underlying tokens owned by this contract\n   */\n  function getCashPrior() internal view override returns (uint256) {\n    PotLike pot = PotLike(potAddress);\n    uint256 pie = pot.pie(address(this));\n    return mul(pot.chi(), pie) / RAY;\n  }\n\n  /**\n   * @notice Transfer the underlying to this contract and sweep into DSR pot\n   * @param from Address to transfer funds from\n   * @param amount Amount of underlying to transfer\n   * @return The actual amount that is transferred\n   */\n  function doTransferIn(address from, uint256 amount) internal override returns (uint256) {\n    // Perform the EIP-20 transfer in\n    EIP20Interface token = EIP20Interface(underlying);\n    require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    GemLike dai = GemLike(underlying);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Convert all our DAI to internal DAI in the vat\n    daiJoin.join(address(this), dai.balanceOf(address(this)));\n\n    // Checks the actual balance of DAI in the vat after the join\n    uint256 bal = vat.dai(address(this));\n\n    // Calculate the percentage increase to th pot for the entire vat, and move it in\n    // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\n    uint256 pie = bal / pot.chi();\n    pot.join(pie);\n\n    return amount;\n  }\n\n  /**\n   * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\n   * @param to Address to transfer funds to\n   * @param amount Amount of underlying to transfer\n   */\n  function doTransferOut(address to, uint256 amount) internal override {\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n\n    // Calculate the percentage decrease from the pot, and move that much out\n    // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\n    uint256 pie = add(mul(amount, RAY) / pot.chi(), 1);\n    pot.exit(pie);\n\n    daiJoin.exit(to, amount);\n  }\n\n  /*** Maker Internals ***/\n\n  uint256 constant RAY = 10**27;\n\n  function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require((z = x + y) >= x, \"add-overflow\");\n  }\n\n  function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n  }\n}\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n  function chi() external view returns (uint256);\n\n  function pie(address) external view returns (uint256);\n\n  function drip() external returns (uint256);\n\n  function join(uint256) external;\n\n  function exit(uint256) external;\n}\n\ninterface GemLike {\n  function approve(address, uint256) external;\n\n  function balanceOf(address) external view returns (uint256);\n\n  function transferFrom(\n    address,\n    address,\n    uint256\n  ) external returns (bool);\n}\n\ninterface VatLike {\n  function dai(address) external view returns (uint256);\n\n  function hope(address) external;\n}\n\ninterface DaiJoinLike {\n  function vat() external returns (VatLike);\n\n  function dai() external returns (GemLike);\n\n  function join(address, uint256) external payable;\n\n  function exit(address, uint256) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}